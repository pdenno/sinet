* Notes on org mode
** M-x widen -- When you lose text!
** Useful Links
*** The tutorial 
 [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][The tutorial]]
 http://orgmode.org/manual/index.html
    
** Key bindings 
*** Opening and closing
**** Cntl-tab open/close at point
**** Shift-tab open/close whole document (circular)
**** Shift-cntl open/close current
*** Linking
**** C-c l (store link)
**** C-c C-l bring the link here
**** C-c C-l also to edit a link (when point is on the link)
**** Links look like this: [[link][description] ...] 
  Here I inserted elipsis to stop that from turning into a link. An actual 
  link to a web page would appear like this: [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][the tutorial]]. 
**** C-c C-o (open) open a link without the mouse.   
    This is especially sweet for local links. It splits showing two buffers. 

*** TODO Operations
**** M-Shift-Ret open a TODO.

**** C-c C-t (terminate?) marks a TODO as done.
*** Miscellaneous
**** Timestamps C-c . (C-c ! is similar but 'without creating an agenda entry' whatever that means.)

**** Source Code C-c ' (open and close) #+BEGIN_SRC clojure ... #+END_SRC

**** Footnotes [fn:1] is a reference.  Says it needs to start with "fn:" but it doesn't. 
     The definition must begin in column 1. 
* Org Mode Tasks
** DONE Start using org for programming notes.
   CLOSED: [2017-10-14 Sat 18:06]
** DONE Learn how to 'open' and edit a link. Right now the org manual link is just the URL. 
   CLOSED: [2017-10-15 Sun 12:25]
** TODO Find out what good the source code marking is. I see that you can edit it with C-c ' but so what?

* Miscellaneous loosly related
** [[https://www.datasciencecentral.com/profiles/blogs/artificial-intelligence-is-not-fake-intelligence][This]] neural net chart is pretty good.
   Much better discussion of it [[http://www.asimovinstitute.org/neural-network-zoo/][here]].
   23 Types of Regression, [[https://www.datasciencecentral.com/profiles/blogs/23-types-of-regression][here]].
   

** Clojure.core is one file of about 8000 lines. Worth a read! Includes futures, etc. 

* Sinet/MJPdes/SPNtools TODOs
** TODO Investigate the relative accuracy of the new interpretation. Update fitness_test.clj. See notes <2018-01-06 Sat> 
** TODO Can I halt interpretation when it looks like pulling from an empty buffer?
        Yeah, but if "start-job" means what we want it to mean, that will never happen in the rgraph.
** TODO Decide whether setting all transitions to timed makes sense for simple-reach. See discussion <2017-10-15 Sun>
** TODO Investigate possible bugs with MJPdes 'coordination' and create more 'deterministic' test cases.
** DONE Conceive of a strategy for using exceptional fitness
   CLOSED: [2017-12-07 Thu 11:17]
 [I think I missed the whole point in the stuff below, but just to be sure: There are messages that
  are not associated with transitions. They are associated with STATES. I may have a place in the network
  that is essentially "M1-BLOCKED" but it won't be labelled as such! A nice thing about this is that 
  I DON'T WANT to get a M1-BLOCKED message every (vanishing) time that there is a token in that place.
  I only want these when the buffer is filled (a state where the buffer place looms large). That's what 
  will happen, and we don't have to worry about labeling the "m1-blocked" place!]

 In some cases like blocking/starving it seem that having a place represent the state is appropriate. 
 But is that generally the case? This ToDo is closely related to the next about vanishing transitions,
 but I don't think it is the same issue. I think I need to see the result of the "mild blocking" 
 situation before I can sort this out. Remember that the goal is to get rates out of these things. 

 (More on this): I think there might be quirk to what I'm trying to do: I'd like to allow the PN to handle 
 exceptional messages just as some do for block/starve, but block/starve are places, not transitions, and 
 they won't have meaningful names. I think I'll just wait to explore this after getting the exceptional 
 fitness hooked in. 

** DONE Deal with vanishing transitions. 
   CLOSED: [2017-12-07 Thu 11:17]
 I need to generate blocking/starving messages ONLY when the net sojourns at blocking/starving. 
 So simulation has to be better and I need to distinguish these immediate transitions some how. 

** TODO Find a way to find the pathname "to a namespace" so I can run tests on dependent packages. 
** DONE Create a project for simple neural nets. Sinet log date <2017-10-23 Mon> has some code for it. 
   CLOSED: [2017-11-01 Wed 19:53]

** DONE Fix MJPdes as described in log <2017-10-17 Tue>
   CLOSED: [2017-10-22 Sun 14:25]
** TODO Rewrite disorder code to use rgraph.

** TODO Need a way to get the world after a time out. 
** DONE Does the :pop really need to be on app-info?
   CLOSED: [2017-12-19 Tue 16:07]
** DONE Every arc needs a :bind and :priority
   CLOSED: [2017-12-19 Tue 16:07]
** DONE Perform experiments that will tell you what the value of exceptional messages is. 
   CLOSED: [2017-12-07 Thu 11:20]
        I think one can learn the lower-bound on the buffer size just by witnessing how
        many jobs one machine can get ahead of the next machine. However, you don't know 
        the exact size of the buffer until the system "complains about a machine getting 
        too far ahead." THESIS POINT, STAR

** TODO [0 1 0 1 3] [:m1-unblocked 1.0] : Is that really the state I want associated (or state plus transition)? 
** TODO Running lein repl gives only one "Compiling ClojureScript"; running lein start-repl gives three. 
** TODO Add MJP 
    This entails
     (1) having an operator for adding other colours -- Not a crossover operator ???
     (2) watching the execution times, maybe doing GPtips like regression.

** TODO Don't 'add choice' as a genetic operator, unless that is semantically what is intended! (see notes 2017-12-11)
** TODO Set the marking in draw.cljs to something reasonable (use imark from lax-reach). 
** TODO MJPdes: Update MJPdes README to note what :mx-complete-job means when :mx was blocked in BAS. 
        Processing stopped at :mx-blocked. :mx-complete-job is always reported contemporaneous 
        with :mx-unblock if :mx was blocked. 
        In BAS, :mx-unblock reports where the part moves off the machine. 
        In BBS, the part moves off the machine at :mx-complete-job and :mx-blocked prevents starting a new job.
        (Regarding the BBS comment, at least that's the way I see it for PNs.) See next TODO!
** TODO MJPdes: Make BBS/BAS something settable on the individual machine. 
* Agenda up to December 1:
** DONE Fix bug in pnr/simple-reach. See bug <2017-10-15 Sun>
   CLOSED: [2017-10-15 Sun 18:13]

** DONE Try a more mild blocking situation.
   CLOSED: [2017-10-23 Mon 19:05]

** DONE Consider the possibility/advantages of an 'abbreviated' reachability graph. 
   CLOSED: [2017-11-04 Sat 22:10]

** DONE Consider more forgiving simple-reach 
   CLOSED: [2017-11-04 Sat 22:13]
        lax-reach is this. It is used with new find-interpretation. 
        GP operators on tokens is a thing of the past. 
** DONE How do I use graph distance with real-valued data (round???)
   CLOSED: [2017-11-15 Wed 14:28]
** TODO Integrate exceptional fitness, try using it to place buffer limits.
    In addition to adding an inhibitor with multiplicity, may need to attach functions that
    will emit messages on exceptional events.
** TODO Add individuals that represent machine activity???
   Add genetic operators that combine machine perspective with job perspective. STAR
   Add genetic operators that keep edits within a machine. STAR
   Thought: Evolution here is essential from job perspective to machine/topology perspective.
             - At least when there are parallel workcenters, this will be true. 
             - Also true about learning about buffers and accommodating other jobs.
             - Probably want a "ready-made structure" for insertion of parallel workstations. 
** TODO Add Causal
    This entails making the infinitessimal generator parametric.
** DONE Paper: Add more PNN distance algorithms
   CLOSED: [2017-12-07 Thu 11:21]
** TODO Add parallel workstations to MJPdes and see what happens here (enhance notion of priority?). 

* Discussion
** Rationale for PNN
It is clear that I need a means to explain messages that do not correspond to transitions. 
I need to discover the pattern associated with these other messages, if such a pattern exists. 
The PNN is just the way to do this. Do we associate a semantics to these messages? We can assume
that in general that may not be possible, but there is a "PN semantics" in the case
of blocking and starvation that it would be useful to know. (Likewise for competition for
resources and deadlocking). In the blocking/starvation cases, there is still the matter
of determining where the problem buffer is. Once starving happens it continues upstream, 
and blocking continues downstream. (You could check for that in the causal model.)
Likewise could look at non-delivery of a part from a feeder line. 

*** Think about the role of PNN in causal modeling
The nice thing here is that using the parametric infinitessimal, I'll have real-numbered 
quantities of tokens in places. The PNN essentially shows the state changes while I move around the parameters.

*** Think about what is being inferred. 
*** What role do the "starving/blocking" places have? Can they be added?
*** Define the steps 
   - recognition of a pattern
   - hypothesis generation
   - hypothesis testing (causal? comparison?)
   - [TODO] Consider "evolution in stages" where fitness changes when milestones are reached.
** IDEA: Maybe award fitness to PNs that represent exceptional messages.
***  Award a little less to those who can at least cope with it with a NN. 

** Integrating exceptional fitness   
No starting links because nothing can parse the log. Every individual is capable of only describing
the path of a single job through the production resources. I think I have few options:

***  Obsolete?
****  1) Hope for a population that gets it right.
   Use genetic operators to produce more varied individuals, including some that 
   might parse the log well enough to get an exceptional msg table with markings that
   can guide design.

****  2) Use a next-ordinary-on-job
   Instead of next-ordinary, use next-ordinary-on-job. That will provide a parse
   and lead to the need for queues. 

   You could apply this to multiple jobs, but would that be helpful?

****  3) Give some more thought about how the reachability graph can do this. 

***  Summary (and msg-table)
Preparation to do (1) and (2) is the same, I think: It must be possible to 
use the msg table markings to update the PN. This is a "semantic genetic operator"

{:m1-blocked   {[3 0 1 1 0] 30},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved   {[0 0 1 0 1] 14},
 :m2-unstarved {[0 0 1 1 0] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263}}

But that is a msg-table for N=3. A table for N=1 would have 1/0 for the first component of block/unblock.
So what? 

But why doesn't an individual emerge from evolution that can do this?
The winning individual came real close after just two iterations. 

***  After 30 generations I still didn't get one. 
***  Struggle
(You need 5 places and just the four transitions.) The only mistake
was an arc from the buffer to m2-complete-job. That arc should have
went to m2-start job. I think it may have stopped because success is <= 1 ??? Nope: we are looking for 0.1 or better.

***  Idea: I'm following jobs, what if instead I followed machines? (Or did both?)
Essentially what is wrong with the algorithm now is that it doesn't look at what machines do.
A Machine accepts/creates a part and starts work on it. It puts/destroys a part when done. 
These are patterns I could inject into the initial population, similar to what I do for jobs. 
What I really need are operators that combine the two viewpoints!!!
**** I sort of fixed this with util/related-places etc used in setting the initial-marking

***  Struggle
   I'm going to cut the pop down to 25 and cut out lots of operators. 
   Not enough experimentation yet, but so far, that didn't work. 

***  Let's force one close to this: [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/close-to-correct-pn.jpg][hopeful-pn]]
Find the PN for this on Sunday 2017-10-29. 
** GP Operators 
*** Need better notion of locality!
**** hopeful-pn with an initial-marking [1 0 0 0 0] (where first is place-1)
     Doesn't even get a rgraph, yet it is SO CLOSE! 
***** The above before I thought about pnu/set-initial-mark related-machine, etc.
***** Certainly more to say about locality, but that's it for now!
*** Semantic operators
**** Example failure is hopeful-pn with initial-marking token on place-1


* Sinet Log *
** <2017-10-14 Sat>
*** I started with this log file: [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-out.clj::%5B][m2-j1-n3-block-out.clj]] which blocks like crazy. 
*** I switched from returning 'the first' good starting marking to all markings.
*** I then compared the results from all three:

I am indexing the nets by the starting state. Each will associate a different marking with the
exceptional msg (defined as :fires-on). They all map [3 0 1 1 0] to the highest value of the NN.
Yet only the second one was trained for that outcome! The problem is that higher values are
going to drive the NN higher. (For example [10 0 1 1 0] give values even closer to 1 in each case.)
I can at least conclude that the one with the correct starting marking has the most prominent max
value (0.398 versus 0.213) is almost double, whereas the others are only  (0.57 versus 0.53) and
(0.71 vs 0.67) In all three cases, second best is [3 1 0 1 0].

**** (test-markings (get nnns [2 0 1 1 0]))   :fires-on {[2 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0019047821808839684),
 [3 1 0 1 0] (0.5329793128418048),
 [2 0 1 1 0] (0.4557148825447303),
 [1 1 0 1 0] (0.028426845459858803),
 [3 0 1 0 1] (0.2520620080684257),
 [1 0 1 1 0] (0.0824105061449745),
 [0 1 0 0 1] (4.4899449786599065E-4),
 [2 1 0 1 0] (0.3112057574008602),
 [3 0 1 1 0] (0.5690740829317157),   ----- (next best is 0.53, which is :fires-on)
 [1 0 1 0 1] (0.007984861441426688),
 [3 1 0 0 1] (0.33543893173498296),
 [0 0 1 1 0] (0.0017534551604061264),
 [0 0 1 0 1] (0.0010127514448150464),
 [2 0 1 0 1] (0.04765593309469408)}

**** (test-markings (get nnns [3 0 1 1 0]))   :fires-on {[3 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0014487996373689941),
 [3 1 0 1 0] (0.21293141920670883),
 [2 0 1 1 0] (0.15438051750729484),
 [1 1 0 1 0] (0.005105555396279919),
 [3 0 1 0 1] (0.05425027679413153),
 [1 0 1 1 0] (0.017136382643884614),
 [0 1 0 0 1] (4.6382801763844935E-4),
 [2 1 0 1 0] (0.03850346112492955),
 [3 0 1 1 0] (0.39880145491033164), ----- This IS fires-on. (next best is 0.213) 
 [1 0 1 0 1] (0.006230800133017719),
 [3 1 0 0 1] (0.03105553855253639),
 [0 0 1 1 0] (0.002015237400342786),
 [0 0 1 0 1] (0.001066242446042215),
 [2 0 1 0 1] (0.022575588402398115)}

**** (test-markings (get nnns [1 0 1 1 0]))   :fires-on {[1 0 1 1 0] 388}}}
{[0 1 0 1 0] (0.014569799679218615),
 [3 1 0 1 0] (0.6721408448530173),
 [2 0 1 1 0] (0.6688434016370715),
 [1 1 0 1 0] (0.21941460772717947),
 [3 0 1 0 1] (0.6601096030824811),
 [1 0 1 1 0] (0.46608997395936497),
 [0 1 0 0 1] (0.001252201438882003),
 [2 1 0 1 0] (0.5432656472113356),
 [3 0 1 1 0] (0.7113587186344846),  --- (next best is 0.672, which is [3 1 0 1 0]
 [1 0 1 0 1] (0.033295385315624364),
 [3 1 0 0 1] (0.5286157002824883),
 [0 0 1 1 0] (0.04039619976094015),
 [0 0 1 0 1] (0.00328347348876465),
 [2 0 1 0 1] (0.41021721559535307)}




**** Advantage: 
     The correct starting state has fewer false positives. It will do best. 

n**** Problem: 
     The algorithm is just going to focus on the buffer being high/low. This is fine for 
     blocking/starving events but not good for state-but-not-transition situations.

** <2017-10-15 Sun>
*** I ended up with data that blocks 30 times and starves 14 times: 
This was after about 30 experiments, fine tuning the parameters. The problem is that it
is very easy to get very short blocking/starving periods. 
Input:   file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild.clj]]
Output:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj:::status%20nil,][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj]]
Pretty:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj::%5B][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj]]
*** This was achieved with these parameters:
#+BEGIN_SRC clojure
  (map->Model
   {:line 
    {:m1 (map->ExpoMachine {:lambda 0.6 :mu 3.5 :W 1.0}) 
     :b1 (map->Buffer {:N 3})
     :m2 (map->ExpoMachine {:lambda 0.001 :mu 0.99 :W 1.0})}
    :number-of-simulations 1
    :report {:log? true :max-lines 3000}
    :topology [:m1 :b1 :m2]
    :entry-point :m1
    :params {:warm-up-time 2000 :run-to-time 10000}
    :jobmix {:jobType1 (map->JobType {:portion 1.0 :w {:m1 1.0, :m2 1.17}})}})
#+END_SRC
*** The m2-j1-n3 PN 
#+BEGIN_SRC clojure
{:places
 [{:name :buffer, :pid 0, :initial-tokens 0}
  {:name :m1-blocked, :pid 1, :initial-tokens 0}
  {:name :m1-busy, :pid 2, :initial-tokens 1}
  {:name :m2-busy, :pid 3, :initial-tokens 1}
  {:name :m2-starved, :pid 4, :initial-tokens 0}],
 :transitions
 [{:name :m1-complete-job, :tid 6, :type :exponential, :rate 0.9}
  {:name :m1-start-job, :tid 7, :type :immediate, :rate 1.0}
  {:name :m2-complete-job, :tid 8, :type :exponential, :rate 1.0}
  {:name :m2-start-job, :tid 9, :type :immediate, :rate 1.0}],
 :arcs
 [{:aid 10, :source :buffer, :target :m1-start-job, :name :aa-10, :type :inhibitor, :multiplicity 3, :bind {:jtype :blue}, :priority 1}
  {:aid 11, :source :buffer, :target :m2-start-job, :name :aa-11, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 12, :source :m1-blocked, :target :m1-start-job, :name :aa-12, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 13, :source :m1-busy, :target :m1-complete-job, :name :aa-13, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 14, :source :m1-complete-job, :target :m1-blocked, :name :aa-14, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 15, :source :m1-start-job, :target :buffer, :name :aa-15, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 2}
  {:aid 16, :source :m1-start-job, :target :m1-busy, :name :aa-16, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 17, :source :m2-busy, :target :m2-complete-job, :name :aa-17, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 18, :source :m2-complete-job, :target :m2-starved, :name :aa-18, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 19, :source :m2-start-job, :target :m2-busy, :name :aa-19, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 20, :source :m2-starved, :target :m2-start-job, :name :aa-20, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}]}
#+END_SRC 
 
*** Does it make sense to have an entry point with no :fire-ons?  (Yes, but...)
 I get two entry point markings, only one has anything in :fires-on. 
 I search for 50 steps supposedly, but it goes 225 lines, ending on the only exceptional msg, 
 which is {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]}. None of that should matter, we
 aren't looking for exceptional one yet. 
**** Is the problem that it is using the short data?
**** Yeah, ok this is wrong! : 
     (def foo (interpret-scada reach1 (-> (app-info) :problem :scada-log) lili))
     (count foo) ==> 225
     So I have been using the wrong data all the time, or it is stopping early?
     Good! It is stopping after 225 (the other goes 3000). I'm guessing that it gets 
     stuck in a situation it cannot interpret. Verify...
   
     Here is the new "failed-on" information:
     {:failed-prior   {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 224},
      :failed-on-link {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]},
      :failed-on-msg  {:act :m1-complete-job, :bf :b1, :j 1745, :n 0, :clk 2067.08452126566, :line 226, :mjpact :bj, :m :m1}}

     According to the reachability graph, the only thing that can occur after [1 0 1 0 1] is :m2-start-job
     {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0}
     That makes sense because ...
      [:buffer     1
       :m1-blocked 0
       :m1-busy    1
       :m2-busy    0
       :m2-starved 1]
      ... No, it doesn't make sense. [1 1 0 0 1] should also be possible. This is a vanishing transition to :m1-blocked.
***** BUG 
      The reachability graph must be wrong, but before I fix it, I won't build nets where :failed-on-msg is on last. DONE. 
      Something is seriously wrong. I created pnml for the N=3 PN but I don't get the same reachability as I did earlier
      (def reach1 ...) This one is much smaller. 

      Even the N=1 net is wrong. It should have 12 links, not 10:
      [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/m2-n1-no-immediate-reach.jpg]]

      First of all, these PNs have immediate transitions. 
          
      This is bad, there should be two here!    
    
      (next-links pnpn [0 1 0 1 0])
      [{:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0}]
      The problem was that I was not setting all transitions to timed. THIS MAY NEED MORE THOUGHT (to TODO)
*** So now I have larger rgraphs (e.g. 28 vs 18 for N=3) do things still work?
**** DONE write code to generate simple-reach
     CLOSED: [2017-10-15 Sun 20:07]
**** write fitness assessment. 
*** Junk I'll probably never use
#_(defn prev-ordinary
  "Return an ordinary message, at index n or earlier."
  [data n]
  (loop [indx n]
    (cond (ordinary? (nth data indx)) (nth data indx), 
          (== indx 0) nil
          :otherwise (recur (dec indx)))))

(defn big-train
  ([net] (big-train net :m1-blocked 1))
  ([net msg-type cnt]
   (reduce (fn [n _] (train-msg n msg-type))
           net
           (range cnt))))

;;; POD This is for :m2-starved. 
(defn more-exceptional-training
  [net cnt]
  (reduce (fn [n _]
            (nn/train-step net [0.0 0.0 1.0 0.0 1.0] [1.0]))
          net
          (range cnt)))


*** DONE Write code to defobulate/zipmap (and pick best???)
    CLOSED: [2017-10-17 Tue 14:17]
** <2017-10-16 Mon>
 So far there is only one NN per message. 

I cleaned things up so that I get one NN per message. 

I studied Probabilistic Neural Nets briefly. They require one neuron for each training instance
and therefore for my application I think would be equivalent of a lookup table encompasing the whole
training set. I think they make more sense when there are points "between" the elements in the
training set. (Do I have these???) Needs more study, but maybe not so promising.

Let's look at how these things do against the 

** <2017-10-17 Tue>

*** Cortex
Cortex layer types (what I'm seeing [[https://github.com/thinktopic/cortex/commit/4be1c559675b9612249abbb94963d989d70817fe][here]]): convolutional, max-pooling, dropout, relu, linear, softmax.
But *this* matters: [[https://machinelearningmastery.com/confusion-matrix-machine-learning/][Confusion matrix]]: Describes what one is and how to calculate one for the 2-class
classification problem!

[[https://adeshpande3.github.io/adeshpande3.github.io/A-Beginner's-Guide-To-Understanding-Convolutional-Neural-Networks-Part-2/][Nice discussion of use of layers in CNN]].

**** Dropout 
     Seems to be primarily about overfitting and regularization - introducing additional information to solve ill-posed problems
     Regularization is NOT what I want. 

     "The idea of dropout is simplistic in nature. This layer “drops out” a random set of activations in that 
      layer by setting them to zero. Simple as that. Now, what are the benefits of such a simple and seemingly 
      unnecessary and counterintuitive process? Well, in a way, it forces the network to be redundant. 
      By that I mean the network should be able to provide the right classification or output for a specific 
      example even if some of the activations are dropped out"

**** Max-pooling
     Used in convolutional NNs. Use biggest value on a window. [[https://leonardoaraujosantos.gitbooks.io/artificial-inteligence/content/pooling_layer.html][example here]]. The goal is to reduce spatial dimensions (but not depth)
     on a convolutional NN. Not what I want.

**** ReLu [[https://stackoverflow.com/questions/27319931/relu-and-dropout-in-cnn][here]]. (Rectified Linear Unit, Not a layer, the activation function of a single neuron.)
     The rectifier function is an activation function f(x) = Max(0, x) which can be used by neurons just like 
     any other activation function, a node using the rectifier activation function is called a ReLu node. 
     The main reason that it is used is because of how efficiently it can be computed compared to more conventional 
     activation functions like the sigmoid and hyperbolic tangent, without making a significant difference to 
     generalisation accuracy. The rectifier activation function is used instead of a linear activation function to 
     add non linearity to the network, otherwise the network would only ever be able to compute a linear function.

     This part sounds useful "to add non-linearity to the network, otherwise the network would only ever be able to
     compute a linear function." That is the problem I'm experiencing now. 

**** Convolutional 
     They aren't fully connected...

**** Softmax (Not a layer, the activation function of a single neuron.)
     In mathematics, the softmax function, or normalized exponential function is a generalization of the 
     logistic function that "squashes" a K-dimensional vector z of arbitrary real values to a K-dimensional vector 
      {\displaystyle \sigma (\mathbf {z} )} \sigma (\mathbf {z} ) of real values in the range [0, 1] that add up to 1.
     (wikipedia)
     [[https://github.com/Kulbear/deep-learning-nano-foundation/wiki/ReLU-and-Softmax-Activation-Functions][Softmax and ReLU]].

**** Probabilistic Neural Nets
   [[https://web.archive.org/web/20101218121158/http://herselfsai.com/2007/03/probabilistic-neural-networks.html][Start here]].


*** Confusion matrix
"A confusion matrix is a technique for summarizing the performance of a classification algorithm."
Thus if I have one of these, I can use it directly to determine the fitness of the combination of
PN + NNs as an identification of the system. 

Easy enough. Should also look at precision, recall, specificity and sensitivity. 
These are all defined on this [[https://en.wikipedia.org/wiki/Confusion_matrix][wikipedia page]]. I also have a paper by D. M. W. Powers in the ML
section of Mendeley.

*** fitness.clj
I think before I go much further, I have to fix the problem any problems deciding the class. 
I had hoped that it was just a matter of choosing marking > 0.5. Is this the case? 

HELP! No marking hits on any exceptional message. I don't think I have looked at results
since the "dense" exceptional messages of Saturday. 

*** What does the marking used as input to training mean?
    I was hoping that it was the marking just before the message is issued. 
    Messages are issued on complete-job / start-job but MJPdes doesn't 
    order these where they all happen simultaneously. Maybe it should???

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
 {:msg-type :m1-blocked,   [3 0 1 1 0] 30} ... I assume next msg is m1-complete-job
 {:msg-type :m1-unblocked, [2 1 0 1 0] 30} ... 
 {:msg-type :m2-starved,   [0 0 1 0 1] 14} 
 {:msg-type :m2-unstarved, [0 0 1 1 0] 14} 
 
Let's generate the interpretation [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j2-n3-block-mild-interpreted.clj::{:act%20:m1-blocked,%20:prev-act%20:m1-start-job,%20:indx%20710,%20:Mp%20%5B3%200%201%201%200%5D,%20:clk%202206.0879216608246}][AND SAVE IT AS A FILE]]. 

Start link is the same for all 4 message types, yet I interpret the log four times. Nice. 
    
**** Typical output with "data/SCADA-logs/m2-j1-n3-block-mild-out.clj"       
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-blocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.024485036900973763,
 [3 1 0 1 0] 0.008046179155291305,
 [2 0 1 1 0] 0.004074497484690655,
 [1 1 0 1 0] 0.013784127155537253,
 [3 0 1 0 1] 0.004062515347353122,
 [1 0 1 1 0] 0.005371589317720032,
 [0 1 0 0 1] 0.0521152547076084, <-- wrong, and next best is 0.027
 [2 1 0 1 0] 0.009709532322778542,
 [3 0 1 1 0] 0.003524192574949857,
 [1 0 1 0 1] 0.009338700112664192,
 [3 1 0 0 1] 0.010161648095898495,
 [0 0 1 1 0] 0.008800298059058962,
 [1 1 0 0 1] 0.026920570777390792,
 [0 0 1 0 1] 0.01845261113215176,
 [2 1 0 0 1] 0.014811122272394004,
 [2 0 1 0 1] 0.0055072388527700866}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-unblocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.025163102369711258,
 [3 1 0 1 0] 0.016114179019312516,
 [2 0 1 1 0] 0.007977926858371297,
 [1 1 0 1 0] 0.0201854362883496,
 [3 0 1 0 1] 0.014301613606198235,
 [1 0 1 1 0] 0.008978827733614799,
 [0 1 0 0 1] 0.06621052090624126,  <--- wrong, next is 0.036
 [2 1 0 1 0] 0.01751290729163327,
 [3 0 1 1 0] 0.007622303706912641,
 [1 0 1 0 1] 0.018487183654880144,
 [3 1 0 0 1] 0.029438724652992698,
 [0 0 1 1 0] 0.01104428285399589,
 [1 1 0 0 1] 0.04735457640118155,
 [0 0 1 0 1] 0.02363169658896575,
 [2 1 0 0 1] 0.036172647847275446,
 [2 0 1 0 1] 0.01569931368097529}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-starved nnns) %)) markings1)))

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.017027576075899276,
 [3 1 0 1 0] 0.004886266737864184,
 [2 0 1 1 0] 0.006935985604851713,
 [1 1 0 1 0] 0.008132810057098754,
 [3 0 1 0 1] 0.008690333194503956,
 [1 0 1 1 0] 0.011443272037409967,
 [0 1 0 0 1] 0.06431606145668564,
 [2 1 0 1 0] 0.005697633024429593,
 [3 0 1 1 0] 0.005600030048084727,
 [1 0 1 0 1] 0.03823100286076116,
 [3 1 0 0 1] 0.00657718778677882,
 [0 0 1 1 0] 0.029978431187203013,
 [1 1 0 0 1] 0.019941922787321802,
 [0 0 1 0 1] 0.11582262659576607, <-- yes. next is 0.064
 [2 1 0 0 1] 0.00937067227357531,
 [2 0 1 0 1] 0.014909753268535426}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-unstarved nnns) %)) markings1)))
[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.026026209106502097,
 [3 1 0 1 0] 0.0034988958592581513,
 [2 0 1 1 0] 0.00601129014254703,
 [1 1 0 1 0] 0.010186463188839843,
 [3 0 1 0 1] 0.0033239310083816543,
 [1 0 1 1 0] 0.011904922484223533,
 [0 1 0 0 1] 0.016127654355549154,
 [2 1 0 1 0] 0.00529834749317781,
 [3 0 1 1 0] 0.00385956712448291,
 [1 0 1 0 1] 0.008798843571705668,
 [3 1 0 0 1] 0.0029969968812421986,
 [0 0 1 1 0] 0.03188710693160681, <--- I guess...what does the marking mean???
 [1 1 0 0 1] 0.007127766343136932,
 [0 0 1 0 1] 0.020988809038561193,
 [2 1 0 0 1] 0.004186967134676599,
 [2 0 1 0 1] 0.00488250449212974}
nil
gov.nist.sinet.fitness> 


Let's go back to the dense messages and see if we still get good results.



Some bad news (Sort of. Hey, we need an interesting paper!): With more exceptional instances
things work pretty well.

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{:m1-unblocked
 [{:marking [0 1 0 1 0], :value 0.50118328747075}
  {:marking [1 1 0 1 0], :value 0.5228651697897436}
  {:marking [2 1 0 1 0], :value 0.5181440750582226}],
 :m1-blocked 
 [{:marking [3 1 0 1 0], :value 0.546424705570647} 
  {:marking [3 0 1 1 0], :value 0.5841860833305524}]}

...actually the unblocks look goofed up. 

This is not correct (or at least not best):

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]

How did m1-starting a job result in there being another job in the buffer?!?!?!
  {:M [1 1 0 1 0], :fire :m1-start-job, :Mp [2 0 1 1 0], :rate 1.0, :clk 3719.7720757450656, :indx 2984}
  {:act :m1-blocked, :prev-act :m1-start-job, :indx 2985, :Mp [2 0 1 1 0], :clk 3720.7720757450656}

The "out" log: (it shows the buffer being full, m2 pulling one, m1 completing one which would set it back to N=3.

{:act :m2-start-job, :bf :b1, :j 1082, :n 3, :clk 3719.7720757450656, :line 2981, :mjpact :sm, :m :m2}
{:act :m1-complete-job, :bf :b1, :j 1085, :n 2, :clk 3719.7720757450656, :line 2982, :mjpact :bj, :m :m1}
{:act :m1-unblocked, :m :m1, :clk 3719.7720757450656, :line 2983, :mjpact :ub}
{:act :m1-start-job, :j 1086, :jt :jobType1, :ends 3720.7720757450656, :clk 3719.7720757450656, :line 2984, :mjpact :aj, :m :m1}

The above  would be easier to read as this:

{:act :m2-start-job, :bf :b1, :j 1082, :n 3,    :clk 3719.7720757450656, :line 2981, :mjpact :sm, :m :m2}
{:act :m1-unblocked, :m :m1,                    :clk 3719.7720757450656, :line 2983, :mjpact :ub}
{:act :m1-complete-job, :bf :b1, :j 1085, :n 2, :clk 3719.7720757450656, :line 2982, :mjpact :bj, :m :m1} (move job)
{:act :m1-start-job, :j 1086, :jt :jobType1,    :clk 3719.7720757450656, :ends 3720.7720757450656, :line 2984, :mjpact :aj, :m :m1}

FIX MJPdes: 
- MJPdes ought to report things upstream happening first. (sort that way (upstream? x y)
- Everything would be easier to read if :clk was first, then :act. 

** <2017-10-18 Wed>

#_(defn reliable? [m]
    (= ReliableMachine (type m)))

#_(defn machine? [m]
  (let [t (type m)]
    (or (= ExpoMachine t) (= ReliableMachine t) (= Machine t))))

#_(defn buffer? [b]
  (let [t (type b)]
    (or (= Buffer t) (= InfiniteBuffer t) (= DedicatedBuffer t))))

** <2017-10-19 Thu>

I reviewed PNNs and found a nice Python implementation. The notebook is [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j2-n3-block-mild-interpreted.clj::{:act%20:m1-blocked,%20:prev-act%20:m1-start-job,%20:indx%20710,%20:Mp%20%5B3%200%201%201%200%5D,%20:clk%202206.0879216608246}][here]].

** <2017-10-20 Fri>

See discussion on keeping my head straight in Discussion area. 
** <2017-10-21 Sat>

I implement the PNN algorithm from [[http://www.personal.reading.ac.uk/~sis01xh/teaching/CY2D2/Pattern3.pdf][here]].

The key think I'm learning is that you can have the same marking associated with many classes. 
But if a class only has one datapoint, it wins when you hit it. This is good! This 
might be useful for distinguishing the size of buffers with different "best-interpretations."

All of this will be useful when I want to compare to the steady-state behavior using 
a parametric infinitessimal! 

(ppprint (subvec (best-interpretation pnpn (-> (app-info) :problem :scada-log)) 0 300))

Interestingly, starve and unstarve are coming up as both ordinary and exceptional. 
For the time being, this shouldn't matter much given that there is only 1 class in 
these exceptional markings. 

{:m2-unstarved {[0 0 1 1 0] 14},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved {[0 0 1 0 1] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263},
 :m1-blocked {[3 0 1 1 0] 30}}

;;; Results with sigma = 1.0
{[0 1 0 1 0] [:m2-unstarved 0.36787944117144233],
 [2 0 1 1 0] [:m1-blocked 0.6065306597126334],
 [1 1 0 1 0] [:m1-unblocked 0.6065306597126334],
 [3 0 1 0 1] [:m1-blocked 0.3678794411714423],
 [1 0 1 1 0] [:m2-unstarved 0.6065306597126334],
 [0 1 0 0 1] [:m2-starved 0.36787944117144233],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.6065306597126334],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.3312510892460261]}

;;; Results with sigma = 0.2 MAKES PERFECT SENSE!
{[0 1 0 1 0] [:ordinary 0.06971187503880233],
 [2 0 1 1 0] [:ordinary 0.17548168297989752],
 [1 1 0 1 0] [:ordinary 0.09031651123868557],
 [3 0 1 0 1] [:ordinary 0.0851651717421801],
 [1 0 1 1 0] [:ordinary 0.16002840419305475],
 [0 1 0 0 1] [:ordinary 0.0048076923087272344],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:ordinary 0.07451958526421719],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.09031652915550199]}

** <2017-10-22 Sun>

Yesterday I got PNNs working nicely! If only every day were that productive!
This morning (well, until 2:30PM!) I cleaned up MJPdes. 
Today we experiment with the idea of replacing euclid-dist2 with some notion of "pn network distance."

- Places are dimensions, movement can be along one or more dimensions. 
- Transitions are the things that determine movement; only dimensions referenced in the
  transition change between states. 
- Each marking has an associated classification. Markings that are very dissimilar from the
  classified marking should have a large distance measure from it. EUCLIDEAN DISTANCE ENSURES THIS.
  The PDF distributes the classification among each training instance. 

- I was concerned about the proximity of activity over time. That changes according to rates. 
  If one part of the network has high-rate transitions, we'd expect more activity from it. But so what?
- I was thinking about "locality of reference" -- that with each transition, only connected places change. 

--> Maybe then what I'm after is to use the distance between transitions in the measure of 
    distance between states. 
    Q: But what does that mean? 
    A: A transition occurs -- we want to learn the relationship between transition and the emission of 
       exceptional messages. This is a temporal relationship (E.g. How many steps after firing X do
       I see exceptional message M?) This isn't judged by pn-path stuff, it is by reachability graph!

Maybe just do the Euclidean distance between markings times the number of steps. 

- There is nothing preventing 
- Transitions that are far from the 

(defn paths-to
  "Return the paths from FROM to TO (both are names of places or transitions) 
   in exactly STEPS steps (counting places, transitions and arcs)."
  [pn from to nsteps & {:keys [back?]}]

** <2017-10-23 Mon>

Another productive day (without really working too hard!). 
The distance function that I'm using is strictly distance between nodes in the rgraph. 
I use loom to calculate this (20 minutes work). 
I'm moving the parzen-pdf-msg stuff from pnn to fitness. 

*** This stuff isn't going to be used
#_(defn min-pn-steps
  "Return the pn distance from FROM to TO in either direction."
  [pn [from to]]
  (if (= from to)
    0
    (loop [cnt 1]
      (if (> cnt 100) 1000, ; POD 1000, it is probably down stream
          (if-let [path (or (not-empty (pnu/paths-to pn from to cnt))
                            (not-empty (pnu/paths-to pn to from cnt)))]
            (/ (-> path first count) 4) ; counts arcs, transitions; I want place to place.
            (recur (inc cnt)))))))

#_(defn pn-distance-table
  "Return a table of all pn distances"
  [pn]
  (let [places (map :name (:places pn))
        keys (for [from places
                   to   places]
               [from to])]
    (zipmap keys
            (map #(min-pn-steps pn %) keys))))


*** This stuff could go in project just of simple neural nets
;;; :marking-key [:buffer :m1-blocked :m1-busy :m2-busy :m2-starved],
;;; It blocks after [2 0 1 1 0]

;;; POD NYI
#_(defn pick-net 
  "Given a list of NN, choose the most accurate one for its message."
  [nets]
  (let [result (filter nn/net? nets)]
    (when (> (count result) 1)
      (println "Multiple nets. Pick NYI."))
    (first nets)))
  
#_(defn train-msg
  "Train the net for the msg-type using the log interpretation."
  [net interp msg-type]
  (let [train-data (:interpreted-log interp)
        last-indx (-> train-data last :indx)
        fires-on (atom {:msg-type msg-type})]
    (loop [net net
           indx 0]
      (if (>= indx last-indx) ; terminate
        (-> net
            (assoc :fires-on @fires-on)
            (assoc :msg-type msg-type)
            (assoc :start-link (:start-link interp)))
        (let [msg (nth train-data indx)
              label (if (= (:act msg) msg-type) 1 0)           ; (rand-int 2)
              inputs (cond (== label 1)             (:Mp msg), ; (noise) 
                           (contains? msg :fire)    (:M  msg), ; (noise) 
                           :otherwise :skip)] ; an exceptional message but not the one I'm learning. 
          (when (== label 1) ; track markings it is firing on
            ;;(println msg)
            (if (contains? @fires-on (:Mp msg))
              (swap! fires-on #(update % (:Mp msg) inc))
              (swap! fires-on #(assoc  % (:Mp msg) 1))))
          (recur
           (if (= inputs :skip)
             net
             (nn/train-step net
                            (vec (map double inputs))
                            (vector (double label))))
           (inc indx)))))))

#_(defn train-all
  "Given a SCADA log interpretation, return a map providing the best NN for each message."
  [interp]
  (let [size   (-> interp :marking-key count)
        msgs   (-> (app-info) :problem :exceptional-msgs)]
    (zipmap msgs
            (map #(train-msg (nn/make-net size 1 size) interp %) msgs))))

#_(defn exceptional-markings
  "Return a vector of {:marking x :value y} indicating that the 
   marking associates with the exceptional class of the neural net."
  [net markings]
  (let [results (zipmap markings
                         (map #(first (nn/eval-net net %)) markings))]
    (reduce (fn [success [mark class-val]]
              (if (> class-val 0.5)
                (conj success {:marking mark :value class-val})
                success))
            []
            results)))

;;; (tryme pnpn (-> (app-info) :problem :scada-log))
#_(defn tryme [pn scada-log]
  (let [interp (best-interpretation pn scada-log) ; POD stop after have all markings. 
        nets (train-all interp)
        markings (distinct (map :M (:rgraph interp)))]
    (reduce (fn [res [msg net]]
              (assoc res msg (exceptional-markings net markings)))
            {}
            nets)))

#_(defn noise []
  (vec (repeatedly 5 #(rand-int 2))))

*** This stuff is what I used prior to recognizing that I need occurrence counts for the parzen-fn
It has been replaced by compute-msg-table.
(defn compute-pnn-data
  "Return a map indicating what markings are associated with what message types, 
   where message types are either ':ordinary' or some exceptional message type."
  [pn scada-log]
  (let [interp (best-interpretation pn scada-log)
        markings (-> (map :M (:rgraph interp)) set)
        excepts (->> (filter #(contains? % :act) (:interpreted-log interp))
                     (map #(dissoc % :clk))
                     (map #(dissoc % :indx))
                     distinct)
        classes (conj (distinct (map :act excepts)) :ordinary)
        emarks (set (map :Mp excepts))
        data (reduce
              (fn [data mark]
                (if (contains? emarks mark)
                  (update-in data
                             [(some #(when (= (:Mp %) mark) (:act %)) excepts)]
                             #(conj % mark))
                  (update-in data [:ordinary] #(conj % mark))))
              (zipmap classes (repeat (count classes) []))
              markings)]
    data))


        
*** This stuff was my first pass at interpretation???
#_(defn best-nav
  "Picking various starting points in the SCADA log, return the 
   longest path of it that can be walked using the QPN." 
  [inv]
  (let [rgraph (pnr/simple-reach (:pn inv))
        exceptional (set/difference scada-msg-types (set (map :fire rgraph)))
        msg1 (first scada-msgs)
        start-marks (map :Mp (filter #(= (:fire %) (:name msg1)) rgraph))]
    (map #(navigate-qpn (:pn inv) rgraph exceptional % 0 (dec (count scada-msgs))) start-marks)))

;;; The set of exceptional message types is decided on a per-QPN basis.
;;; Whatever is in the SCADA log but not a QPN event is exceptional for that QPN. 

;;; POD I think it is enough to always start at position 0 in the SCADA log because
;;;     exceptional situations are the only thing in the way. 
;;;     But is this still sensitive to to the initial marking???
(defn navigate-qpn
  "Using the QPN, try to walk the SCADA log from the argument marking and associated 
   starting position in the log to the argument stop position.
   Return a map describing how far it was possible to navigate and what markings were
   associated with the exceptional messages encountered."
  [pn rgraph excepts mark start stop]
  (let [pn (pnr/renumber-pids pn)]
    (loop [result {:start start :ix (+ start 1) :mark mark :path [] :excepts {}}]
      (let [links (filter #(= (:M %) (:mark result)) rgraph)
            event (:name (nth scada-msgs (:ix result)))
            link  (some #(when (= event (:fire %)) %) links)]
        (if (or (and (not link)
                     (not (some #(= event %) excepts)))
                (>= (inc (:ix result)) stop))
          result 
          (recur (if link
                   (-> result
                       (update :ix inc)
                       (assoc :mark (:Mp link)))
                   (-> result
                       (update :ix inc)
                       (update-in [:excepts event] #(distinct (conj %1 %2)) mark)))))))))


As is apparent from the four subtopics above, I cut out a lot of code today!

Refactors stuff has not yet been tested. 
** <2017-10-24 Tue>

I've got a bug in starting-links. 
next-paths works depth first thus I don't think this code makes sense:
      (when-let [goods (filter #(> (count %) 50) paths)]
        (swap! winners #(into % (vec (map first goods)))))


paths= [[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0}
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 1}
        {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 2}
        {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0, :indx 3}
        {:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 4} 
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 5} 
        {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 6} 
        {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0, :indx 7} 
        {:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 8} 
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 9}] 

[{:M [1 0 1 0 1], :fire :m1-complete-job, :Mp [1 1 0 0 1], :rate 0.9, :indx 0}] 
[{:M [0 0 1 0 1], :fire :m1-complete-job, :Mp [0 1 0 0 1], :rate 0.9, :indx 0}] 
[{:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0}]]
indx = 10
good-steps= ()

Ugh! The problem is I'm using the wrong data. Anyway, if there are no good starting-links... 

{:act :m2-complete-job, :m :m2, :j 1744, :ent 2062.4506743555485, :clk 2066.1692850612535, :line 224, :mjpact :ej}
{:act :m2-starved, :m :m2, :clk 2066.1692850612535, :line 225, :mjpact :st}

I have been chasing my tail for hours! It works here, doesn't work, works....



At sigma = 1.0 mine works better:

Euclidean:
         {[0 1 0 1 0] [:m2-unstarved 0.36787944117144233],
          [2 0 1 1 0] [:m1-blocked 0.6065306597126334],
          [1 1 0 1 0] [:m1-unblocked 0.6065306597126334],
          [3 0 1 0 1] [:m1-blocked 0.3678794411714423],
          [1 0 1 1 0] [:m2-unstarved 0.6065306597126334],
          [0 1 0 0 1] [:m2-starved 0.36787944117144233],
          [2 1 0 1 0] [:m1-unblocked 1.0],
          [3 0 1 1 0] [:m1-blocked 1.0],
          [1 0 1 0 1] [:m2-starved 0.6065306597126334],
          [0 0 1 1 0] [:m2-unstarved 1.0],
          [0 0 1 0 1] [:m2-starved 1.0],
          [2 0 1 0 1] [:ordinary 0.3312510892460261]}))

Euclidean + graph distance
         {[0 1 0 1 0] [:m2-unstarved 0.1353352832366127],   <------- Even these
	 [2 0 1 1 0] [:ordinary 0.24215429146359604],       <----------------
	 [1 1 0 1 0] [:m1-unblocked 0.22313016014842982],
	 [3 0 1 0 1] [:m1-blocked 0.1353352832366127],
	 [1 0 1 1 0] [:ordinary 0.22681188379228487],       <----------------
	 [0 1 0 0 1] [:m2-starved 0.1353352832366127],
	 [2 1 0 1 0] [:m1-unblocked 1.0],
	 [3 0 1 1 0] [:m1-blocked 1.0],
	 [1 0 1 0 1] [:m2-starved 0.2231301601484298],
	 [0 0 1 1 0] [:m2-unstarved 1.0],
	 [0 0 1 0 1] [:m2-starved 1.0],
	 [2 0 1 0 1] [:ordinary 0.1503568437398036]}


At sigma=0.2 very little difference (but this is very tight range on trained values). 
Euclidean
         (fit/choose-winners (assoc pn-test :sigma 0.2))
         {[0 1 0 1 0] [:ordinary 0.06971187503880233],
          [2 0 1 1 0] [:ordinary 0.17548168297989752],
          [1 1 0 1 0] [:ordinary 0.09031651123868557],
          [3 0 1 0 1] [:ordinary 0.0851651717421801],
          [1 0 1 1 0] [:ordinary 0.16002840419305475],
          [0 1 0 0 1] [:ordinary 0.0048076923087272344],
          [2 1 0 1 0] [:m1-unblocked 1.0],
          [3 0 1 1 0] [:m1-blocked 1.0],
          [1 0 1 0 1] [:ordinary 0.07451958526421719],
          [0 0 1 1 0] [:m2-unstarved 1.0],
          [0 0 1 0 1] [:m2-starved 1.0],
          [2 0 1 0 1] [:ordinary 0.09031652915550199]}))))

Mine
         {[0 1 0 1 0] [:ordinary 0.06971153846153845],
	 [2 0 1 1 0] [:ordinary 0.17548076923076922],
	 [1 1 0 1 0] [:ordinary 0.09031593406593406],
	 [3 0 1 0 1] [:ordinary 0.08516483516483515],
	 [1 0 1 1 0] [:ordinary 0.16002747252747251],
	 [0 1 0 0 1] [:ordinary 0.004807692307692307],
	 [2 1 0 1 0] [:m1-unblocked 1.0],
	 [3 0 1 1 0] [:m1-blocked 1.0],
	 [1 0 1 0 1] [:ordinary 0.07451923076923077],
	 [0 0 1 1 0] [:m2-unstarved 1.0],
	 [0 0 1 0 1] [:m2-starved 1.0],
	 [2 0 1 0 1] [:ordinary 0.09031593406593406]}

At sigma = 0.8 mine is almost perfect, traditional is way off. 
(ppprint (tryme 0.8))
{[0 1 0 1 0] [:ordinary 0.08167651755114105],
 [2 0 1 1 0] [:ordinary 0.20096611102341413],
 [1 1 0 1 0] [:ordinary 0.11223204044436556],
 [3 0 1 0 1] [:ordinary 0.09758966328235849],
 [1 0 1 1 0] [:ordinary 0.1858113376895019],
 [0 1 0 0 1] [:m2-starved 0.04393693362340743],  
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.09596708604499851], <--- wrong
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.11337198216661176]}
nil
gov.nist.sinet.fitness> (ppprint (tryme2 0.8))
{[0 1 0 1 0] [:m2-unstarved 0.20961138715109787],
 [2 0 1 1 0] [:m1-blocked 0.4578333617716143],
 [1 1 0 1 0] [:m1-unblocked 0.4578333617716143],
 [3 0 1 0 1] [:m1-blocked 0.20961138715109784],
 [1 0 1 1 0] [:m2-unstarved 0.45783336177161427],
 [0 1 0 0 1] [:m2-starved 0.20961138715109787],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.45783336177161427],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.23037282986699076]}

;;; At sigma = 0.75 mine is good, theirs is still crap.


gov.nist.sinet.fitness> (pprint (tryme 0.75))
{[0 1 0 1 0] [:ordinary 0.07812345592321546],
 [2 0 1 1 0] [:ordinary 0.19350798937548197],
 [1 1 0 1 0] [:ordinary 0.10565451941946981],
 [3 0 1 0 1] [:ordinary 0.09387730377891051],
 [1 0 1 1 0] [:ordinary 0.1783054552497219],
 [0 1 0 0 1] [:m2-starved 0.028565500784550373],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:ordinary 0.08572916833008677],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.10642989332503937]}
nil
gov.nist.sinet.fitness> (pprint (tryme2 0.75))
{[0 1 0 1 0] [:m2-unstarved 0.1690133154060661],
 [2 0 1 1 0] [:m1-blocked 0.41111229050718745],
 [1 1 0 1 0] [:m1-unblocked 0.41111229050718745],
 [3 0 1 0 1] [:m1-blocked 0.1690133154060661],
 [1 0 1 1 0] [:m2-unstarved 0.41111229050718745],
 [0 1 0 0 1] [:m2-starved 0.1690133154060661],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.41111229050718745],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.20673002778168464]}



{:m2-unstarved {[0 0 1 1 0] 14},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved {[0 0 1 0 1] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263},
** <2017-10-25 Wed>

I should be having a telecon with Charles today, but...

*** Tryme functions for Euclidean and graph-distance * Euclidean
(defn tryme [sigma]
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        pn (as-> "data/PNs/m2-inhib-n3.xml" ?pn
             (pnml/read-pnml ?pn)
             (pnr/renumber-pids ?pn)
             (assoc ?pn :rgraph (pnr/simple-reach ?pn))
             (assoc ?pn :starting-links (starting-links ?pn log 0))
             (assoc ?pn :msg-table (compute-msg-table ?pn log))
             (assoc ?pn :sigma sigma)
             (assoc ?pn :distance-fn (graph-distance-fn ?pn))
             (assoc ?pn :pdf-fns
                    (zipmap (-> ?pn :msg-table keys)
                            (map #(parzen-pdf-msg ?pn %)
                                 (-> ?pn :msg-table keys)))))]
    (reset! diag pn)
    (choose-winners pn)))

(defn tryme2 [sigma]
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        pn (as-> "data/PNs/m2-inhib-n3.xml" ?pn
             (pnml/read-pnml ?pn)
             (pnr/renumber-pids ?pn)
             (assoc ?pn :rgraph (pnr/simple-reach ?pn))
             (assoc ?pn :starting-links (starting-links ?pn log 0))
             (assoc ?pn :msg-table (compute-msg-table ?pn log))
             (assoc ?pn :sigma sigma)
             (assoc ?pn :distance-fn pnn/euclid-dist2)
             (assoc ?pn :pdf-fns
                    (zipmap (-> ?pn :msg-table keys)
                            (map #(parzen-pdf-msg ?pn %)
                                 (-> ?pn :msg-table keys)))))]
    (choose-winners pn)))
See Agenda. Today I'm integrating the exceptional messages, and inhibitors.
First, however, is to look into the possibly erroneous marking state found yesterday:

[0 1 0 0 1] [:m2-starved 0.1690133154060661], ; <---- Needs investigation. Should not be in rgraph!

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
Means that m1 is blocked, yet there is nothing in the buffer. How does this come about?
It is a vanishing state from m1-complete-job to m1-start-job. 
So it is okay. 

The problem I'm having with init-pop seems to be that plans don't have names. 
This was probably erroneously removed when MJPdes was prettified. 

*** More unnecessary code:
#_(defn mjpdes2pn-trace
  "Translate all the SCADA message maps with maps with 'nice pn names."
  [job-trace]
  (distinct (map scada/mjpdes2pn job-trace)))

;;; POD Will need to generalize this idea of 'what a message means' I'm giving nice "pn names" to MJPdes output. 
;;; (mjpdes2pn (first (scada/random-job-trace))) ==>  {:name :m1-start-job, :act :aj, :m :m1}

#_(defn mjpdes2pn
  "Interpret/translate the SCADA log. (Give pretty-fied pn names to MJPdes output.)" 
  [msg]
  (let [m (implies-machine msg)]
    (-> msg
        (assoc :mjpact (:act msg))
        (assoc :m m)
        (assoc :act (scada2pn-name msg)))))
;;; POD Someday you might want to call this with multiple job traces.
;;; POD This interprets/translates the SCADA log. We'll need to generalize it someday.
(defn scada2pn-name
  "Return a transition name for a given SCADA msg (bl/ub/st/us probably wont' be used.)"
  [msg]
  (let [m (implies-machine msg)]
    (cond (= :aj (:act msg)) (read-string (cl-format nil "~A-start-job"    m)),
          (= :ej (:act msg)) (read-string (cl-format nil "~A-complete-job" m)),
          (= :sm (:act msg)) (read-string (cl-format nil "~A-start-job"    m)),
          (= :bj (:act msg)) (read-string (cl-format nil "~A-complete-job" m)),
          (= :bl (:act msg)) (read-string (cl-format nil "~A-blocked"      m)),
          (= :ub (:act msg)) (read-string (cl-format nil "~A-unblocked"    m)),
          (= :st (:act msg)) (read-string (cl-format nil "~A-starved"      m)),
          (= :us (:act msg)) (read-string (cl-format nil "~A-unstarved"    m)))))

(defn implies-machine
  "Returns machine referenced/implied in message. 
   If a buffer n is references, machine n+1 is pulling from it.
   Returns nil if msg contains neither :bf or :m"
  [msg]
  (let [act (:act msg)]
    (cond (= act :aj) :m1
          (= act :bj) (keyword (format "m%d"      (read-string (subs (str (:bf msg)) 2)))),
          (= act :sm) (keyword (format "m%d" (inc (read-string (subs (str (:bf msg)) 2))))),
          (contains? msg :m) (:m msg))))


OK, first interesting thing is that I've been using a N=3 example, but now, of course, 
all the instances start as N=1. I guess that was expected, but it is making it harder
to sync-up in "starting-links" 


Arcs are all messed up: 
 :arcs
 [{:aid 1, :source :place-1, :target nil, :name :aa-1, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 2, :source nil, :target :place-2, :name :aa-2, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 3, :source :place-2, :target nil, :name :aa-3, :type :normal, :multiplicity 1, :bind {:jtype :blue}}

Maybe fix this with clojure.spec? 
** <2017-10-26 Thu>

*** More junk?
#_(defn diag-run
  "Run the GP in diagnostic mode from the REPL. A very useful function!"
  []
  (binding [*debugging* false] ;<===== Whether or not to save every individual
    (reset! diag-all-inv {})
    (let [p (promise)]
      (as-> (evolve-init) ?w
        (evolve-continue ?w p (rep/evolve-chan))))))
*** NEXT: Write clojure.spec for world. 
** <2017-10-27 Fri>

Writing clojure spec for world. Find a way to pause and keep world. 

Once again (it was happening Oct 7, among other times) I'm getting a error
No implementation of method: :sch-send! of protocol: #'taoensso.sente.interfaces/IServerChan found for 
class: org.httpkit.server.AsyncChannel
==> I started a new client (close tab, open another to localhost:8080) and it seems to work.

This makes no sense. big-reset does not fix it. 

==> Timeout requesting individual...Needed to provide a clean PN (no functions). DONE.

  < See Discussion>


==> Something screwy is going on. It is no faster. Gets stuck sometimes after 1 iteration. 

--> I remove exceptional processing. No help! Still slow! WTF is it doing???

Is it that the agent is forcing things into one process??? Need to watch process meter!!
** <2017-10-28 Sat>

*** Slow Runtime investigation

Yesterday: Is it that the agent is forcing things into one process??? Need to watch process meter!!
I think that it is that I don't have an ABORT that actually leaves the loop, and that
I don't have a record (defonce atom) ? of old evolve-chan. OTOH, these are suppose to park.

[[http://www.bradcypert.com/clojure-async/][Brad Cypert on Core.Async]] 

**** Before I started, there were two processes called main. 
    MJPdes (started with lein repl) gets two processes called main too.  
    Also get two with C-c M-j on MJPdes.
    Starting fresh I get one. (fan starts/stops) Now two again 869 and 784
    Killing 684 kills both.
    ====> One starts just as the REPL server starts. --> One for program, one for repl (nREPL). 
**** Pipe taking 30% of a CPU. Killed it. 
**** Code suggests that nothing starts just by loading. 
**** Oh so well behaved today!
    Got more than 500% CPU and CPU dropped to 0.1% when done. 
**** Big-reset didn't save on old-channel. (Reload doesn't obey defonce ???)
    Also, no message that would suggest that ABORT happened. 
*** Resolved runtime, but exceptional is slow!

It is not just slow, it is stuck, I think. Aborting doesn't abort. Some of those 
pmapped things are probably still running -- hung: 
**** Need timeouts on pmapped processes???

*** This was first attempt at pmap-timeout (though I didn't know it at the time!)
(def running "Vector of futures" (atom []))
(def promises "Promises of running individuals." (atom []))

(def sched-chan ; POD defonce
  "A channel with a buffer equal to the number of cpu/hyperthreads."
  (async/chan (-> (app-info) :gp-system :use-cpus)))


(defn schedule-work
  "Schedule an individual to run; return a promise."
  [inv work]
  (>!! sched-chan (:id inv)) ; block if full
    (future (deliver p (work inv))
            (<!! sched-chan)) ; make room for more
    p))

(defn finished-work
  "Deref a promise (with timeout) and pull from channel to free up a spot."
  [p]
  (let [result (deref p 10000 :timeout)]
    (cl-format *out* "~%~A finished with ~A" (<!! sched-chan) result)
    result))


***    13:45 - pmap-timeout working....
    ... but I'm back to having 700% CPU when nothing (useful) is running.  
   
    Agents allow shared access to mutable state. 
    (send-off @the-agent evolve-continue @the-promise evolve-chan)

    So I'm asking the agent to run evolve-continue, as opposed to just running evolve-continue
    in a thread with future. 

    I am not able to use (shutdown-agents) (nREPL uses agents). So maybe I try this 
    with a future? 

    The nice thing about agents is the error handler....
    No difference. So SLOWWWW

    Let's see if the pmap-timeout is implicated. 
    A: No, not really. It gets stuck on 100% rather than 800% so we can at least debug it. 

>>>>>    the-promise never gets delivered. 
>>>>>    Delivering it by hand doesn't help.

Temporarily, I'm not reset! the-future to nil. When I print it out:
         (try @@the-future (catch Exception e (str e)))
            "java.util.concurrent.CancellationException"


This 700% problem is really weird. 
(clojure.core.async/thread) shows one thread. 

I *think* I now know why it would hang in the map case (as opposed to my pmap-timeout case):
 It gets stuck on simple-reach. Next time I'll get the PN!!!

For the 700% case, it is probably true that future-cancel isn't doing what I hoped (terminating the thread)

Some thoughts on interrupt by [[http://puredanger.github.io/tech.puredanger.com/2009/06/08/interrupt-handling/][puredanger]].

** <2017-10-29 Sun>

*** Yesterday's impressive waste of time (NOT?):
#_(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many futures in parallel as possible for the hardware. Returns a vector of results."
  ([func members timeout]
   (pmap-timeout func members timeout (+ 2 (.. Runtime getRuntime availableProcessors))))
  ([func members timeout nproc]
   (let [to-run      (atom (vec members))
         results     (atom [])
         running-cnt (atom 0)
         nprocessors nproc
         update-fn (fn [mp] ; return a (possibly new) value for the results vector member.
                     (cond (not (:fut mp)) ;(not= #{:fut :start :mem :prom} (-> mp keys set))
                           mp,
                           (future-done? (:fut mp))
                           (do (swap! running-cnt dec)
                               (deref (:fut mp))),
                           (> (System/currentTimeMillis)
                              (+ (:start mp) timeout))
                           (do (swap! running-cnt dec)
                               (.interrupt @(:prom mp))
                               (.stop @(:prom mp))
                               ;; POD deref timeout here should not be necessary, but...
                               (deref (:fut mp) 10 {:timeout (:mem mp)}))
                           :else mp))]
     (while (not-empty @to-run)
       (when (< @running-cnt nprocessors)
         (let [mem (first @to-run)
               p   (promise)]
           (swap! running-cnt inc)
           (swap! to-run #(vec (rest %)))
           (swap! results conj {:fut (future
                                       (try (let [t (Thread/currentThread)]
                                              (deliver p t)
                                              (func mem))
                                            (catch InterruptedException e
                                              {:timeout mem})))
                                :prom p
                                :mem mem
                                :start (System/currentTimeMillis)})))
       (swap! results #(vec (map update-fn %))))
     ;; Wait for everyone to finish/timeout. 
     (while (some #(:fut %) @results)
       (swap! results #(vec (map update-fn %))))
     (reset! diag @results)
     @results)))

*** I'm still at it. This morning I read about timeout on alts!! in Clojure for the Brave and True. 

**** First try
(pmap-timeout (fn [n] (Thread/sleep n) :done) (repeatedly 8 #(+ 1000 (* 1000 (rand-int 5)))) 5000)
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  [func members maxtime]
  (map (fn [mem]
         (let [c (async/chan)]
           (go (>! c {::val (func mem)}))
           (let [[v _] (alts!! [c (timeout maxtime)])]
             (if (contains? v ::val)
               (::val v)
               {:timeout mem}))))
       members))

***** Huh?
Okay, I expected some trouble, but not this. The map here is not blocking!
Furthermore, it takes maxtime rather than the actual execution time!
I see one problem in that the system might not really start the process when I do go.
I can fix that with a promise that delivers the time and channel. Let's try that first,
THOUGH THINGS ARE ALREADY CONFUSED BY NOT BLOCKING!!! <---- doall on map!

***** Naive; no promise, no doall
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  [func members maxtime]
  (let [channels (map #(let [c (async/chan)]
                         (go (>! c {::val (func %)}))
                         c)
                      members)
        launched (System/currentTimeMillis)]
    ;; This isn't perfect, but it gets around futures, which I can't get to .stop.
    (map (fn [mem c]
           (let [remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                 [v _] (alts!! [c (timeout remaining)])]
             (if (contains? v ::val)
               (::val v)
               {:timeout mem})))
         members
         channels)))








***** This one "gathers" cpus with each iteration, keeps them!
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  ([func members maxtime] (pmap-timeout func members maxtime :timeout))
  ([func members maxtime timeout-key]
   (let [chan&prom (map #(let [c (chan)
                               p (promise)]
                           (go (deliver p (System/currentTimeMillis))
                               (>! c {::val (func %)}))
                           [c p])
                        members)]
     ;; This was designed to gets around futures not .stop-ing. No help.
     (doall
      (map (fn [mem [c p]]
             (let [launched (deref p)
                   remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                   [v _] (alts!! [c (timeout remaining)])]
               (if (contains? v ::val)
                 (::val v)
                 {timeout-key mem})))
           members
           chan&prom)))))

;;; Apparently, it doesn't even run them in parallel!:



(time (let [times (pmap-timeout (fn [n] (Thread/sleep n) n) (repeatedly 8 #(+ 1000 (* 1000 (rand-int 5)))) 5000)]
        (println (str "times = " times))
        (apply + (map #(if (number? %) % (:timeout %)) times)))
"Elapsed time: 19029.34562 msecs"
19000

I GIVE UP!!!!
times = clojure.lang.LazySeq@b6bc10ca
"Elapsed time: 30032.256013 msecs"


Yesterday's was better! It didn't stop either, but it used all the processors:
times = [3000 {:timeout 5000} {:timeout 5000} {:timeout 5000} {:timeout 5000} 1000 3000 2000]
"Elapsed time: 5007.784076 msecs"
29000

I'll update yesterday's to send the actual launch time in the promise, then I'm calling it quits.

I REALLY NEED TO GIVE UP! However, when it does get stuck, it gets stuck while starting the 
first eight. For example, the running-cnt stops at 2 or 3. 

Too bad [[https://www.amazon.com/Clojure-High-Performance-JVM-Programming/dp/1787129594][this]] (high-performance clojure/jvm) is published by Packt!

*** I'm going with my 'sophisticated' futures one; this is the last one with core.async

This [[https://books.google.com/books?id=wU8oDwAAQBAJ&pg=PA231&lpg=PA231&dq=clojure+realized?+versus+future-done?&source=bl&ots=jp-WamYmFj&sig=EVCmaMEv1SyUiGteYzTWgJOGNRw&hl=en&sa=X&ved=0ahUKEwi73vy0oJbXAhUJ6iYKHWwWDTcQ6AEIWjAH#v=onepage&q=clojure%20realized%3F%20versus%20future-done%3F&f=false][page]] about future-done? in hi-performance jvm ... is good.
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  ([func members maxtime] (pmap-timeout func members maxtime :timeout))
  ([func members maxtime timeout-key]
   (let [chan&prom (map #(let [c (chan)
                               p (promise)]
                           (go (deliver p (System/currentTimeMillis))
                               (>! c {::val (func %)}))
                           [c p])
                        members)]
     ;; They won't start until I dereference??? Back to the future!
     (map (fn [[_ p]] (future (deref p))) chan&prom)
     ;; This was designed to gets around futures not .stop-ing. Still doesn't stop.
     (doall
      (map (fn [mem [c p]]
             (let [launched (deref p)
                   remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                   [v _] (alts!! [c (timeout remaining)])]
               (if (contains? v ::val)
                 (::val v)
                 {timeout-key mem})))
           members
           chan&prom)))))



*** I gave up!
*** Here is an offending pn, it is not k-bounded
**** Code
(def pnpn
{:initial-marking [1 0 0 0],
 :transitions
 [{:name :m1-start-job,
   :tid 2,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-start-job, :j 2001, :jt :jobType1, :ends 2368.3676866897163, :clk 2367.3676866897163, :line 1275, :mjpact :aj, :m :m1},
   :visible? true}
  {:name :m1-complete-job,
   :tid 3,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-complete-job, :bf :b1, :j 2001, :n 1, :clk 2368.3676866897163, :line 1278, :mjpact :bj, :m :m1},
   :visible? true}
  {:name :m2-start-job,
   :tid 4,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-start-job, :bf :b1, :j 2001, :n 3, :clk 2370.6070474961243, :line 1287, :mjpact :sm, :m :m2},
   :visible? true}
  {:name :m2-complete-job,
   :tid 5,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-complete-job, :m :m2, :j 2001, :ent 2367.3676866897163, :clk 2371.7770474961244, :line 1290, :mjpact :ej},
   :visible? true}],
 :sigma 0.75,
 :winners {},
 :arcs
 [{:aid 2, :source :place-1, :target :m1-start-job, :name :aa-2, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 3, :source :m1-start-job, :target :place-2, :name :aa-3, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 4, :source :place-2, :target :m1-complete-job, :name :aa-4, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 5, :source :m1-complete-job, :target :place-3, :name :aa-5, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 6, :source :place-3, :target :m2-start-job, :name :aa-6, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 7, :source :m2-start-job, :target :place-4, :name :aa-7, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 8, :source :place-4, :target :m2-complete-job, :name :aa-8, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 9, :source :m2-complete-job, :target :place-1, :name :aa-9, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 210, :source :m1-start-job, :target :place-4, :name :aa-210, :type :normal, :multiplicity 1, :priority 2}],
 :rgraph
 ({:M [1 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0], :rate 1.0}
  {:M [0 1 0 0], :fire :m1-complete-job, :Mp [0 0 1 0], :rate 1.0}
  {:M [0 0 1 0], :fire :m2-start-job, :Mp [0 0 0 1], :rate 1.0}
  {:M [0 0 0 1], :fire :m2-complete-job, :Mp [1 0 0 0], :rate 1.0}),
 :msg-table {:m2-unstarved {}, :m1-unblocked {}, :m2-starved {}, :ordinary {}, :m1-blocked {}},
 :marking-key [:place-1 :place-2 :place-3 :place-4],
 :starting-links (),
 :places
 [{:name :place-1, :pid 0, :initial-tokens 1, :visible? true}
  {:name :place-2, :pid 1, :initial-tokens 0, :visible? true}
  {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
  {:name :place-4, :pid 3, :initial-tokens 0, :visible? true}]})

**** I'm now using "k-bounding" to truncate rgraphs in reach.clj.
**** 30 iterations and nothing useful found
**** No implementation of method: :sch-send!
Once again (it was happening Oct 7, and Friday, among other times) I'm getting a error
No implementation of method: :sch-send! of protocol: #'taoensso.sente.interfaces/IServerChan found for 
class: org.httpkit.server.AsyncChannel

Unlike Friday's episode, restarting the client is not helping. 
However, restarting completely -- lein restart-repl -- did the trick. 
Could it be that running -- diag-run -- before having the client up messes up the client? 

*** Hopeful-pn
{:initial-marking [1 0 0 0 0],
 :transitions
 [{:name :m1-start-job,
   :tid 38,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-start-job, :j 1991, :jt :jobType1, :ends 2356.5705647971827, :clk 2355.3103128463604, :line 1233, :mjpact :aj, :m :m1},
   :visible? true}
  {:name :m1-complete-job,
   :tid 39,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-complete-job, :bf :b1, :j 1991, :n 1, :clk 2356.5705647971827, :line 1238, :mjpact :bj, :m :m1},
   :visible? true}
  {:name :m2-start-job,
   :tid 40,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-start-job, :bf :b1, :j 1991, :n 3, :clk 2358.9070474961236, :line 1247, :mjpact :sm, :m :m2},
   :visible? true}
  {:name :m2-complete-job,
   :tid 41,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-complete-job, :m :m2, :j 1991, :ent 2355.3103128463604, :clk 2360.0770474961237, :line 1248, :mjpact :ej},
   :visible? true}],
 :sigma 0.75,
 :winners {},
 :arcs
 [{:aid 74, :source :place-1, :target :m2-start-job, :EDITED true :name :aa-74, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 75, :source :m1-start-job, :target :place-2, :name :aa-75, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 76, :source :place-2, :target :m1-complete-job, :name :aa-76, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 77, :source :m1-complete-job, :target :place-3, :name :aa-77, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 78, :source :place-3, :target :m1-start-job, :EDITED true :name :aa-78, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 79, :source :m2-start-job, :target :place-4, :name :aa-79, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 80, :source :place-4, :target :m2-complete-job, :name :aa-80, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 81, :source :m2-complete-job, :target :place-1, :name :aa-81, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 205, :source :m1-start-job, :target :Place-103, :name :aa-205, :type :normal, :multiplicity 1, :priority 2}
  {:aid 206, :source :Place-103, :target :m2-start-job, :name :aa-206, :type :normal, :multiplicity 1}],
 :rgraph
 {:rgraph
  [{:M [1 0 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0 1], :rate 1.0}
   {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
   {:M [0 0 1 0 1], :fire :m2-start-job, :Mp [0 0 0 1 0], :rate 1.0}
   {:M [0 0 0 1 0], :fire :m2-complete-job, :Mp [1 0 0 0 0], :rate 1.0}],
  :k-limited? false},
 :msg-table {:m2-unstarved {}, :m1-unblocked {}, :m2-starved {}, :ordinary {}, :m1-blocked {}},
 :k-limited? false,
 :marking-key [:place-1 :place-2 :place-3 :place-4 :Place-103],
 :starting-links (),
 :places
 [{:name :place-1, :pid 0, :initial-tokens 1, :visible? true}
  {:name :place-2, :pid 1, :initial-tokens 0, :visible? true}
  {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
  {:name :place-4, :pid 3, :initial-tokens 0, :visible? true}
  {:name :Place-103, :pid 4, :initial-tokens 0}]}

** <2017-10-30 Mon>

The hopeful PN produces this rgraph, which apparently is not sufficient to parse the log. 

 {:rgraph
  [{:M [1 0 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0 1], :rate 1.0}
   {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
   {:M [0 0 1 0 1], :fire :m2-start-job, :Mp [0 0 0 1 0], :rate 1.0}
   {:M [0 0 0 1 0], :fire :m2-complete-job, :Mp [1 0 0 0 0], :rate 1.0}],

The log looks like this:

[{:act :m1-complete-job, :bf :b1, :j 1689, :n 0, :clk 1999.9234365080201, :line 0, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1690, :jt :jobType1, :ends 2000.9234365080201, :clk 1999.9234365080201, :line 1, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1688, :ent 1996.9156570964649, :clk 2000.6492850612497, :line 2, :mjpact :ej}
 {:act :m2-start-job, :bf :b1, :j 1689, :n 1, :clk 2000.6492850612497, :line 3, :mjpact :sm, :m :m2}
 {:act :m1-complete-job, :bf :b1, :j 1690, :n 0, :clk 2000.9234365080201, :line 4, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1691, :jt :jobType1, :ends 2001.9234365080201, :clk 2000.9234365080201, :line 5, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1689, :ent 1998.198793731718, :clk 2001.8192850612497, :line 6, :mjpact :ej}
 {:act :m2-start-job, :bf :b1, :j 1690, :n 1, :clk 2001.8192850612497, :line 7, :mjpact :sm, :m :m2}
 {:act :m1-complete-job, :bf :b1, :j 1691, :n 0, :clk 2001.9234365080201, :line 8, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1692, :jt :jobType1, :ends 2002.9234365080201, :clk 2001.9234365080201, :line 9, :mjpact :aj, :m :m1}
 {:act :m1-complete-job, :bf :b1, :j 1692, :n 1, :clk 2002.9234365080201, :line 10, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1693, :jt :jobType1, :ends 2003.9234365080201, :clk 2002.9234365080201, :line 11, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1690, :ent 1999.9234365080201, :clk 2002.9892850612498, :line 12, :mjpact :ej}]

The reason that it can't model the log is that it isn't looking at job-ids. 
If instead of what I'm doing, I started with (like the log shows) m1-complete-job j 1689 on line 0,
then I can jump down to :m2-start-job j 1689 on line 3. THIS is parsing the log!

TUESDAY CLARIFICATION: Parsing the log must still means doing things in the order
specified by the reachability graph! The problem MIGHT be different from what 
I describe above. The reason it can't parse the log is that the argument PN has a buffer 
of only 1, so it can't express the level of asynchronicity in the log??? (FALSE?).

WHATEVER! First fix regression testing, then see what good the job assignments might provide.

What I need is indeed, "next-ordinary-message-on-job" and I need to count what messages
I parsed and remove them / associate them with the job. 
When I'm done, I count what content I accounted for by each. 
EASY PEASY. 

<2017-10-31 Tue>

Well, maybe not so easy. First, there is the matter that we need to keep moving ahead with
new jobs in order to parse the entire log. Secondly, there is the technical problem of 
where (in what object) do we keep notice of consumption of a message. 

I'll try to create a map with the messages and other data and validate with the 
N=3 pn... 
  -rw-r--r--   1 pdenno  pdenno  334035 Oct 15 12:03 m2-j1-n3-block-mild-out.clj
So I'll just attach the 334k log to every PN. Let's see how good the GC is!

C-c C-t n has apparently been lying to me!
** <2017-10-31 Tue>

On the way to exploring the "more flexible" interpretation of the log, I found and
fixed a bug in starting-links (the "distinct" thing). This might not have an effect
on functionality. 

I now pass in most information *including the log* through pn. The idea is to track
which job is consuming which message, a relaxation of the log interpretation to account
for a lack of (or insufficient) buffer. 
** <2017-11-01 Wed>

==> I believe that today's algorithm subsumes functionality of disorder-fitness. 


(defn next-ordinary-on-job
  "Return the next ordinary message, at index n or later."
  [pn n jid]
  (let [data (:log pn)
        last-ix (:last-line pn)] ; POD put on pn
    (loop [indx n]
      (if (> indx last-ix)
        nil
        (if-let [msg (and (ordinary? (nth data indx))
                          (== (:j (nth data indx)) jid))]
          msg
          (recur (inc indx)))))))

[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0, :job 1689}
 {:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0, :job 1689}]

First one failed on 
{:msg
 {:act :m1-complete-job,
  :bf :b1,
  :j 1692,
  :n 1,
  :clk 2002.9234365080201,
  :line 10,
  :mjpact :bj,
  :m :m1},
 :interp-last
 {:M [3 1 0 0 1],
  :fire :m2-start-job,
  :Mp [2 1 0 1 0],
  :rate 1.0,
  :job 1692,
  :clk 2001.9234365080201,
  :indx 9,
  :relax? :add-job}}

Even if second one succeeds, it is doing so only on buffer size, thus something needs adjustment. 
Hmmm, maybe not; at :Mp buffer is 2. 

{:msg
 {:act :m2-complete-job,
  :m :m2,
  :j 1720,
  :ent 2034.2910787732983,
  :clk 2038.089285061252,
  :line 130,
  :mjpact :ej},
 :interp-last
 {:M [3 0 1 1 0],
  :fire :m2-complete-job,
  :Mp [3 0 1 0 1],
  :rate 1.0,
  :job 1720,
  :clk 2036.919285061252,
  :indx 129,              <------ Looks like this should be line 128
  :relax? :active}}

Second is really messed up! :m2-complete-job at 129, then it chooses :m2-complete-job ???

Log looks like this:
{:act :m2-complete-job, :m :m2, :j 1719, :ent 2033.0614667964674, :clk 2036.919285061252, :line 128, :mjpact :ej}
{:act :m2-start-job, :bf :b1, :j 1720, :n 2, :clk 2036.919285061252, :line 129, :mjpact :sm, :m :m2}
{:act :m2-complete-job, :m :m2, :j 1720, :ent 2034.2910787732983, :clk 2038.089285061252, :line 130, :mjpact :ej}

So how did the last action become :indx 129 :m2-complete-job ???

Should I update :graph-link on an :active ? I think so. I did. 
Need to see the whole interp. Where is 128? 
  {:M [2 1 0 1 0],
   :fire :m1-start-job,
   :Mp [3 0 1 1 0],
   :rate 1.0,
   :job 1719,
   :clk 2036.919285061252,
   :indx 128,                      <--------------------- 128 is :m2-complete-job
   :relax? :active}
  {:M [3 0 1 1 0],
   :fire :m2-complete-job,
   :Mp [3 0 1 0 1],
   :rate 1.0,
   :job 1720,
   :clk 2036.919285061252,
   :indx 129,
   :relax? :active}]}

(filter #(= (:Mp glink) (:M %)) (:rgraph pn))]

Needs :fire like for normal messages. 
Something is wrong with the way I'm thinking about this, because when I add the 
extra condition, things stop after just a few lines.

There is no question that the message condition has to be there -- that's the message!
So it must be that I'm screwing up on :M / :Mp YEAH -- THOSE shouldn't be in the condition!

8 seconds!!!

(def pnpn (tryme)) ;; Then uncomment...
(def lll (-> (app-info) :problem :scada-log))
(time (def foo (interpret-scada pnpn lll (-> pnpn :starting-links first))))

If still slow, try shorting out the call to the Djikstra thing.

Something changed, because now it takes 1200 milliseconds. Acceptable, barely.

Yeah, without Djikstra it finishes in 50 milliseconds and still goes all the way.
What gives? 

Without checking first: 2796.
        Checking first: 2796

*** This version of link-match  should not be necessary.
(defn link-match [pn action llink msg]
  (let [glink (:graph-link pn)]
    (if-let [link (some #(when (and (= (:Mp llink) (:M %)) 
                                    (= (:fire %) (:act msg)))
                           %)
                        (:rgraph pn))]
      (link+msg link msg)
      ;; This relaxes conformance to rgraph
      ;; Use :graph-link to find which of the candidate states is nearest. 
      (when-let [links (filter #(and (= (:fire %) (:act msg)))
                               (:rgraph pn))]
        (let [graph (:loom-graph pn)
              from (:Mp glink)
              dists (map
                     (fn [l] {:link l
                              :dist (count (alg/dijkstra-path
                                            graph
                                            from
                                            (:M l)))})
                     links)
              best (-> (sort #(< (:dist %1) (:dist %2)) dists) first :link)]
          (cl-format *out* "~%counts = ~{~A ~}" (map :dist dists))
          (when best
            (as-> (link+msg best msg) ?link
              (if (= action :aj)
                (assoc ?link :relax? :add-job)
                (assoc ?link :relax? :active)))))))))
*** Cleaning upt some PQN stuff
;;; This is only called when there aren't many jobs. Typically, just one. 
#_(defn qpn-typical-job-id
  "Return log entry from (statistically) most typical jobs (a statistical analysis)."
  [pn]
  ;; Check variance across qpn-c-t-t; use it (and process pattern) to determine job types.
  ;(NYI)
  ;; Of the types, choose one (a safe one).
  (let [tkn-id (max (Math/round (/ (-> pn :sim :max-tkn) 2.0)) 1)]
    (vector ; POD current assume just one job type. 
     (loop [log (qpn-gather-tkn (-> pn :sim :log) tkn-id) ; this collects just :acts
            trace []]
       (let [msg (first log)]
         (cond (empty? log) trace, 
               (some #(= (:act %) (:act msg)) trace) trace,
               :else (recur (next log) (conj trace msg))))))))
            

*** Tomorrow
So it only hits "ordinary" about 200 times!
Why isn't new job ordinary? Why does that create a disconnect; it didn't 
before I wrote this!
(In fact, EVERYTHING worked without Djikstra on this test case!)
** <2017-11-02 Thu>

Force everything in this test case through the old method.
If can't get it down to 100 msec, consider using FIRST interpretation. 
Don't commit until this is figured out. 

Get's through 565. Very odd. 
Aha! Gets throug 565 for the *second* start link. Gets through all 3000 for the *first*!

43 milliseconds!

[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0, :job 1689}
 {:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0, :job 1689}]

The system is, in fact, in the situation of the first!
{:act :m1-complete-job, :bf :b1, :j 1689, :n 0, :clk 1999.9234365080201, :line 0, :mjpact :bj, :m :m1}

OK, now we have lax-reach which on hopeful-pn is k-limited. It has this rgraph:
 :rgraph
 ({:M [0 1 0 0 0], :fire :m1-complete-job, :Mp [0 0 1 0 0], :rate 1.0}
  {:M [0 0 1 0 0], :fire :m1-start-job,    :Mp [0 1 0 0 1], :rate 1.0}
  {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
  {:M [0 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 0 2], :rate 1.0}
  {:M [0 1 0 0 2], :fire :m1-complete-job, :Mp [0 0 1 0 2], :rate 1.0}),

place-103 is indeed what I intend to be a buffer.

:marking-key [:place-1 :place-2 :place-3 :place-4 :Place-103],
Note that there is no transition out of [0 0 1 0 2]. Can this be fixed? 

Things are not going well with the repair. The lax idea is okay, but instead of
one token on :m1, I should have 1 token on each machine. Exception will work 
to specify the buffer sizes. 


*** Old lax-reach
(defn lax-reach
  "Return a rgraph where possibly it is necessary to experiment with 
   initial markings to make things go."
  ([pn] (lax-reach pn 2))
  ([pn max-k]
   (if-let [rgraph (:rgraph (pnr/simple-reach pn max-k))]
     rgraph  ; POD :m1 is entry machine??? (MJPdes notion)
     (let [m1-starters (map :name (filter #(= :m1 (-> % :rep :m)) (:transitions pn)))
           m1-places   (distinct
                        (into (mapv :target (filter (fn [a] (some #(= % (:source a)) m1-starters)) (:arcs pn)))
                              (mapv :source (filter (fn [a] (some #(= % (:target a)) m1-starters)) (:arcs pn)))))
           mkey (:marking-key pn)
           ;; Try markings that put tokens into :m1
           imarks (mapv (fn [pname]
                          (reduce (fn [mark ix]
                                    (conj mark (if (= pname (nth mkey ix)) 1 0)))
                                  []
                                  (-> mkey count range)))
                        m1-places)]
       (some #(let [pn (pnu/set-marking pn %)
                    reach (pnr/simple-reach pn max-k)]
                (when (:rgraph reach)
                  (-> pn
                      (assoc :rgraph (:rgraph reach))
                      (assoc :k-limited? (:k-limited? reach)))))
             imarks)))))


*** Look at all this shrapnel!
                                           
  (let [aset (get m-arcs m)]
     (and (contains? aset (:source %))
     (contains? aset (:target %))))
      (:places pn)))))

     {:machines machines
      :m-t m-trans
      :m-a m-arcs})))

   m1-starters (map :name (filter #(= :m1 (-> % :rep :m)) (:transitions pn)))
   m1-places   (filter (fn [p] (and (some #(= p (:source )) m1-starters)) (:places pn)))
   (distinct
      (into (mapv :target (filter (fn [a] (some #(= % (:source a)) m1-starters)) (:arcs pn)))
            (mapv :source (filter (fn [a] (some #(= % (:target a)) m1-starters)) (:arcs pn)))))
           mkey (:marking-key pn)
           ;; Try markings that put tokens into :m1
           imarks (mapv (fn [pname]
                          (reduce (fn [mark ix]
                                    (conj mark (if (= pname (nth mkey ix)) 1 0)))
                                  []
                                  (-> mkey count range)))
                        m1-places)]
       (some #(let [pn (pnu/set-marking pn %)
                    reach (pnr/simple-reach pn max-k)]
                (when (:rgraph reach)
                  (-> pn
                      (assoc :rgraph (:rgraph reach))
                      (assoc :k-limited? (:k-limited? reach)))))
             imarks)))))

** <2017-11-03 Fri>

*** I start with this version of lax-reach(defn lax-reach
  "Return a rgraph where possibly it is necessary to experiment with 
   initial markings to make things go."
  ([pn] (lax-reach pn 2))
  ([pn max-k]
   ;(if-let [rgraph (:rgraph (pnr/simple-reach pn max-k))]  rgraph  :foo); POD :m1 is entry machine??? (MJPdes notion)
   (let [machines (distinct (mapv #(-> % :rep :m)
                                  (filter #(contains? % :rep) (:transitions pn))))
         ;; map of transitions associated with a machine. Transition associate with messages, which associate to machines.
         m-trans (zipmap machines
                         (map (fn [m]
                                (set (map :name (filter #(= m (-> % :rep :m))
                                                        (:transitions pn)))))
                              machines))
         ;; map of arcs associated with a machine. Must have both ends on a transition related to the machine. 
         m-arcs (zipmap machines
                        (map (fn [m]
                               (let [tset (get m-trans m)]
                                 (set (map :name
                                           (filter #(and (contains? tset (:source %))  ; <--- Not bipartite!
                                                         (contains? tset (:target %)))
                                                   (:arcs pn))))))
                             machines))
         ;; map of places associated with a machine. Must be between trans of the same machine. 
         m-places (zipmap machines ; there is an arc that has this place as source and a m-trans machine as target
                          (map (fn [m]  ; and an arc that has this place as target and a m-trans machine as source
                                 (let [mset (get m-trans m)]
                                   (set (map :name
                                             (filter (fn [p] 
                                                       (some #(or (and (contains? mset (:source %))
                                                                       (= (:target %) (:name p)))
                                                                  (and (contains? mset (:target %))
                                                                       (= (:source %) (:name p))))
                                                             (:arcs pn))) ; (get m-arcs m))) <---- When the above is fixed.
                                                     (:places pn))))))
                               machines))]
          {:machines machines
           :m-t m-trans
           :m-a m-arcs
           :starters m-places})))
** <2017-11-04 Sat>

I did paper until 4PM. I learned about Mahoney's approach finding a separate sigma for each measurement dimension. 
Will I have time for all of this???

*** Old tryme
(defn tryme []
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")]
    (as-> hopeful-pn ?pn
      (assoc ?pn :last-line (-> log last :line))
      (assoc ?pn :rgraph (pnr/simple-reach ?pn)) ; returns a map {:rgraph ... :k-limited...}
      (assoc ?pn :k-limited? (-> ?pn :rgraph :k-limited?))
      (assoc ?pn :rgraph (-> ?pn :rgraph :rgraph vec))
      (assoc ?pn :loom-graph (rgraph2loom-graph (-> ?pn :rgraph)))
      (assoc ?pn :starting-links (fit/starting-links ?pn log 0))
      (assoc ?pn :msg-table (fit/compute-msg-table ?pn log))
      (assoc ?pn :distance-fn pnn/euclid-dist2))))

*** repair-reach; probably not going to use it
;;; (def pnpn (lax-reach hopeful-pn))
;;; [:place-1 :place-2 :place-3 :place-4 :Place-103]
;;; m-mp : #{[0 1 0 0 0]} -- True, you'll never see this after starting with it. 
;;; mp-m : #{[0 0 1 0 2]}
(defn repair-reach
  "If present, try to remove traps from a k-limited graph."
  ([pn] (repair-reach pn 2))
  ([pn max-k]
   (let [m  (set (distinct (map #(:M %)  (:rgraph pn))))
         mp (set (distinct (map #(:Mp %) (:rgraph pn))))
         m-mp (clojure.set/difference m mp)
         mp-m (clojure.set/difference mp m)
         trans (map :name (:transitions pn))]
     ;; m-mp: try to find a transition from any existing :M that yields Mp.
     (let [seek-mp [0 1 0 0 0]
           m-mp-fix (reduce (fn [answ1 trans]
                              (into answ1
                                    (vec (reduce (fn [answ2 mark]
                                                   (into answ2
                                                         (filterv #(= seek-mp (:Mp %))
                                                                  (pnr/next-marks pn mark))))
                                                 []
                                                 m))))
                            []
                            trans)]
       (if (empty? m-mp-fix)
         (let [test-one (first m-mp)]
           (filterv #(not= test-one (:M %)) (:rgraph pn)))
         m-mp-fix)))))

*** hopeful-pn (pnpn) fizzles out at line 594:

{:M [0 1 0 1 0], :fire :m2-complete-job, :Mp [1 1 0 0 0], :rate 1.0, :job 1834, :clk 2173.361361140053, :indx 594}]

{:act :m2-complete-job, :m :m2, :j 1834, :ent 2169.2631314350665, :clk 2173.361361140053, :line 594, :mjpact :ej}
{:act :m2-start-job, :bf :b1, :j 1835, :n 1, :clk 2173.361361140053, :line 595, :mjpact :sm, :m :m2}
{:act :m1-complete-job, :bf :b1, :j 1836, :n 0, :clk 2173.4862364331248, :line 596, :mjpact :bj, :m :m1}


Let's see if the problem is that N=3 and lax is set to two. Maybe first I'll try lax set to 3. 
YUP! That's an easy test! 

*** Thinking about how interpretation should really work:
So I think I need the converse of lax-reach: lax-interp which will:
  1) Allow "pushing to full buffers"  when no other transition (but only up to "max-buffer" = 10 to terminate early) 
  2) Allow "pulling from  empty buffers" when no other transition. 

To do this:
 a) Must determine what places are buffers.
 b) Must be able to determine which place is the problem, and whether it is 
 c) There are two "when no other transition" conditions" -- I guess that isn't a problem though (zero or two tells you).

Hmmm... Maybe the easiest way to implement this isn't to extend into a larger reachability set, but
        rather just make jobs magically appear and disappear... UNFORTUNATELY, that will screw up 
        job tracking. 

**** Three alternatives then:
 (1): Extend the k-max bound on-the-fly as you get into failure situations.
 (2): Add jobs to deal with not having false starvation, remove jobs to deal with false blocking.
 (3): Do what I just did: Run lax-reach again with a higher number. 

(3) is by far the easiest, and I don't think it is computationally expensive either. 
    I'm going to try (3)!!!

This needs to wrap lax-reach and interp in a loop. Refactoring!

*** interpretations got factored out. 
;;; POD this is probably the most time consuming part of the pnn process.
;;; POD with new lax interpretation, will need to run every one since multiple
;;;     might make it to the end. 
(defn interpretations
  "Add :interps and :fails to the pn describing what interpretations worked."
  [pn log]
  (let [last-indx (:last-line pn)]
    (reduce (fn [pn link]
              (let [interp (interpret-scada pn log link)]
                (if (and (number? (-> interp last :indx))
                         (== last-indx (-> interp last :indx)))
                  (update pn :interps conj interp)
                  (update pn :fails conj (last interp)))))
            (-> pn
                (assoc :interps [])
                (assoc :fails []))
            (:starting-links pn))))

** <2017-11-05 Sun>

8:46 - A few minutes to fix things before starting writing???
9:29 - Will need to investigate a bug here: 
{:m2-unstarved {[0 1 0 1 0] 10, 
                [0 1 0 1 1] 4},  <---- wrong
 :m1-blocked   {[0 1 0 1 3] 30}
 :m1-unblocked {[0 0 1 1 2] 30},
 :m2-starved   {[1 1 0 0 0] 10, 
                [1 1 0 0 1] 4},  <---- wrong
 :ordinary     {[0 0 1 1 1] 243,
		[0 1 0 1 0] 155,
		[1 1 0 0 2] 247,
		[0 1 0 1 3] 326,
		[1 1 0 0 3] 325,
		[0 1 0 1 1] 393,
		[1 1 0 0 0] 10,
		[1 0 1 0 1] 4,    These are also different, and should include the above. (They might.)
		[0 0 1 1 0] 145,
		[0 0 1 1 2] 326,
		[1 1 0 0 1] 160,
		[0 1 0 1 2] 568,
		[1 0 1 0 0] 10}}

It is probably the case that the next-link stuff can be simplified, 
use of Djikstra etc. removed. This is obviated by the max-k-used approach.

** <2017-11-06 Mon>

I'm going to let yesterday's bug slide, because I don't think it hurts anything. 
I'm cleaning up all the mess from yesterday's conflict over whether the implementation
in fact conforms to the math -- it does. The problem is in the "artifacts of 
inaccessible formalisms" -- formalisms which get elided in the Parzen window 
implementation. 

** <2017-11-07 Tue>

find-interpretation(2loops) --> lax-reach (:rgraph pn)
(:interp pn)                --> interpret-scada (get an interpretation)
(:max-k-used pn)
(:rgraph pn)

*** ??? The work to 1:20 was a waste! Somehow the calculation of :loom-graph ended up after :distance-fn

--> Stuck in a call to the evaluation of marking against the parzen functions. 
(which of each?) 
[3 0 1 1 0] -- This data doesn't match Ugh!


Problem ----> ((-> pnpn :pdf-fns :m1-unblocked) [3 0 1 1 0])
It looks like it can't do the Djikstra graph search (no successors* for class nil)

Indeed, we are again working with the markings in a different order!
:loom-graph and :rgraph match up. msg-table DOES NOT.

There could be problems with graphs (not ergodic, traps and siphons?) that make 
the distance function fail???

((-> pnpn :pdf-fns :m1-unblocked) [0 1 0 1 0])
from =  [0 0 1 1 2]  to =  [0 1 0 1 0]

----> It looks like it can't do the Djikstra graph search (no successors* for class nil)
Even with the pnpn issue fixed I get this. The reason is that the GRAPH is nil. 



Did those couple of wrong values do this much damage? It looks to be the case!

{:m2-unstarved {[0 1 0 1 0] 10, [0 1 0 1 1] 4},
 :m2-starved   {[1 1 0 0 0] 10, [1 1 0 0 1] 4},  


{[0 0 1 1 1] [:ordinary 0.09854858103526418],  
 [0 1 0 1 0] [:m2-unstarved 0.7341381289208004],  <-------------- makes sense
 [1 1 0 0 2] [:ordinary 0.1019784166519701],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.12070348087608791],
 [0 1 0 1 1] [:m2-unstarved 0.3353453223020011],  <-------------- unfortunate
 [1 1 0 0 0] [:m2-starved 0.7341381289208004],    <-------------- makes sense
 [1 0 1 0 1] [:m2-starved 0.00817822101068792],   <-------------- huh???
 [0 0 1 1 0] [:ordinary 0.05712535334821984],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.3353453223020011],    <-------------- Unfortunate
 [0 1 0 1 2] [:ordinary 0.21331334446723213],
 [1 0 1 0 0] [:m2-starved 0.020410588875005395]}  <-------------- huh???

Original msg-table results from today's implementation. Not what it was!

{[0 0 1 1 1] [:ordinary 0.09854858103526418],
 [1 1 0 0 2] [:ordinary 0.1019784166519701],
 [1 1 0 0 3] [:ordinary 0.12070348087608791],
 [0 1 0 1 1] [:ordinary 0.15297323906481347],      
 [1 0 1 0 1] [:ordinary 0.005574471494601208],
 [0 0 1 1 0] [:ordinary 0.05712535334821984],
 [0 1 0 1 2] [:ordinary 0.21331334446723213],
 [1 1 0 0 0] [:m2-starved 1.0],
 [1 1 0 0 1] [:m2-starved 0.06948345122280154],
 [1 0 1 0 0] [:m2-starved 0.028565500784550373]}
 [0 1 0 1 0] [:m2-unstarved 1.0],                  
 [0 1 0 1 3] [:m1-blocked 1.0],
 [0 0 1 1 2] [:m1-unblocked 1.0],

What is in fitness_test:

           {[0 1 0 1 0] [:ordinary 0.07812345592321546],
            [2 0 1 1 0] [:ordinary 0.19350798937548197],
            [1 1 0 1 0] [:ordinary 0.10565451941946981],
            [3 0 1 0 1] [:ordinary 0.09387730377891051],
            [1 0 1 1 0] [:ordinary 0.1783054552497219],
            [1 0 1 0 1] [:ordinary 0.08572916833008677],
            [2 0 1 0 1] [:ordinary 0.10642989332503937]
            [0 0 1 0 1] [:m2-starved 1.0],
            [0 1 0 0 1] [:m2-starved 0.028565500784550373],
            [2 1 0 1 0] [:m1-unblocked 1.0],
            [3 0 1 1 0] [:m1-blocked 1.0],
            [0 0 1 1 0] [:m2-unstarved 1.0],

This is what I was getting on the 24th. It was also in the powerpoint. 
gov.nist.sinet.fitness> (pprint (tryme 0.75))
{[0 1 0 1 0] [:ordinary 0.07812345592321546],
 [2 0 1 1 0] [:ordinary 0.19350798937548197],
 [1 1 0 1 0] [:ordinary 0.10565451941946981],
 [3 0 1 0 1] [:ordinary 0.09387730377891051],
 [1 0 1 1 0] [:ordinary 0.1783054552497219],
 [1 0 1 0 1] [:ordinary 0.08572916833008677],
 [2 0 1 0 1] [:ordinary 0.10642989332503937]}
 [0 0 1 0 1] [:m2-starved 1.0],                  <--------------
 [0 1 0 0 1] [:m2-starved 0.028565500784550373], <-------------- Should be ordinary
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],


There are 16 markings in the msg-table and 28 markings in the rgraph. 

So it is a little bit worse today for some reason:

Q: Is what I'm calling the original-msg-table also in the Powerpoint? 
A: No, there is a discrepency due to moving things around for 10 4 vs 14. 
And the marking-key has changed so, I'm not investigating. 

---> Key problem: I need to look at alternative formulations, some as simple as changing sigma, 
     but also straight (no Euclidean) and normalized. 

I think a probabilistic one will be best. I could calculate the probability of 
transition from each state to other state just by looking at the interpretation. 
I don't think the formulation I have in mind is a Markov chain, because I'm not interested
in the "no op" transition to self. 

Ideally what I'd like is the probability of transition between two states
where there are multiple paths between the states (sum of all the paths).
But what does that mean? Some paths have cycles. It's not like I'm looking
for some steady state kind of thing. 

A simplification that I can understand is to find the shortest path and calculate
the probability of that path. 

*** Maybe better than the above is to put 1/probabilities on the transitions and make 
it find the shortest path that way. DO THIS!

Okay, First step is to continue to process the interpretation, producing transition 
probabilities for every pair where there is a transition. 

{:M [0 1 0 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 1], :rate 1.0, :indx 0, :job 1689}

It's easy, just a reduce that does the counting. 

{[0 0 1 1 1] {[0 1 0 1 2] 243},
 [0 1 0 1 0] {[0 0 1 1 0] 145, [1 1 0 0 0] 10},
 [1 1 0 0 2] {[0 1 0 1 1] 247},
 [0 1 0 1 3] {[1 1 0 0 3] 325, [0 0 1 1 3] 1},
 [1 1 0 0 3] {[0 1 0 1 2] 325},
 [0 1 0 1 1] {[0 0 1 1 1] 243, [1 1 0 0 1] 150},
 [1 1 0 0 0] {[1 0 1 0 0] 10},
 [1 0 1 0 1] {[1 1 0 0 2] 4},
 [0 0 1 1 0] {[0 1 0 1 1] 145},
 [0 0 1 1 2] {[0 1 0 1 3] 326},
 [1 1 0 0 1] {[1 0 1 0 1] 4, [0 1 0 1 0] 156},
 [0 1 0 1 2] {[1 1 0 0 2] 243, [0 0 1 1 2] 325},
 [1 0 1 0 0] {[1 1 0 0 1] 10}}

HMMM---> Now set the links in the loom graph to 1/P - 1, (e.g. if there is not alternative). 
         If this looks too "harsh," try log(1/p).
Yeah, I'll go with this. The alternative is to not use the costs in Djikstra and instead
do product of 1/p for each link. 

1/p - 1 looks pretty tough!
{:nodeset
 #{[0 0 1 1 1] [0 1 0 1 0] [1 1 0 0 2] [1 0 1 0 3] [0 1 0 1 3] [1 1 0 0 3] [0 1 0 1 1] [1 0 1 0 2] [1 1 0 0 0] [1 0 1 0 1] [0 0 1 1 0]
   [0 0 1 1 2] [1 1 0 0 1] [0 1 0 1 2] [0 0 1 1 3] [1 0 1 0 0]},
 :adj
 {[0 0 1 1 1] {[0 1 0 1 2] 0.0, [1 0 1 0 1] 99998.99999999999},
  [0 1 0 1 0] {[0 0 1 1 0] 0.06896551724137945, [1 1 0 0 0] 14.5},
  [1 1 0 0 2] {[0 1 0 1 1] 0.0, [1 0 1 0 2] 99998.99999999999},
  [1 0 1 0 3] {[0 0 1 1 2] 99998.99999999999},
  [0 1 0 1 3] {[1 1 0 0 3] 0.003076923076922977, [0 0 1 1 3] 325.0},
  [1 1 0 0 3] {[0 1 0 1 2] 0.0, [1 0 1 0 3] 99998.99999999999},
  [0 1 0 1 1] {[1 1 0 0 1] 1.6199999999999997, [0 0 1 1 1] 0.6172839506172838},
  [1 0 1 0 2] {[1 1 0 0 3] 99998.99999999999, [0 0 1 1 1] 99998.99999999999},
  [1 1 0 0 0] {[1 0 1 0 0] 0.0},
  [1 0 1 0 1] {[1 1 0 0 2] 0.0, [0 0 1 1 0] 99998.99999999999},
  [0 0 1 1 0] {[0 1 0 1 1] 0.0, [1 0 1 0 0] 99998.99999999999},
  [0 0 1 1 2] {[0 1 0 1 3] 0.0, [1 0 1 0 2] 99998.99999999999},
  [1 1 0 0 1] {[0 1 0 1 0] 0.025641025641025772, [1 0 1 0 1] 39.0},
  [0 1 0 1 2] {[0 0 1 1 2] 0.7476923076923079, [1 1 0 0 2] 1.337448559670782},
  [0 0 1 1 3] {[1 0 1 0 3] 99998.99999999999},
  [1 0 1 0 0] {[1 1 0 0 1] 0.0}},
 :in
 {[0 0 1 1 1] #{[0 1 0 1 1] [1 0 1 0 2]},
  [0 1 0 1 0] #{[1 1 0 0 1]},
  [1 1 0 0 2] #{[1 0 1 0 1] [0 1 0 1 2]},
  [1 0 1 0 3] #{[1 1 0 0 3] [0 0 1 1 3]},
  [0 1 0 1 3] #{[0 0 1 1 2]},
  [1 1 0 0 3] #{[0 1 0 1 3] [1 0 1 0 2]},
  [0 1 0 1 1] #{[1 1 0 0 2] [0 0 1 1 0]},
  [1 0 1 0 2] #{[1 1 0 0 2] [0 0 1 1 2]},
  [1 1 0 0 0] #{[0 1 0 1 0]},
  [1 0 1 0 1] #{[0 0 1 1 1] [1 1 0 0 1]},
  [0 0 1 1 0] #{[0 1 0 1 0] [1 0 1 0 1]},
  [0 0 1 1 2] #{[1 0 1 0 3] [0 1 0 1 2]},
  [1 1 0 0 1] #{[0 1 0 1 1] [1 0 1 0 0]},
  [0 1 0 1 2] #{[0 0 1 1 1] [1 1 0 0 3]},
  [0 0 1 1 3] #{[0 1 0 1 3]},
  [1 0 1 0 0] #{[1 1 0 0 0] [0 0 1 1 0]}}}


Not so hot! 1/p - 1 Not so hot. 
{[0 0 1 1 1] [:m2-unstarved 0.5531657059250906],
 [0 1 0 1 0] [:m2-starved 0.9774657532330877],
 [1 1 0 0 2] [:ordinary 0.32433564829827793],
 [0 1 0 1 3] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:m1-unblocked 0.997268694086773],
 [0 1 0 1 1] [:m2-unstarved 0.9575275090117306],
 [1 1 0 0 0] [:m2-starved 0.71428641972588],
 [1 0 1 0 1] [:ordinary 0.0013736263736265335],
 [0 0 1 1 0] [:m2-starved 0.9193441856793396],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 1.0],
 [0 1 0 1 2] [:m1-unblocked 0.997268694086773],
 [1 0 1 0 0] [:m2-starved 0.71428641972588]}

Log(1/p) even worse! Something is wrong!
{[0 0 1 1 1] [:m2-unstarved 0.6254312767723978],
 [0 1 0 1 0] [:m2-starved 0.9777466239702579],
 [1 1 0 0 2] [:m1-unblocked 0.46886011292787777],
 [0 1 0 1 3] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:m1-unblocked 0.9972728817730363],
 [0 1 0 1 1] [:m2-unstarved 0.9588869262560565],
 [1 1 0 0 0] [:m2-starved 0.738724839703402],
 [1 0 1 0 1] [:m2-starved 0.03766575475736669],
 [0 0 1 1 0] [:m2-starved 0.9214691872944045],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 1.0],
 [0 1 0 1 2] [:m1-unblocked 0.9972728817730363],
 [1 0 1 0 0] [:m2-starved 0.738724839703402]}

This looks good: It is a distance from the a m1-blocking to a m2-starving event
(alg/dijkstra-path-dist (-> pnpn :loom-prob) [0 1 0 1 3] [0 0 1 1 0])
[([0 1 0 1 3] [1 1 0 0 3] [0 1 0 1 2] [1 1 0 0 2] [0 1 0 1 1] [1 1 0 0 1] [0 1 0 1 0] [0 0 1 1 0]) 1.9073156746735405]

This looks wrong:
(alg/dijkstra-path-dist (-> pnpn :loom-prob) [0 0 1 1 0] [1 1 0 0 0])
[([0 0 1 1 0] [0 1 0 1 1] [1 1 0 0 1] [0 1 0 1 0] [1 1 0 0 0]) 3.729332149682496]

gov.nist.sinet.fitness> (ppprint (subvec iii 0 10))
[{:M [0 1 0 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 1], :rate 1.0, :indx 0, :job 1689}
 {:M [0 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 2], :rate 1.0, :job 1690, :clk 1999.9234365080201, :indx 1}
 {:M [0 1 0 1 2], :fire :m2-complete-job, :Mp [1 1 0 0 2], :rate 1.0, :job 1688, :clk 2000.6492850612497, :indx 2}
 {:M [1 1 0 0 2], :fire :m2-start-job, :Mp [0 1 0 1 1], :rate 1.0, :job 1689, :clk 2000.6492850612497, :indx 3}
 {:M [0 1 0 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 1], :rate 1.0, :job 1690, :clk 2000.9234365080201, :indx 4}
 {:M [0 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 2], :rate 1.0, :job 1691, :clk 2000.9234365080201, :indx 5}
 {:M [0 1 0 1 2], :fire :m2-complete-job, :Mp [1 1 0 0 2], :rate 1.0, :job 1689, :clk 2001.8192850612497, :indx 6}
 {:M [1 1 0 0 2], :fire :m2-start-job, :Mp [0 1 0 1 1], :rate 1.0, :job 1690, :clk 2001.8192850612497, :indx 7}
 {:M [0 1 0 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 1], :rate 1.0, :job 1691, :clk 2001.9234365080201, :indx 8}
 {:M [0 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 2], :rate 1.0, :job 1692, :clk 2001.9234365080201, :indx 9}]

THis is good (and same 1/p - 1 and log(1/p)
(alg/dijkstra-path-dist (-> pnpn :loom-prob) [0 0 1 1 1] [0 1 0 1 2])
***** [([0 0 1 1 1] [0 1 0 1 2]) 0.0]

Setting sigma to 0.2 doesn't help, suggesting that it isn't centered correctly.

***** {:mark [0 0 1 1 1], :class :ordinary, :score 0.39497228911318194}

gov.nist.sinet.fitness> (ppprint (:winners (tryme)))
{[0 0 1 1 1] [:ordinary 0.08358699988257319],
 [0 1 0 1 0] [:m2-starved 0.7257767484189018],
 [1 1 0 0 2] [:ordinary 0.08619508818420649],
 [0 1 0 1 3] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:m1-unblocked 0.9622687143632584],
 [0 1 0 1 1] [:m2-unstarved 0.5873481997390083],
 [1 1 0 0 0] [:m2-starved 0.7142857142857142],
 [1 0 1 0 1] [:ordinary 0.0013736263736263735],
 [0 0 1 1 0] [:m2-starved 0.30648643386722174],
***** [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 1.0],
 [0 1 0 1 2] [:m1-unblocked 0.9622687143632584],
 [1 0 1 0 0] [:m2-starved 0.7142857142857142]}

***** 30  instances of unblocking at [0 0 1 1 2] 
***** 326 instances of ordinary happening there. 

{:M [0 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 2], :rate 1.0, :job 1692, :clk 2001.9234365080201, :indx 9}
{:M [0 1 0 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 2], :rate 1.0, :job 1692, :clk 2002.9234365080201, :indx 10}
***** {:M [0 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 3], :rate 1.0, :job 1693, :clk 2002.9234365080201, :indx 11}
{:M [0 1 0 1 3], :fire :m2-complete-job, :Mp [1 1 0 0 3], :rate 1.0, :job 1690, :clk 2002.9892850612498, :indx 12}


({:mark [0 0 1 1 2], :class :m2-unstarved, :score 2.2849406843698177E-8}
 {:mark [0 0 1 1 2], :class :m1-unblocked, :score 1.0}
 {:mark [0 0 1 1 2], :class :m2-starved, :score 1.1923137284864743E-8}
 {:mark [0 0 1 1 2], :class :ordinary, :score 0.11199402299201237}
 {:mark [0 0 1 1 2], :class :m1-blocked, :score 8.400658371646288E-5})

Lots of these:
{:act :m2-unstarved, :prev-act :m2-start-job, :indx 2231, :Mp [0 1 0 1 0], :clk 2639.0818930886508, :job 2230}

{:m2-unstarved {[0 1 0 1 0] 10, [0 1 0 1 1] 4},
 :m1-unblocked {[0 0 1 1 2] 30}, <==================================== Huh
 :m2-starved {[1 1 0 0 0] 10, [1 1 0 0 1] 4},
 :ordinary
 {[0 0 1 1 1] 243,
  [0 1 0 1 0] 155,
  [1 1 0 0 2] 247,
  [0 1 0 1 3] 326,
  [1 1 0 0 3] 325,
  [0 1 0 1 1] 393,
  [1 1 0 0 0] 10,
  [1 0 1 0 1] 4,
  [0 0 1 1 0] 145,
  [0 0 1 1 2] 326, <----------------
  [1 1 0 0 1] 160,
  [0 1 0 1 2] 568,
  [1 0 1 0 0] 10},
 :m1-blocked {[0 1 0 1 3] 30}}

There should be *AT MOST 6* winners that are not :ordinary. There are 10. 

[0 1 0 1 1] Is a good example:

  [0 1 0 1 1] [:m2-unstarved 0.5873481997390083], 4    :m2-unstarved
  [0 1 0 1 1]                                     393  :ordinary

({:mark [0 1 0 1 1], :class :m2-unstarved, :score 0.5873481997390083}  <-- winner
 {:mark [0 1 0 1 1], :class :m1-unblocked, :score 5.280982762217078E-8}
 {:mark [0 1 0 1 1], :class :m2-starved,   :score 0.30648643386722174} <-- WHY? 
 {:mark [0 1 0 1 1], :class :ordinary,     :score 0.312370265870799}   <-- reasonable
 {:mark [0 1 0 1 1], :class :m1-blocked,   :score 5.280982762217078E-8})

** <2017-11-08 Wed>

*** false negatives
place-1 and place-4 are on m2, place-4 is busy. 
                               place-2 is busy. 

I'm continuing on with the WHY?
Maybe it is syncing on :M and should be on :Mp ?
[:place-1 :place-2 :place-3 :place-4 :Place-103]
  0          1        0          1      1         (That really isn't m2-starving because it is busy!)
                                                  (Busy and one in the buffer, it won't even transition to starving.)

 [1] {:M [0 1 0 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0], :rate 1.0, :job 1836, :clk 2173.4862364331248, :indx 596}
 [2] {:M [0 0 1 1 0], :fire :m1-start-job,    :Mp [0 1 0 1 1], :rate 1.0, :job 1837, :clk 2173.4862364331248, :indx 597}
     {:M [0 1 0 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 1], :rate 1.0, :job 1837, :clk 2174.4862364331248, :indx 598}


{:act :m1-complete-job, :bf :b1, :j 1836, :n 0, :clk 2173.4862364331248, :line 596, :mjpact :bj, :m :m1}
{:act :m1-start-job, :j 1837, :jt :jobType1, :ends 2174.4862364331248, :clk 2173.4862364331248, :line 597, :mjpact :aj, :m :m1}
{:act :m1-complete-job, :bf :b1, :j 1837, :n 1, :clk 2174.4862364331248, :line 598, :mjpact :bj, :m :m1}

[1] "wrong-iness" because it doesn't add to the buffer??? The transition is tecnically correct! 
[2] Here it does add to the buffer. I think this is okay. To do otherwise is to invite problems.

*** Leading to definition of starved? 
So I don't see a case for [0 1 0 1 1] being m2-starved in the log at all. Buffer has 1!
Let's look at what is happening when m2 starves. Two situations, supposedly. 

[3] {:M [0 1 0 1 1], :fire :m2-complete-job,       :Mp [1 1 0 0 1], :rate 1.0, :job 1744, :clk 2066.1692850612535, :indx 224}
[4] {:act :m2-starved, :prev-act :m2-complete-job, :Mp [1 1 0 0 1], :clk 2066.1692850612535, :job 1744            :indx 225,}
    {:M [1 0 1 0 1], :fire :m1-start-job,          :Mp [1 1 0 0 2], :rate 1.0, :job 1746, :clk 2067.08452126566, :indx 227}
    {:M [1 1 0 0 2], :fire :m2-start-job,          :Mp [0 1 0 1 1], :rate 1.0, :job 1745, :clk 2067.08452126566, :indx 228}
    {:act :m2-unstarved, :prev-act :m2-start-job, :indx 229, :Mp [0 1 0 1 1], :clk 2067.08452126566, :job 1745}

     This [4] is *wrong*. There is one in the buffer. Should penalize an interpretation that matches
     a starvation to having something in the buffer. In other respects it is "continuous." 
     Either way, it doesn't explain the :m2-starved in PNN, but fix the interpretation first. 
     Really need a look-ahead at [3] to see that [4] is starve. Going to have to work backwards
     from starvations!. Also call it :state (not :Mp)

====> starved? written.

{:act :m2-complete-job, :m :m2, :j 1744, :ent 2062.4506743555485, :clk 2066.1692850612535, :line 224, :mjpact :ej}
{:act :m2-starved, :m :m2, :clk 2066.1692850612535, :line 225, :mjpact :st}
{:act :m1-complete-job, :bf :b1, :j 1745, :n 0, :clk 2067.08452126566, :line 226, :mjpact :bj, :m :m1}

{:M [0 1 0 1 1], :fire :m2-complete-job, :Mp [1 1 0 0 1], :rate 1.0, :m :m2, :job 1744, :clk 2066.1692850612535, :indx 224}
{:act :m2-starved, :prev-act :m2-complete-job, :Mp [1 1 0 0 1], :state [1 1 0 0 1], :clk 2066.1692850612535, :job 1744, :indx 225}
{:M [1 1 0 0 1], :fire :m1-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :m :m1, :job 1745, :clk 2067.08452126566, :indx 226}

This should have failed starved? 

*** Bug in MJPdes
====> I have a new (better) interpretation now, but I'm not happy with what MJPdes is doing.
It is putting :m2-start-job messages [5] before :unstarve messages, resulting in the 
wrong state on exceptional [6] . 

What sucks about this is that to fix it, I need a new log. 

{:M [1 1 0 0 1], :fire :m2-start-job, :Mp [0 1 0 1 0], :rate 1.0, :m :m2, :job 1744, :clk 2064.9992850612534, :indx 223}
{:M [0 1 0 1 0], :fire :m2-complete-job, :Mp [1 1 0 0 0], :rate 1.0, :m :m2, :job 1744, :clk 2066.1692850612535, :indx 224}
{:act :m2-starved, :prev-act :m2-complete-job, :Mp [1 1 0 0 0], :state [1 1 0 0 0], :clk 2066.1692850612535, :job 1744, :indx 225}
{:M [1 1 0 0 0], :fire :m1-complete-job, :Mp [1 0 1 0 0], :rate 1.0, :m :m1, :job 1745, :clk 2067.08452126566, :indx 226}
{:M [1 0 1 0 0], :fire :m1-start-job, :Mp [1 1 0 0 1], :rate 1.0, :m :m1, :job 1746, :clk 2067.08452126566, :indx 227}
[5] {:M [1 1 0 0 1], :fire :m2-start-job, :Mp [0 1 0 1 0], :rate 1.0, :m :m2, :job 1745, :clk 2067.08452126566, :indx 228}
[6] {:act :m2-unstarved, :prev-act :m2-start-job, :Mp [0 1 0 1 0], :state [0 1 0 1 0], :clk 2067.08452126566, :job 1745, :indx 229}
{:M [0 1 0 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0], :rate 1.0, :m :m1, :job 1746, :clk 2068.08452126566, :indx 230}

...so essentially, I have more to do. 
It may even be the case that I'll want to terminate interpretations where
unstarve is happening but the buffer is empty. 

*** Progress on winners?

Am I making progress on the winners? No. Still 10 exceptional winners, should only be 6

{[0 0 1 1 1] [:ordinary 0.09034091305554764],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09031989717406354],
 [0 1 0 1 3] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:m1-unblocked 1.0],
 [0 1 0 1 1] [:m2-unstarved 0.42228747963461166],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:m2-unstarved 0.42228747963461166],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 1.0],
 [0 1 0 1 2] [:m1-unblocked 1.0],
 [1 0 1 0 0] [:m2-starved 1.0]}

Actually, things should be MUCH better because the msg table is good: (AND THIS WITH SIGMA = 0.2 !)
{:m2-starved   {[1 1 0 0 0] 14},
 :m2-unstarved {[0 1 0 1 0] 14}, <------------------- Except that last here should be 1 not 0. 
 :m1-blocked   {[0 1 0 1 3] 30}
 :m1-unblocked {[0 0 1 1 2] 30},
 :ordinary
 {[0 0 1 1 1] 263,
  [0 1 0 1 0] 217,
  [1 1 0 0 2] 263,
  [0 1 0 1 3] 248,
  [1 1 0 0 3] 248,
  [0 1 0 1 1] 466,
  [1 1 0 0 0] 14,
  [0 0 1 1 0] 203,
  [0 0 1 1 2] 248,
  [1 1 0 0 1] 217,
  [0 1 0 1 2] 511,
  [1 0 1 0 0] 14}}

I'm going to investigate better winners before fixing MJPdes. 
*** Just two ordinary with sigma=0.5
{[0 0 1 1 1] [:ordinary 0.20215720349327004],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.18131030070691884],
 [0 1 0 1 3] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:m1-unblocked 1.0],
 [0 1 0 1 1] [:m2-unstarved 0.8711587695892686],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:m2-unstarved 0.8711587695892686],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 1.0],
 [0 1 0 1 2] [:m1-unblocked 1.0],
 [1 0 1 0 0] [:m2-starved 1.0]}

(log 1/p) gives zero

*** Surprisingly! 5 with 1/p (rather than 1/p - 1). 
 [0 0 1 1 1] [:ordinary 0.09562183669845968],

 [1 1 0 0 0] [:m2-starved 1.0],
 [1 0 1 0 0] [:m2-starved 0.1353352832366127]
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [0 0 1 1 0] [:m2-unstarved 0.11789851882642269],

 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:m1-blocked 0.1353352832366127],
 [0 0 1 1 2] [:m1-unblocked 1.0],

 [1 1 0 0 2] [:ordinary 0.09445592889074222],
 [0 1 0 1 1] [:ordinary 0.1835947938879116],
 [1 1 0 0 1] [:ordinary 0.07711819024458476],
 [0 1 0 1 2] [:ordinary 0.20171648386436794]

*** Perfect at 1/p and sigma=0.4. I'm going to live with that for a while at least.
{[0 0 1 1 1] [:ordinary 0.0903244614282773],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09031954835912448],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 3] [:ordinary 0.08549534846163118],
 [0 1 0 1 1] [:ordinary 0.1606469021025419],
 [0 0 1 1 0] [:ordinary 0.06990869038942338],
 [1 1 0 0 1] [:ordinary 0.07453835356002238],
 [0 1 0 1 2] [:ordinary 0.17616047457462952],
 [1 0 1 0 0] [:ordinary 0.0048262784622090035]}
*** I have in-lined dijkstra. I don't need these unless I want old graph-distance
#_(defn old-graph-distance-fn
  "Return a function that calculates graph distance for the PN.
   BTW, In the Parzen use of this, the first argument is a training instance and 
   the second argument is the value for which we want a score."
  [pn]
  (let [graph (-> pn :loom-graph)]
    (when-not graph (throw (ex-info "Not graph in graph-distance-fn" {}))) ; POD temporary
    (fn [from to] 
      (let [graph-distance (count (alg/dijkstra-path graph from to))]
        (* graph-distance ; POD I need to try straight graph distance ???
           (reduce (fn [sum ix] (+ sum (Math/pow (- (nth from ix) (nth to ix)) 2)))
                   0.0
                   (range (count from))))))))

** <2017-11-09 Thu>

 I didn't do much on the program OR the paper today. Instead I reviewed Liang's proposal and
 handled some odds and ends. 
** <2017-11-10 Fri>

*** starved? is established and I got all the test cases in fitness_test.clj working. 
 Internet is down.
*** I'm looking at an alternative PNN measure: product of probabilities
This would be perfect were Loom to provide all (or a reasonable subset of) paths between nodes. 
But I don't think it can do that. Checking... Nothing. 

Q: What if I got a first graph and then tried to get subgraphs? 
A: I don't think it would give me anything new unless I changed the costs. 
Q: Then why not change costs on this entire path and see what it can do? 
A: Maybe.
Q: What if I keep the path I have but recalculate the distance as a product?
A: This should be easy...

*** Quick check of a side issue
In the graph, not in the interp. 
  [1 0 1 0 3] {[0 0 1 1 2] 99999.99999999999},    

It is in the graph:
[:place-1 :place-2 :place-3 :place-4 :Place-103]
 {:M [1 0 1 0 3], :fire :m2-start-job, :Mp [0 0 1 1 2], :rate 1.0}
It could be that this never happens because 1 0 1 0 3 is both machines waiting. 
Yup. Not in the log. 

[[[[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/Screen Shot 2017-11-10 at 11.46.55 AM.jpg]]][PN]]
 
Baseline with sigma=0.75 --> 4 ordinary. 
  (count (filter #(= :ordinary (first %)) (-> (tryme) vals)))

*** exper-dist-fn-1 and -2 suck
(defn exper-dist-fn-1
  "Measure distance as the product of probability along the 1/p path." 
  [rgraph trans-cnts from to]
  (let [loom-prob (rgraph2loom-probability rgraph trans-cnts)
        path (alg/dijkstra-path loom-prob from to)
        adj-table (:adj loom-prob)]
    (reduce (fn [probs ix]
              (let [f (nth path ix)
                    t (nth path (inc ix))]
                (* probs (/ 1 (get (get adj-table f) t)))))
            1
            (range (-> path count dec)))))

(defn exper-dist-fn-2
  [rgraph trans-cnts from to]
  "Measure distance as the product of probability along a '1 per step' cost path." 
  (let [loom-steps (rgraph2loom-steps rgraph)
        path (alg/dijkstra-path loom-steps from to)]
    (reduce (fn [probs ix]
              (let [f (nth path ix)
                    t (nth path (inc ix))]
                (* probs (trans-prob f t trans-cnts))))
            1
            (range (-> path count dec)))))

(defn tryme
  []
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        pn (as-> (find-interpretation hopeful-pn log) ?pn
             (assoc  ?pn :msg-table (compute-msg-table ?pn)) 
             (assoc  ?pn :trans-counts (trans-counts (:interp ?pn)))
             (dissoc ?pn :interp)
             (assoc  ?pn :sigma 0.40)
             (assoc  ?pn :loom-prob (rgraph2loom-probability (:rgraph ?pn) (:trans-counts ?pn)))
             (assoc  ?pn :distance-fn #(second (alg/dijkstra-path-dist (:loom-prob ?pn) %1 %2)))
             #_(assoc  ?pn :distance-fn #(exper-dist-fn-1 (:rgraph ?pn) (:trans-counts ?pn) %1 %2))
             (assoc  ?pn :pdf-fns
                     (zipmap (-> ?pn :msg-table keys)
                             (map #(fit/parzen-pdf-msg ?pn %)
                                  (-> ?pn :msg-table keys))))
             (assoc ?pn :winners (choose-winners ?pn)))]
    pn))

Terrible:
{[0 0 1 1 1] [:m1-unblocked 0.7724426022951624],
 [0 1 0 1 0] [:m1-unblocked 0.8193096491007966],
 [1 1 0 0 2] [:m2-unstarved 0.7854176486427293],
 [0 1 0 1 3] [:m2-unstarved 0.7963124543204168],
 [1 1 0 0 3] [:m2-unstarved 0.7963124543204168],
 [0 1 0 1 1] [:m1-unblocked 0.6328696774369557],
 [1 1 0 0 0] [:m1-unblocked 0.9872246813101748],
 [0 0 1 1 0] [:m1-unblocked 0.8299120398949777],
 [0 0 1 1 2] [:m2-unstarved 0.7963124543204168],
 [1 1 0 0 1] [:m1-unblocked 0.8193096491007966],
 [0 1 0 1 2] [:m2-unstarved 0.6254378554572626],
 [1 0 1 0 0] [:m1-unblocked 0.9872246813101748]}

*** Better than all of these was simple distance???

Yeah, but since I cannot explain why that would be, I'm going to ignore it! 
And BTW, what I mean by simple distance is steps*euclidean distance. 
I'm going with 1/p and sigma=0.4. 

Maybe I should review euclidean distance times steps. See if the I can get
back to the values (of a few weeks ago!) and maybe normalize it and claim success. 

*** steps * euclid-dist2 at sigma=0.75 still really good. 

{[0 0 1 1 1] [:ordinary 0.10565451941946982],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.10642989332503937],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.09387730377891053],
 [0 1 0 1 1] [:ordinary 0.1783054552497219],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.07812345592321546],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:ordinary 0.08572916833008677],
 [0 1 0 1 2] [:ordinary 0.1935079893754819],
 [1 0 1 0 0] [:m2-starved 0.028565500784550373]}

What would it be like with the markings normalized. 
(That just means dividing the last component by 3)

*** Normalized not nearly as good (at sigma=0.75). Damn! 
{[0 0 1 1 1] [:m1-unblocked 0.7435670792059064],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.21486867525000083],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.1651985882002166],
 [0 1 0 1 1] [:m2-unstarved 0.7435670792059064],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.15090367155243273],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.7435670792059064],
 [0 1 0 1 2] [:m1-blocked 0.7435670792059063],
 [1 0 1 0 0] [:m2-starved 0.028565500784550373]}

Sigma=0.4 not much help.
{[0 0 1 1 1] [:m1-unblocked 0.352866081458849],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.14666831313900044],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.11710641702346947],
 [0 1 0 1 1] [:m2-unstarved 0.35286608145884896],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.1016633427504141],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.35286608145884896],
 [0 1 0 1 2] [:m1-blocked 0.35286608145884896],
 [1 0 1 0 0] [:ordinary 0.00480797001559086]}

*** This all means that 1/p wins. Which I guess is a good thing, except...
Except that it only works on integer values. 
Q: How would it do with an added normalized Euclidean factor?

Baseline (simple 1/p) at sigma=0.4,  exper-dist-fn-5
{[0 0 1 1 1] [:ordinary 0.09097436581837509],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09073903307292706],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.08907167734269653],
 [0 1 0 1 1] [:ordinary 0.16719825182833473],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.07246741235005642],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:ordinary 0.0748679045133488],
 [0 1 0 1 2] [:ordinary 0.18339141280578564],
 [1 0 1 0 0] [:m2-starved 0.04393693362340743]} <---- wrong!

A: at sigma=0.25 Actually, a little better! exper-dist-fn-6
{[0 0 1 1 1] [:ordinary 0.0963382250561357],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09661490913580296],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.08525038465184905],
 [0 1 0 1 1] [:ordinary 0.1847004189542513],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.06976761268904322],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.1690133154060661], <--- different
 [0 1 0 1 2] [:ordinary 0.20349378870019016],
 [1 0 1 0 0] [:ordinary 0.004807692848726801]} <--- right

{:m2-unstarved {[0 1 0 1 0] 14},
 :m1-unblocked {[0 0 1 1 2] 30},
 :m2-starved {[1 1 0 0 0] 14},
 :ordinary
 {[0 0 1 1 1] 263,
  [0 1 0 1 0] 217,
  [1 1 0 0 2] 263,
  [0 1 0 1 3] 248,
  [1 1 0 0 3] 248,
  [0 1 0 1 1] 466,
  [1 1 0 0 0] 14,
  [0 0 1 1 0] 203,
  [0 0 1 1 2] 248,
  [1 1 0 0 1] 217,
  [0 1 0 1 2] 511,
  [1 0 1 0 0] 14},
 :m1-blocked {[0 1 0 1 3] 30}}

A: sigma=0.4 Not as good. (sigh) exper-dist-fn-6
{[0 0 1 1 1] [:ordinary 0.1227915012397023],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.1259642872042334],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.09128145042037937],
 [0 1 0 1 1] [:m2-unstarved 0.4875361660153877], <-- wrong
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.07485193189373177],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.4993517885992762],   <--- wrong
 [0 1 0 1 2] [:m1-blocked 0.4993517885992762],   <--- wrong
 [1 0 1 0 0] [:ordinary 0.004816973337193402]}

*** MJPdes was doing things correctly -- I was using old output.
The new one [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out-2.clj][new file]] is *much* easier to read.  Oh, but it doesn't work. 
It fails interpretation. 

*** bad start, it IS a tree search
;;; POD better than keeping these long paths would just be to count them.
(defn starting-links
  "Return all links (containing reference scada log line) that interpret 
   the SCADA log well from start-indx (usually 0)."
  [pn log start-indx & {:keys [diag-path]}]
  (let [rgraph (:rgraph pn)
        starts  (filter #(= (:act (next-ordinary pn log start-indx))
                            (:fire %))
                        rgraph)]
    (reduce (fn [winners start]
              (let [win? (loop [next-link start
                                cnt 0]
                           (cond (> cnt 0) start
                                 (not next-link) nil
                                 true (recur 
    



It dies here
matched =  {:M [0 1 0 1 1], :fire :m2-move-off, :Mp [1 1 0 0 1], :rate 1.0, :m :m2, :job 1723, :clk 2053.4484, :indx 182}
{:clk 2053.4484 :act :m2-move-off :m :m2 :ent 2049.6847 :mjpact :ej :j 1723 :line 182}
{:clk 2053.4484 :act :m2-starved :m :m2 :mjpact :st :line 183}
{:clk 2053.7211 :act :m2-unstarved :m :m2 :mjpact :us :line 184}
Which happens to be the first starvation!

llink, msg. 
{:M [0 1 0 1 1], :fire :m2-move-off, :Mp [1 1 0 0 1], :rate 1.0, :m :m2, :job 1723, :clk 2053.4484, :indx 182}
{:clk 2053.4484, :act :m2-starved, :m :m2, :mjpact :st, :line 183}

:place-1 = m2 waiting
:place-2 = m1 busy
:place-3 = m1 waiting
:place-4 = m2 busy

[:place-1 :place-2 :place-3 :place-4 :Place-103]
It fails on starved? because indeed the :Mp here isn't starved. 

So we go from (m1-busy, m2-busy, 1 in buffer) to (m1-busy m2-waiting) but there is still one in the 
buffer, so yeah, this is supposed to fail. 

This isn't the winning initial-marking. Do I try other buffer settings? 
It should start with 1 in buffer because:
{:clk 1999.6284 :act :m2-move-off :m :m2 :ent 1996.918 :mjpact :ej :j 1677 :line 0}
{:clk 1999.6284 :act :m2-start-job :m :m2 :bf :b1 :n 1 :mjpact :sm :j 1678 :line 1}
{:clk 2000.0641 :act :m1-move-off :m :m1 :bf :b1 :n 0 :mjpact :bj :j 1679 :line 2}

*** MJPdes log problem
IT IS starting with one in the buffer. What gives? .... Wait there are lots of starts here. I might not be synched-up. 
matched =  {:M [1 1 0 0 1], :fire :m2-start-job, :Mp [0 1 0 1 0], :rate 1.0, :m :m2, :job 1678, :clk 1999.6284, :indx 1}
matched =  {:M [0 1 0 1 0], :fire :m1-move-off, :Mp [0 0 1 1 0], :rate 1.0, :m :m1, :job 1679, :clk 2000.0641, :indx 2}
matched =  {:M [0 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 1], :rate 1.0, :m :m1, :job 1680, :clk 2000.0641, :indx 3}

;;; Okay, The log looks like it is messed up. Goes from m2-starved to m2-unstarved without anything between!
matched =  {:M [0 1 0 1 0], :fire :m2-move-off, :Mp [1 1 0 0 0], :rate 1.0, :m :m2, :job 1723, :clk 2053.4484, :indx 182}
matched =  {:act :m2-starved, :prev-act :m2-move-off, :Mp [1 1 0 0 0], :state [1 1 0 0 0], :clk 2053.4484, :job 1723, :indx 183}
matched =  {:act :m2-unstarved, :prev-act nil, :Mp [1 1 0 0 0], :state [1 1 0 0 0], :clk 2053.7211, :job 1723, :indx 184}

Yup. Log problem:
{:clk 2053.4484 :act :m2-starved :m :m2 :mjpact :st :line 183}

[4] {:clk 2053.7211 :act :m2-unstarved :m :m2 :mjpact :us :line 184}
[3] {:clk 2053.7211 :act :m2-start-job :m :m2 :bf :b1 :n 1 :mjpact :sm :j 1724 :line 185}
[1] {:clk 2053.7211 :act :m1-move-off :m :m1 :bf :b1 :n 0 :mjpact :bj :j 1724 :line 186}
[2] {:clk 2053.7211 :act :m1-start-job :jt :jobType1 :m :m1 :ends 2054.7211 :mjpact :aj :j 1725 :line 187}

 [1] has to be before [3] and [4] Is the upstream? thing not working? 

These four together makes a great test!

*** Man! What a bear!
(defn msg-before?
  "Returns true if msg1 should be reported before msg2."
  [model msg1 msg2]
  (let [ep1 (or (:m msg1) (:bf msg1))
        ep2 (or (:m msg2) (:bf msg2)) ; model below for easier testing.
        up? (and model ep1 ep2 (upstream? model ep1 ep2))
        same? (= ep1 ep2)
        down? (and (not up?) (not same?))
        act1 (:mjpact msg1)
        act2 (:mjpact msg2)
        clk1 (:clk msg1)
        clk2 (:clk msg2)]
    (cond (and clk1 clk2 (< clk1 clk2)) true, 
          (and clk1 clk2 (> clk1 clk2)) false,

          ;; Do downtream stuff before unblocking.
          (and down? (or (= act1 :ej) (= act1 :sm)) (= act2 :ub)) true,
          (and down? (or (= act2 :ej) (= act2 :sm)) (= act1 :ub)) false,
          ;; Do upstream stuff before unstarving.
          (and up?   (or (= act1 :bj) (= act1 :aj)) (= act2 :us)) true,
          (and up?   (or (= act2 :bj) (= act2 :aj)) (= act1 :us)) false,
          ;; If neither of them are exceptional, do upstream first
          (and up?   (not (exception? act1)) (not (exception? act2))) true,
          (and down? (not (exception? act1)) (not (exception? act2))) false,
          ;; unblock before starting
          (and same? (= act1 :ub) (or (= act2 :sm) (= act2 :aj))) true,
          ;; unstarve before starting
          (and same? (= act1 :us) (= act2 :sm)) true,
          :else false)))

*** This works for blocking but not starvation:

(defn msg-before?
  "Returns true if msg1 should be reported before msg2."
  [model msg1 msg2]
  (let [ep1 (or (:m msg1) (:bf msg1))
        ep2 (or (:m msg2) (:bf msg2)) ; model below for easier testing.
        up? (and model ep1 ep2 (upstream? model ep1 ep2))
        same? (= ep1 ep2)
        down? (and (not up?) (not same?))
        act1 (:mjpact msg1)
        act2 (:mjpact msg2)
        clk1 (:clk msg1)
        clk2 (:clk msg2)]
    (cond (< clk1 clk2) true, 
          (> clk1 clk2) false,
          ;; Do downtream before unblocking.
          (and down? (or (= act1 :ej) (= act1 :sm)) (= act2 :ub)) true,
          (and   up? (or (= act2 :ej) (= act2 :sm)) (= act1 :ub)) false,
          ;; Do upstream before unstarving.
          (and up?   (or (= act1 :bj) (= act1 :aj)) (= act2 :us)) true,
          ;; If neither of them are exceptional, do downstream first
          ;; POD I wonder if this is going to be different for starvation?!?!
          (and down? (not (exception? act1)) (not (exception? act2))) true,
          (and   up? (not (exception? act1)) (not (exception? act2))) false,
          ;; unblock before starting or moving off 
          (and same? (= act1 :ub) (or (= act2 :sm) (= act2 :aj) (= act2 :bj))) true,
          ;; unstarve before starting 
          (and same? (= act1 :us) (= act2 :sm)) true,
          ;; move-off before starting
          (and same? (= act1 :bj) (or (= act2 :sm) (= act2 :aj))) true,
          :else false)))

Maybe it would be work to move the "if neither is exceptional" to the bottom.

I left things for the evening with the following not true: 

(=
   [{:clk 2053.7211, :act :m1-move-off, :m :m1, :bf :b1, :n 0, :mjpact :bj, :j 1724, :line 186}
    {:clk 2053.7211, :act :m1-start-job, :jt :jobType1, :m :m1, :ends 2054.7211, :mjpact :aj, :j 1725, :line 187}
    {:clk 2053.7211, :act :m2-unstarved, :m :m2, :mjpact :us, :line 184}
    {:clk 2053.7211, :act :m2-start-job, :m :m2, :bf :b1, :n 1, :mjpact :sm, :j 1724, :line 185}]
    (vec (sort
      #(log/msg-before? test-model %1 %2)
        [{:clk 2053.7211 :act :m2-unstarved :m :m2 :mjpact :us :line 184}
	{:clk 2053.7211 :act :m2-start-job :m :m2 :bf :b1 :n 1 :mjpact :sm :j 1724 :line 185}
	{:clk 2053.7211 :act :m1-move-off :m :m1 :bf :b1 :n 0 :mjpact :bj :j 1724 :line 186}
	{:clk 2053.7211 :act :m1-start-job :jt :jobType1 :m :m1 :ends 2054.7211 :mjpact :aj :j 1725 :line 187}]))))))
** <2017-11-11 Sat>
*** I played around a bit with utils4pmap and eventually gave up.
  See comments in the code. Contrary to what I had believed before, it *does not* pass the
  busy-fn test. That, at least, is a positive, since I can now test it without sinet. 
  Further, I have a diagnostic atom on the memberes that shows that, in the case of busy-fn, 
  the catch for interrupts never gets invoked. 
  The only way forward is to find a way to get the interrupt handled by run-away code. 
*** My writing goal for today is to get yesterday's pnn stuff written. 
  Then back to ordering messages in MJPdes. 
I'm using exper-dist-fn-6
****  The problem remains that these results really do suck! :
           {[0 0 1 1 1] [:ordinary 0.0963382250561357],
            [0 1 0 1 0] [:m2-unstarved 1.0],
            [1 1 0 0 2] [:ordinary 0.09661490913580298],
            [0 1 0 1 3] [:m1-blocked 1.0],
            [1 1 0 0 3] [:ordinary 0.08525038465184905],
            [0 1 0 1 1] [:ordinary 0.1847004189542513],
            [1 1 0 0 0] [:m2-starved 1.0],
            [0 0 1 1 0] [:ordinary 0.06976761268904322],
            [0 0 1 1 2] [:m1-unblocked 1.0],
            [1 1 0 0 1] [:m2-starved 0.1690133154060661],
            [0 1 0 1 2] [:ordinary 0.20349378870019016],
            [1 0 1 0 0] [:ordinary 0.004807692848726801]}
The ordinary are all miniscule and the exceptional are all 1.0. Anything broader than
sigma=0.25 wanders away from the correct answers. 

I'm lost neither changing msg-table nor trans-cnts causes a difference in winners.
 [1 1 0 0 1] [:m2-starved 0.16901331540606607],
 [1 1 0 0 1] [:m2-starved 0.1690133154060661],  (Maybe just rounding???)

**** Something is wrong? Values don't matter.
Values for msg-table and trans-cnt for 1 1 0 0 1 / :m2-starved between 1 and 1000 don't change the result!

((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1]) ===> 0.1690133154060661
((:ordinary   (:pdf-fns pnpn)) [1 1 0 0 1]) ===> 0.08015732928344184

***** I could see where the values wouldn't matter were there no alternative labels for the marking. 
However, there is an alternative:

{:m2-starved {[1 1 0 0 0] 1001},
 :m2-unstarved {[0 1 0 1 0] 14},
 :m1-blocked {[0 1 0 1 3] 30},
 :m1-unblocked {[0 0 1 1 2] 30},
 :ordinary
 {[0 0 1 1 1] 263,
  [0 1 0 1 0] 217,
  [1 1 0 0 2] 263,
  [0 1 0 1 3] 248, <===== This is marking for blocked. I think it is moving out of it during the same clock tick???
  [1 1 0 0 3] 248,
  [0 1 0 1 1] 466,
  [1 1 0 0 0] 14,  <===== Alternative
  [0 0 1 1 0] 203,
  [0 0 1 1 2] 248,
  [1 1 0 0 1] 217,
  [0 1 0 1 2] 511,
  [1 0 1 0 0] 14}}

{[0 0 1 1 1] {[0 1 0 1 2] 263},
 [0 1 0 1 0] {[0 0 1 1 0] 203, [1 1 0 0 0] 1020},
 [1 1 0 0 2] {[0 1 0 1 1] 263},
 [0 1 0 1 3] {[1 1 0 0 3] 248},
 [1 1 0 0 3] {[0 1 0 1 2] 248},
 [0 1 0 1 1] {[1 1 0 0 1] 203, [0 0 1 1 1] 263},
 [1 1 0 0 0] {[1 0 1 0 0] 14},
 [0 0 1 1 0] {[0 1 0 1 1] 203},
 [0 0 1 1 2] {[0 1 0 1 3] 248},
 [1 1 0 0 1] {[0 1 0 1 0] 217},
 [0 1 0 1 2] {[1 1 0 0 2] 263, [0 0 1 1 2] 248},
 [1 0 1 0 0] {[1 1 0 0 1] 14}}

***** It uses the data associated with the label, as you'd expect. 

((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1])
 mark =  [1 1 0 0 0]  cnt =  1001  x =  [1 1 0 0 1] <--- Meaning that the data on :m2-starved I have is 1001 points at [1 1 0 0 0]
0.1690133154060661

((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1])
 mark =  [1 1 0 0 0]  cnt =  1001  x =  [1 1 0 0 1]  dist =  0.22222 <--- 1001 points at [1 1 0 0 0], but [1 1 0 0 0] is close.
0.1690133154060661

It must be that the distance is small. 

Likewise for :ordinary. There are 12 data points for ordinary. 
((:ordinary (:pdf-fns pnpn)) [1 1 0 0 1])
((:ordinary (:pdf-fns pnpn)) [1 1 0 0 1])
 mark =  [0 0 1 1 1]  cnt =  263  x =  [1 1 0 0 1]  dist =  24.95412912772294
 mark =  [0 1 0 1 0]  cnt =  217  x =  [1 1 0 0 1]  dist =  6.753485838779957
 mark =  [1 1 0 0 2]  cnt =  263  x =  [1 1 0 0 1]  dist =  0.36617405582922824
 mark =  [0 1 0 1 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  17.694190022497352
 mark =  [1 1 0 0 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  2.772681014191438
 mark =  [0 1 0 1 1]  cnt =  466  x =  [1 1 0 0 1]  dist =  4.5911330049261085
 mark =  [1 1 0 0 0]  cnt =  14   x =  [1 1 0 0 1]  dist =  0.2222222222222222 <--- Again. Good.
 mark =  [0 0 1 1 0]  cnt =  203  x =  [1 1 0 0 1]  dist =  13.548440065681444
 mark =  [0 0 1 1 2]  cnt =  248  x =  [1 1 0 0 1]  dist =  33.86952160349301
 mark =  [1 1 0 0 1]  cnt =  217  x =  [1 1 0 0 1]  dist =  0.0
 mark =  [0 1 0 1 2]  cnt =  511  x =  [1 1 0 0 1]  dist =  11.059123706298218
 mark =  [1 0 1 0 0]  cnt =  14   x =  [1 1 0 0 1]  dist =  2.111111111111111

**** The original question: A: Because there is only one value ???
((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1])
 mark =  [1 1 0 0 0]  cnt =  1001  x =  [1 1 0 0 1] <--- Meaning that the data on :m2-starved I have is 1001 points at [1 1 0 0 0]
0.1690133154060661

A: --> It sums 1001 of these and then divides by 1001. 

**** Next question: But does the change to :original counts matter? 
---> Switching to 1020 gave a difference distance for something (verify)

 mark =  [0 0 1 1 1]  cnt =  263  x =  [1 1 0 0 1]  dist =  24.95412912772294
 mark =  [0 1 0 1 0]  cnt =  217  x =  [1 1 0 0 1]  dist =  9.21401204159825    <---- changed as expected.
 mark =  [1 1 0 0 2]  cnt =  263  x =  [1 1 0 0 1]  dist =  0.36617405582922824
 mark =  [0 1 0 1 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  17.694190022497352
 mark =  [1 1 0 0 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  2.772681014191438
 mark =  [0 1 0 1 1]  cnt =  466  x =  [1 1 0 0 1]  dist =  4.5911330049261085
 mark =  [1 1 0 0 0]  cnt =  14   x =  [1 1 0 0 1]  dist =  0.2222222222222222
 mark =  [0 0 1 1 0]  cnt =  203  x =  [1 1 0 0 1]  dist =  13.548440065681444
 mark =  [0 0 1 1 2]  cnt =  248  x =  [1 1 0 0 1]  dist =  33.86952160349301
 mark =  [1 1 0 0 1]  cnt =  217  x =  [1 1 0 0 1]  dist =  0.0                 <------ e^0 --- it is e^(-distance)
 mark =  [0 1 0 1 2]  cnt =  511  x =  [1 1 0 0 1]  dist =  11.059123706298218
 mark =  [1 0 1 0 0]  cnt =  14   x =  [1 1 0 0 1]  dist =  2.111111111111111

I changed the distance from [0 1 0 1 0] to [1 1 0 0 1] Correct?
Correct. In the latter output, I commented out this line, which should have increased the distance:
(assoc-in ?pn [:trans-counts [0 1 0 1 0] [1 1 0 0 0]] 1020)
Correct. Distance went from 6.75 to 9.21. 
(Math/exp -9.2)   ==> 0.00010103940183709342
(Math/exp -6.75)  ==> 0.0011708796207911744
So the transition is 10 times more significant at 6.76 than 9.2. 
The problem is that these aren't very significant relative to 1.0 at distance 0. 

This should have made the score for :original better. Did it? 
Without 1020: 0.08015732928344184
With    1020: 0.08015732928344184
With/ou 1001: 0.08015732928344184

Okay, maybe that doesn't make sense. 
There is enough information above to calculate the values deliberately and see what we get. 

***** Back to the point (again): It works as intended. What about it could be improved?

Here is why it doesn't make any difference:
term =  2.046191895297324E-62
term =  2.5611416543021165E-45
term =  217.0

0.083432 with Sqrt
0.083430

((:ordinary   (:pdf-fns pnpn)) [1 1 0 0 1]) ==> 0.09338080837745166
((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1]) ==> 0.26359713811572677

Why would sqrt make the difference larger?

((:ordinary (:pdf-fns pnpn)) [1 1 0 0 1])   ==> 0.07534353911645686
((:m2-starved (:pdf-fns pnpn)) [1 1 0 0 1]) ==> 0.02302358470854968

***** With sqrt, :ordinary wins!
Extra values stil don't matter. 

Here are values with sqrt:
{[0 0 1 1 1] [:ordinary 0.0911902348920777],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09123773910722094],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.0852177124857642],
 [0 1 0 1 1] [:ordinary 0.1634472113464046],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.06975363285687722],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:ordinary 0.07534353911645686],
 [0 1 0 1 2] [:ordinary 0.17933195862071463],
 [1 0 1 0 0] [:ordinary 0.00480775098301599]}

sigma=0.4 sucks:
{[0 0 1 1 1] [:ordinary 0.1078079178518772],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.1090513700432496],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.09122078912256719],
 [0 1 0 1 1] [:m2-unstarved 0.2235047042298315],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.0750987408784251],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:m2-starved 0.22920485145201186],
 [0 1 0 1 2] [:m1-blocked 0.22920485145201186],
 [1 0 1 0 0] [:m2-starved 0.012041245682929913]}

Sigma=0.3 is good
{[0 0 1 1 1] [:ordinary 0.09401147855597124],
 [0 1 0 1 0] [:m2-unstarved 1.0],
 [1 1 0 0 2] [:ordinary 0.09429688963376698],
 [0 1 0 1 3] [:m1-blocked 1.0],
 [1 1 0 0 3] [:ordinary 0.08570542928116535],
 [0 1 0 1 1] [:ordinary 0.17261382865151273],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.0701684527692359],
 [0 0 1 1 2] [:m1-unblocked 1.0],
 [1 1 0 0 1] [:ordinary 0.07801191238010818],
 [0 1 0 1 2] [:ordinary 0.18909594090862963],
 [1 0 1 0 0] [:ordinary 0.004809553524488202]}



Something is still screwed up in that these aren't the values I get by running by-hand. 
And the stuff above was contradictory at times. 

***** (But why aren't the numbers as expected?)
((:ordinary (:pdf-fns pnpn)) [1 1 0 0 1])
sigma =  0.3
 mark =  [0 0 1 1 1]  cnt =  263  x =  [1 1 0 0 1]  dist =  24.95412912772294
 mark =  [0 1 0 1 0]  cnt =  217  x =  [1 1 0 0 1]  dist =  9.21401204159825
 mark =  [1 1 0 0 2]  cnt =  263  x =  [1 1 0 0 1]  dist =  0.36617405582922824
 mark =  [0 1 0 1 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  17.694190022497352
 mark =  [1 1 0 0 3]  cnt =  248  x =  [1 1 0 0 1]  dist =  2.772681014191438
 mark =  [0 1 0 1 1]  cnt =  466  x =  [1 1 0 0 1]  dist =  4.5911330049261085
 mark =  [1 1 0 0 0]  cnt =  14  x =  [1 1 0 0 1]  dist =  0.2222222222222222
 mark =  [0 0 1 1 0]  cnt =  203  x =  [1 1 0 0 1]  dist =  13.548440065681444
 mark =  [0 0 1 1 2]  cnt =  248  x =  [1 1 0 0 1]  dist =  33.86952160349301
 mark =  [1 1 0 0 1]  cnt =  217  x =  [1 1 0 0 1]  dist =  0.0
 mark =  [0 1 0 1 2]  cnt =  511  x =  [1 1 0 0 1]  dist =  11.059123706298218
 mark =  [1 0 1 0 0]  cnt =  14  x =  [1 1 0 0 1]  dist =  2.111111111111111
0.07801191238010818
0.07801191238010818
0.07465334847815873

All the summands are different. 
sum =  2.0636196635986696E-22
sum =  2.3296608584222083E-10
****** Total waste of time. (* 2.0 sigma sigma)
(defn by-hand [data]
  (let [size (apply + (map first data))
        sig2 (* 2 0.30 0.30)]
    (println "size = " size)
    (* (/ 1 size)
       (reduce (fn [sum [cnt dist]]
                 (println "term = "     (* cnt (Math/exp (- (/ (Math/sqrt dist) sig2)))))
                 (println "dist = " dist " cnt = " cnt)
                 ;(println "sum = " (+ sum (* cnt (Math/exp (- (/ (Math/sqrt dist) sig2))))))
                 (+ sum (* cnt (Math/exp (- (/ (Math/sqrt dist) sig2))))))
               0.0
               data))))


(def data-3 [[263    24.95412912772294]
             [217    9.21401204159825]
             [263    0.36617405582922824]
             [248    17.694190022497352]
             [248    2.772681014191438]
             [466    4.5911330049261085]
             [14     0.2222222222222222]
             [203    13.548440065681444]
             [248    33.86952160349301]
             [217    0.0]
             [511    11.059123706298218]
             [14     2.111111111111111]])

(def data-1
  [[217    9.21401204159825]    
   [263    24.95412912772294]
   [263    0.36617405582922824]
   [248    17.694190022497352]
   [248    2.772681014191438]
   [466    4.5911330049261085]
   [14     0.2222222222222222]
   [203    13.548440065681444]
   [248    33.86952160349301]
   [217    0.0              ]   
   [511    11.059123706298218]
   [14     2.111111111111111]])

(def data-2
  [[217    6.753485838779957]    ;;----
   [263    24.95412912772294]
   [263    0.36617405582922824]
   [248    17.694190022497352]
   [248    2.772681014191438]
   [466    4.5911330049261085]
   [14     0.2222222222222222]
   [203    13.548440065681444]
   [248    33.86952160349301]
   [217    0.0              ]   
   [511    11.059123706298218]
   [14     2.111111111111111]])



**** Results are good with  sigma=0.3 and sqrt on fn-6. Some of the others? 

*** I'm back on the problem with MJPdes ordering of data.
1) Fix this
2) Generate a good log
3) Redo all the tests
4) Check alternative formulations for pnn function. 
5) Write it down. 

(=
   [{:clk 2053.7211, :act :m1-move-off, :m :m1, :bf :b1, :n 0, :mjpact :bj, :j 1724, :line 186}
    {:clk 2053.7211, :act :m1-start-job, :jt :jobType1, :m :m1, :ends 2054.7211, :mjpact :aj, :j 1725, :line 187}
    {:clk 2053.7211, :act :m2-unstarved, :m :m2, :mjpact :us, :line 184}
    {:clk 2053.7211, :act :m2-start-job, :m :m2, :bf :b1, :n 1, :mjpact :sm, :j 1724, :line 185}]
    (vec (sort
      #(log/msg-before? test-model %1 %2)
        [{:clk 2053.7211 :act :m2-unstarved :m :m2 :mjpact :us :line 184}
	 {:clk 2053.7211 :act :m2-start-job :m :m2 :bf :b1 :n 1 :mjpact :sm :j 1724 :line 185}
	 {:clk 2053.7211 :act :m1-move-off :m :m1 :bf :b1 :n 0 :mjpact :bj :j 1724 :line 186}
	 {:clk 2053.7211 :act :m1-start-job :jt :jobType1 :m :m1 :ends 2054.7211 :mjpact :aj :j 1725 :line 187}]))))))

This can't be write because if I swap them around, this test will pass and the other will fail. 
          ;; If neither of them are exceptional, do downstream first
          (and down? (not (exception? act1)) (not (exception? act2))) true,
          (and   up? (not (exception? act1)) (not (exception? act2))) false,

The problem is that I'm only looking at two at a time ???

---> Once you've got things working correctly, write "mix-up" (use all permutations)

** <2017-11-12 Sun>

I'm starting on (2) from yesterday. The new data is processed without a hitch. The results are perfect:
{[0 0 1 1 1] [:ordinary 0.06992850508397208],
 [0 1 0 1 0] [:ordinary 0.08482974339879687],
 [1 1 0 0 2] [:ordinary 0.0695792210954763],
 [0 1 0 1 3] [:m1-blocked 1.0000000000000002],
 [1 1 0 0 3] [:ordinary 0.0972743434925606],
 [0 1 0 1 1] [:ordinary 0.14409909278949354],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.07206595066999992],
 [0 0 1 1 2] [:ordinary 0.09880343751757752],
 [1 1 0 0 1] [:m2-unstarved 1.0],
 [0 1 0 1 2] [:m1-unblocked 1.0000000000000002],
 [1 0 1 0 0] [:ordinary 0.01135570991588166]}

Now on to (3). I'll update the tests with this, try a few of the others, etc. 

I've done all the work I can on -4. It is not going to win!

*** This one is probably goofed up. 
(defn dist-fn-4 ; This one is not continuous. ; <=========================  POD add euclid-dist to this one
  [loom-steps trans-cnts] ; This one is not continuous.
  "Distance = product of probability along a '1 per step' (i.e. shortest) cost path."
  (fn [x y]
    (let [path (alg/dijkstra-path loom-steps x y)]
      (reduce (fn [probs ix]
                (let [f (nth path ix)
                      t (nth path (inc ix))]
                  (* probs (trans-prob f t trans-cnts)))) ; POD needs work?
              1
              (range (-> path count dec))))))


I'm on "(5) Write it down."

** <2017-11-13 Mon>
  I worked on the JMS paper, adding the PNN results. 
** <2017-11-14 Tue>
  I worked on the JMS paper, adding the interpretation algorithm.
** <2017-11-15 Wed>
  In the meeting with Charles we decided to work on the causal piece, with a goal
  of having that complete (and in the paper, if possible) in a week. 
  I might then go back and add more algorithms to the PNN table. 

The "causal piece" involves lot of work on spntools, but I'm going to document that here. 

OK, so I put :rate-fn in :next-links. I have not yet traced through how these functions
would be used in the process of tangible rates. But let's give what we have a try, 
and see if it generates the same values as in the test case. (I think it won't because
there was some math in composing the tangible rates that isn't yet expressed ???

(Actually the example has no :IMMs so it isn't going to matter.) 

  {:M [1 0 0 1 1 0 0],
   :fire :Treq1,
   :Mp [0 1 0 1 1 0 0],
   :rate-fn (clojure.core/fn [gov.nist.spntools.util.reach/rates] (:Treq1 gov.nist.spntools.util.reach/rates)),
   :rate 1.0}
  {:M [0 1 0 1 1 0 0],
   :fire :Treq2,
   :Mp [0 1 0 1 0 1 0],
   :rate-fn (clojure.core/fn [gov.nist.spntools.util.reach/rates] (:Treq2 gov.nist.spntools.util.reach/rates)),
   :rate 2.0}

NICE!
((-> foo :M2Mp first :rate-fn) {:Treq1 5.0})

** <2017-11-16 Thu>

*** Comments I don't need
OK, not much time invested, but let's finish this thing!

      ;; Every link in M2Mp provides a rate between *states*. Can I trace from the rate of
      ;; a transition to rates of these states? Is this essentially just going through the
      ;; reachability graph with new values or is there something I can do here that is
      ;; more effective? When I was working on this code, I seemed to believe that the Q-matrix
      ;; code was an appropriate place to make this parametric. Looking at Marsan....

      ;; The transition rate from state si (corresponding to marking Mi) to state sj (Mj) is obtained
      ;; as the sum of the firing rates of the transitions that are enabled in Mi and whose firings
      ;; generate marking Mj.

      ;;; That means sum rates of all transitions that have

      ;; That's great, except that I'm starting from the premise that I'm changing one of the lambdas.
      ;; I need an algebraic associated with the transition. Have to be careful about this because
      ;; it is a function of reachability. 


Oh man, a little more involved that I thought!
Might have to keep around links that aren't directly used. ...Or some such thing. 

**** In principle, it should not be necessary to keep around links other than those that actually appear in the PN. 
     For example, in calc-vpath-rate I define :vrate-fn, which multiplies a path of rates. 
***** Note that it looks necessary to keep around these for cycles:
          - :Qt-states
          - :Qtv-states
          .... Nope, that's not a good idea! Need to use a closure in these cases! 
               (because these properties are for each loop) .

** <2017-11-17 Fri>

I fixed a problem with vanish-matrices that I caused yesterday: I seemed to forget that 
the function returns the whole ?calc object and that might need some of these additional
keys! It needed :Qt-states. 

*** Okay, I'm not going to pursue loops past Grace's appointment, but while I'm here....
**** Firstly, I might *have* to pursue this a little further, might not be just about loops! (Verify.)
 - vanish-matrices produces :loop-rates and :lv-St, which is further wrapped up in the caller, loop-reduce-vpath.
 - loop-reduce-vpath is called from follow-vpath-loop and transfers :loop-rates and :lv-St 
   *into* :new-vpath-rates and :new-St respectively.
 - *follow-vpath* either calls *follow-vpath-to-tang* or *follow-vpath-loop*. *Both of these set :new-vpath-rates.*
 - reach-reduce-vpaths (toplevel reduce of vpaths, called from tangible-reach-graph) calls 
   *follow-vpath* and *into-v-rates* 

*** A very useful call graph!
reachability -> tangible-reach-graph -> reach-step-tangible
                                        reach-reduce-vpaths -> into-v-rates (after follow-vpath)
                                                               follow-vpath -> follow-vpath-to-tang
                                                                               follow-vpath-loop

follow-vpath-to-tang -> calc-vpath-rate (set :vrate-fn). 


follow-vpath-loop -> loop-reduce-vpath -> vanishing-matrices. 

*** TODO Strategy based on the call graph. 

Looking at this, I would say I need to know what into-v-rates does in order to know what :vrate-fn is supposed to do. 
A: It simply updates :v-rates (one line). Much like conj-t-rate.  (:t-rates, :v-rates). 

(defn summarize-reach
  "Merge :vpath-rates and :explored (sans vanishing) resulting in :M2Mp"
  [pn]
  (as-> pn ?pn
    (assoc ?pn :M2Mp (into (distinct (:t-rates ?pn))
                           (distinct (:v-rates ?pn)))) 
    (dissoc ?pn :explored :vexplored :spaths :t-rates :v-rates))) ; keep

If all goes well, then I'd have a :rate-fn on the appropriate links in :M2Mp. 
Marsan69 is an example. 

SUPER! I see that some links have :vrate-fn. If I just change that to :rate-fn ???

Well, a little more to it, since :fire is a list...Hang on. That's not quite right. 
It references next-links for rates, and these aren't a list.  So "simple syntax approach" should be okay. 

{[:Tpar1 :t_syn :t_ok] 0.5,
 [:Tpar1 :t_syn :t_ko] 0.5,
 [:Tcheck :t_start] 1.0,
 [:Tpar2 :t_syn :t_ok] 0.5,
 [:Tpar2 :t_syn :t_ko] 0.5,
 [:Tndata :t_start] 1.0,
 :Tpar1 1.0,
 :Tpar2 1.0,
 :Tio 1.0}

This rate table is kind of interesting! Shows just what I expect to get back!
((-> (:M2Mp pnpn) first :rate-fn) rrr)

[{:M [0 0 1 0 0 1 0 0 0], :fire :Tpar1, :Mp [0 0 0 0 1 1 0 0 0], :rate 1.0} 
 {:M [0 0 0 0 1 1 0 0 0], :fire :t_syn, :Mp [0 0 0 0 0 0 1 0 0], :rate 1.0} 
 {:M [0 0 0 0 0 0 1 0 0], :fire :t_ok, :Mp [0 0 0 0 0 0 0 0 1],  :rate 0.5}] 

It looks like going after rates off the transitions is wrong somehow and that
I should be going after the ones in these links. 

 *However, these links are intermediate information.* That means, you would be getting what was closed-over, 
  not a new computation. 

{:t_ko 1.0, 
 :t_ok 1.0, 
 :t_start 1.0, 
 :t_syn 1.0, 
 :Tcheck 1.0, 
 :Tio 1.0, 
 :Tndata 1.0, 
 :Tpar1 1.0, 
 :Tpar2 1.0}

t_ok is 1.0 but it competes with t_ko. There is a 1.0 rate into this 

(pnr/next-links pnpn [0 0 0 0 0 0 1 0 0])

[{:M [0 0 0 0 0 0 1 0 0],
  :fire :t_ko,
  :Mp [0 0 0 0 0 0 0 1 0],
  :rate-fn #function[gov.nist.spntools.util.reach/next-links/fn--12693/fn--12694],
  :rate 0.5}
 {:M [0 0 0 0 0 0 1 0 0],
  :fire :t_ok,
  :Mp [0 0 0 0 0 0 0 0 1],
  :rate-fn #function[gov.nist.spntools.util.reach/next-links/fn--12693/fn--12694],
  :rate 0.5}]

So I'm getting new rate functions out of these links. I should be calling that, 
not pulling the rate out of table for the :fire. 

** <2017-11-18 Sat>

*** I pulled this out of spntools/core (quick-test)
(defn quick-test []
  (let [result (:avg-tokens-on-place (pn-steady-state (read-pnml "data/qo10.xml")))
        correct  {:P1 0.111111, :P2 0.0, :P3 0.0, :P4 0.0, :P5 0.416667, 
                  :P6 0.333333, :P7 0.083333,  :P8 0.055556}]
        (every? (fn [[key val]]
                  (=* val (get correct key) 0.0001))
                result)))

*** I spent a *few minutes* debugging the parameteric code in spntools. ;^). 
*** Causal 
Today I implement causal. New file causal.clj

Here is the diagram [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/causal-model.jpg]]

Hurray! No loops in m3.xml 
Calculating its reachability graph takes 4.4 secs however. 

Works great! In m3.xml, if I increase the rate of M2, then 
  - M2 starves and blocks more.
  - Buffer occupancy from the buffer M2 pulls from decreases.
  - Buffer occupancy from the buffer M2 put to increases.

[{:buffer-1 0.8484531004290863,
  :buffer-2 0.2606202864362881,
  :m1-blocked 0.6923152811471641,
  :m1-busy 0.307684718852836,
  :m2-blocked 0.14292679580528836,
  :m2-busy 0.7933965380975156,
  :m2-starved 0.20660346190248446,
  :m3-busy 0.4727927954877663,
  :m3-starved 0.5272072045122338}
 {:buffer-1 0.7957467191633969,
  :buffer-2 0.32785103456872683,
  :m1-blocked 0.6242972600309968,
  :m1-busy 0.3757027399690032,
  :m2-blocked 0.18820608901740393,
  :m2-busy 0.7190646665440273,
  :m2-starved 0.28093533345597266,
  :m3-busy 0.5479873160833673,
  :m3-starved 0.45201268391663274}]

I think I'll stop here and write this up. 
** <2017-11-19 Sun>

I worked on the paper. Finished the PNN diagram, I think. 

** <2017-11-20 Mon>
I worked on the paper, 

I worked on the paper. Put in the causal stuff. Sent a copy to Charles and Jenny. 

** <2017-11-21 Tue>

I worked on the paper. I cleaned things up, particularly early in the paper. 

** <2017-11-22 Wed>

*** Paper 
I worked on the paper until 5PM. I made a ToDo list of things needed; cleaned up several parts. 
Charles and Jenny didn't think it was that far off. 
They suggest doing 3 things well, rather than trying to explain everything. I agree;
the ToDo list is about this. What I'm not talking about is a lot of GP stuff and Multi-model. 

*** Code
  Goal for the code is to get exceptional fitness pushing out individuals with queues. 
  I think I'll start by just pushing the structure into qualifying PNs (e.g. hopeful-pn)
  when it is determined. I'll watch if such individuals can initiate and rise to the top. 
  If that occurs, then maybe note the PN and allow a semantic genetic operator to operate
  on some such instances randomly. 

**** So what are the circumstances for initiating N=3 ? 
   1) k-bound to 3 -- need to recognize it and what place is being referred to.
   2) exceptional blocking on 3 -- (once the k=3 place is recognized?)

***** 
1) We know that :m1-blocked is a blocking message (:mjpact :bl :m :m1) (write scada/info-on-msg)
2) (util/buffers-between fitt/hopeful-pn :m1 :m2) ===> :Place-103

***** If this works, then (someday) I might want to "vectorize" k-binding. 
      Meaning that each place would have its own k value. 




Somehow, I have to conclude that :m1-blocked is a blocking message:

[:place-1 :place-2 :place-3 :place-4 :Place-103]

{[0 0 1 1 1] [:ordinary 0.0694485459151802],
 [0 1 0 1 0] [:ordinary 0.08709351469710418],
 [1 1 0 0 2] [:ordinary 0.06893423154021677],
 [0 1 0 1 3] [:m1-blocked 1.0000000000000002],
 [1 1 0 0 3] [:ordinary 0.1016596225146916],
 [0 1 0 1 1] [:ordinary 0.14753147327597801],
 [1 1 0 0 0] [:m2-starved 1.0],
 [0 0 1 1 0] [:ordinary 0.07437507450091606],
 [0 0 1 1 2] [:ordinary 0.09878476223725656],
 [1 1 0 0 1] [:m2-unstarved 1.0],
 [0 1 0 1 2] [:m1-unblocked 1.0000000000000002],
 [1 0 1 0 0] [:m2-starved 0.043936933623407434]}

** <2017-11-25 Sat>
  I'm looking into adding columns for network hops to Table 2. ...Done. 

*** To run pnn-certainty:
(def pnpn (as-> {} ?pn
            (assoc ?pn :sigma 0.35)
            (assoc ?pn :msg-table fitt/msg-table)
            (assoc ?pn :distance-fn (dist-fn-2 fitt/loom-steps fitt/norm-factors))
            (assoc ?pn :pdf-fns
                       (zipmap (-> ?pn :msg-table keys)
		               (map #(parzen-pdf-msg ?pn %)
                               (-> ?pn :msg-table keys))))))
(pnn-certainty pnpn)


[{:mark [0 0 1 1 1], :certainty 0.9999999999999906, :best :ordinary, :2best :m1-unblocked, :score 0.11280115552657274}
 {:mark [0 1 0 1 0], :certainty 0.9990385213120857, :best :ordinary, :2best :m1-unblocked, :score 0.11964136621006477}
 {:mark [1 1 0 0 2], :certainty 0.5509980610372053, :best :m2-unstarved, :2best :ordinary, :score 0.25652113562024753}
 {:mark [0 1 0 1 3], :certainty 0.7434788643797525, :best :m1-blocked, :2best :m1-unblocked, :score 1.0000000000000002}
 {:mark [1 1 0 0 3], :certainty 0.9989988579754929, :best :ordinary, :2best :m2-unstarved, :score 0.11490140358513679}
 {:mark [0 1 0 1 1], :certainty 0.19955555576732248, :best :m1-unblocked, :2best :ordinary, :score 0.2565211356202476}
 {:mark [1 1 0 0 0], :certainty 0.7434788643797525, :best :m2-starved, :2best :m2-unstarved, :score 1.0}
 {:mark [0 0 1 1 0], :certainty 1.0,                :best :ordinary, :2best :m2-unstarved, :score 0.08979893169932006}
 {:mark [0 0 1 1 2], :certainty 0.9999992983164814, :best :ordinary, :2best :m1-unblocked, :score 0.11570085562261395}
 {:mark [1 1 0 0 1], :certainty 0.7434788643797525, :best :m2-unstarved, :2best :m2-starved, :score 1.0}
 {:mark [0 1 0 1 2], :certainty 0.7434788643797525, :best :m1-unblocked, :2best :m1-blocked, :score 1.0000000000000002}
 {:mark [1 0 1 0 0], :certainty 0.9999928506164287, :best :ordinary, :2best :m2-starved, :score 0.011355578097432782}]
** <2017-12-06 Wed>

Been away from this for a while!
I updated to java 9, now nothing works. Is that really the reason? 
Maybe not, I dropped back to java 8. Still NG. 
Hmmm... I didn't really drop back! Oracle instructions for removing java didn't work?
Also the java control center doesn't report any version. java -version reports 9 still.
The Oracle instructions were for 1.9, not 1.9.1 (or whatever it is I had). 

As I said on Nov 22:

  Goal for the code is to get exceptional fitness pushing out individuals with queues. 
  I think I'll start by just pushing the structure into qualifying PNs (e.g. hopeful-pn)
  when it is determined. I'll watch if such individuals can initiate and rise to the top. 
  If that occurs, then maybe note the PN and allow a semantic genetic operator to operate
  on some such instances randomly. 

... Specifically, I wrote buffers-to-constrain. 

(def iii (exceptional-fitness (util/map->Inv {:pn fitt/hopeful-pn})))
(def pnpn (:pn iii)) ==> [{:buffer :Place-103, :k 3}]

** <2017-12-07 Thu>

ptaoussanis involved in both http-kit and sente, but http-kit started by shenfeng.
ptaoussanis is about the only one contributing to http-kit now. 

I am still trying to get a usable abort from running (diag-run) with a population
that contains nets with no places. All the nets in the population have no places, 
but that is beside the point; diag-run just sits there and smokes. Adding try/catch
and (>!! (rep/evolve-chan) "abort") isn't helping. 

When I find something that works, maybe a macro (handling-evolve ....)

Generation: 29
Best Error: 1.000
Avg Error: 1.241
Avg Arc count: 7.280
Avg Inhib count: 0.000
Avg Trans count: 3.040
Avg Place count: 2.040 <---------- Not kidding! Yet, there is not :remove-place operator in use. 
SD Error: 0.814
SD Arc count: 0.826
SD Trans count: 0.196
SD Place count: 0.196
in loop, msg = abort
aborting...


[{:name :place-1, :pid 0, :initial-tokens 0, :visible? true}
 {:name :place-2, :pid 1, :initial-tokens 1, :visible? true}
 {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
 {:name :place-4, :pid 3, :initial-tokens 1, :visible? true}
 {:name :Place-103, :pid 4, :initial-tokens 0}]
[{:name :m1-start-job,
  :tid 6,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2733.4538, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2734.7764, :j 2313, :line 2577},
  :visible? true}
 {:name :m1-move-off,
  :tid 7,
  :type :immediate,
  :rate 1.0,
  :rep {:clk 2734.7764, :act :m1-move-off, :m :m1, :mjpact :bj, :bf :b1, :n 2, :j 2313, :line 2580},
  :visible? true}
 {:name :m2-start-job,
  :tid 8,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2737.3893, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 3, :j 2313, :line 2591},
  :visible? true}
 {:name :m2-move-off,
  :tid 9,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2738.5593, :act :m2-move-off, :m :m2, :mjpact :ej, :ent 2733.4538, :j 2313, :line 2594},
  :visible? true}
 {:name :Trans-156, :tid 156, :type :exponential, :rate 1.0}
 {:name :Trans-165, :tid 165, :type :exponential, :rate 1.0}]
[{:aid 10, :source :place-1, :target :m1-start-job, :name :aa-10, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 11, :source :m1-start-job, :target :place-2, :name :aa-11, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 12, :source :place-2, :target :m1-move-off, :name :aa-12, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 13, :source :m1-move-off, :target :place-3, :name :aa-13, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 14, :source :place-3, :target :m2-start-job, :name :aa-14, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 15, :source :m2-start-job, :target :place-4, :name :aa-15, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 16, :source :place-4, :target :m2-move-off, :name :aa-16, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 17, :source :m2-move-off, :target :place-1, :name :aa-17, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 209, :source :m1-start-job, :target :Place-103, :name :aa-209, :type :normal, :multiplicity 1, :priority 2}
 {:aid 210, :source :Place-103, :target :m1-move-off, :name :aa-210, :type :normal, :multiplicity 1}
 {:aid 432, :source :place-2, :target :Trans-156, :name :aa-432, :type :normal, :multiplicity 1}
 {:aid 433, :source :Trans-156, :target :place-1, :name :aa-433, :type :normal, :multiplicity 1, :priority 1}
 {:aid 459, :source :Place-103, :target :Trans-165, :name :aa-459, :type :normal, :multiplicity 1}
 {:aid 460, :source :Trans-165, :target :place-3, :name :aa-460, :type :normal, :multiplicity 1, :priority 1}
 {:aid 461, :source :place-3, :target :m1-move-off, :name :aa-461, :type :inhibitor, :multiplicity 3}]


;;; Cut out the *useless* disorder measurement and it finds an answer fast!
;;; Still, its crap.

(def pnpn
{:places
[{:name :place-1, :pid 0, :initial-tokens 0, :visible? true}
 {:name :place-2, :pid 1, :initial-tokens 1, :visible? true}
 {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
 {:name :place-4, :pid 3, :initial-tokens 1, :visible? true}]
:arcs
[{:aid 106, :source :place-1, :target :m1-start-job, :name :aa-106, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 107, :source :m1-start-job, :target :place-2, :name :aa-107, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 108, :source :place-2, :target :m1-move-off, :name :aa-108, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 109, :source :m1-move-off, :target :place-3, :name :aa-109, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 110, :source :place-3, :target :m2-start-job, :name :aa-110, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 111, :source :m2-start-job, :target :place-4, :name :aa-111, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 112, :source :place-4, :target :m2-move-off, :name :aa-112, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
 {:aid 113, :source :m2-move-off, :target :place-1, :name :aa-113, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
 {:aid 221, :source :place-4, :target :Trans-106, :name :aa-221, :type :normal, :multiplicity 1}
 {:aid 222, :source :Trans-106, :target :place-3, :name :aa-222, :type :normal, :multiplicity 1, :priority 1}
 {:aid 246, :source :place-4, :target :Trans-115, :name :aa-246, :type :normal, :multiplicity 1}
 {:aid 247, :source :Trans-115, :target :place-3, :name :aa-247, :type :normal, :multiplicity 1, :priority 1}
 {:aid 268, :source :Trans-115, :target :place-1, :name :aa-268, :type :normal, :multiplicity 1, :priority 2}
 {:aid 285, :source :place-3, :target :m1-move-off, :name :aa-285, :type :inhibitor, :multiplicity 3}]
:transitions
[{:name :m1-start-job,
  :tid 54,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2502.7852, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2504.4905, :j 2121, :line 1781},
  :visible? true}
 {:name :m1-move-off,
  :tid 55,
  :type :immediate,
  :rate 1.0,
  :rep {:clk 2504.4905, :act :m1-move-off, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 2121, :line 1786},
  :visible? true}
 {:name :m2-start-job,
  :tid 56,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2506.3924, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 2121, :line 1793},
  :visible? true}
 {:name :m2-move-off,
  :tid 57,
  :type :exponential,
  :rate 1.0,
  :rep {:clk 2507.5624, :act :m2-move-off, :m :m2, :mjpact :ej, :ent 2502.7852, :j 2121, :line 1798},
  :visible? true}
 {:name :Trans-106, :tid 106, :type :exponential, :rate 1.0}
 {:name :Trans-115, :tid 115, :type :exponential, :rate 1.0}]})

** <2017-12-11 Mon>

*** Reading the Busi and Pinna paper, it is about safe nets with one "source place" and one "sink place". 
So I don't think it is very helpful.

*** Don't 'add choice' as a genetic operator, unless that is semantically what is intended!

Maybe this same sort of advice applies to all the operators (making it more deterministic?).
The above PN has two transitions between the same two places. (One has an additional outbound
to a third place, but that is beside the point, since that can be simplified.) 

*** Debugging the current exceptional -- How do the marking proliferate like this?

Oh how I would love for my pmap stuff to work! (What it does, I think is return with
timeout but not kill the thread.)

It takes way too long to compute! A first step might be to declare failure 
when the number of tokens in a marking exceed  k*(m - 1) + m. 

**** I do this one: Fail when a place other than a buffer has more than one token. 

*** Determine whether hopeful-pn is achievable with the current operators. 

*** NOT KEEPING THE ELITE!

** <2017-12-12 Tue>

*** NOT KEEPING THE ELITE! 

*** The above not solved, but now it goes off and never returns -- just dead. 
Fixed, function not returning object problem.
 
*** Add a "add-buffer" mutation -- works between machines. 

I wrote diag-simple-evolve, which greatly simplifies running things.
I decided towards add-buffer, but this will need more thought. 

** <2017-12-13 Wed>

Even a [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/sinet-simple-individual.jpg][simple individual]] has a buffer, in the sense of utils/buffers-between. 
But what it doesn't have is *machine perspective*: there is "probably" a set of messages
associated with a machine producing a part, and a cycle back to its original. 

The solution might be to apply two "machine cycle" mutations and one "buffer mutation."n

** <2017-12-17 Sun>

*** This is the old util/buffers-between
(defn buffers-between
  "Return all (only one?) buffers between the argument machines. 
   (1) The machines must be adjacent with m2 downstream from m1.
   (2) The candidate place must not function as blocking (that is,
   be between :ej and :sm or :aj transitions)."
  [pn m1 m2]
  (let [arcs  (:arcs pn)
        places (related-places pn)
        trans  (related-trans  pn)
        m1-places (m1 places)
        m2-places (m2 places)
        m1-trans (m1 trans)
        m2-trans (m2 trans)
        candidates (filterv
                    (fn [p] (and (not (contains? m1-places p))
                                 (not (contains? m2-places p))
                                 (some #(and (= (:target %) p)
                                             (contains? m1-trans (:source %)))
                                       (:arcs pn))
                                 (some #(and (= (:source %) p)
                                             (contains? m2-trans (:target %)))
                                       (:arcs pn))))
                    (map :name (:places pn)))]
    (filterv (fn [p]
               (not (and (some #(and (= (:target %) p)
                                     (= :bj (-> (pnu/name2obj pn (:source %)) :rep :mjpact)))
                               arcs)
                         (some #(and (= (:source %) p)
                                     (contains? #{:aj :sm} (-> (pnu/name2obj pn (:target %)) :rep :mjpact)))
                               arcs))))
             candidates)))


*** Here are old mutation operators
;;; POD this should probably go away! Replace by some sort of coping mechanism!
(defmethod mutate-m :add-token [inv & args]
  (if-let [places (-> inv :pn :places not-empty)]
    (let [p-indx (rand-int (count places))]
      (as-> inv ?i
          (update-in ?i [:pn :places p-indx :initial-tokens] inc)
          (update    ?i :history conj [:add-token (-> ?i :pn :places p-indx :name) :from (:id ?i)])))
    {:skip :add-token :msg "no place!"}))

(defmethod mutate-m :remove-token [inv & args]
  (if (> (apply + (->> inv :pn :places (map :initial-tokens))) 1)
    (let [pl (:name (random-place (:pn inv) :subset #(remove (fn [pl] (= 0 (:initial-tokens pl))) %)))]
      (-> inv
          (update-in [:pn :places (pnu/place-index (:pn inv) pl) :initial-tokens] dec)
          (update    :history conj [:remove-token pl :from (:id inv)])))
    {:skip :remove-token :msg "Not enough tokens left"}))

(defmethod mutate-m :swap-places [inv & args]
  (if-let [pl1 (:name (random-place (:pn inv)))]
    (if-let [pl2 (:name (random-place (:pn inv):subset #(filter (fn [pl] (not= (:name pl) pl1)) %)))]
      (-> inv
          (update :pn #(swap-arcs % pl1 pl2))
          (update :history conj [:swap-places pl1 pl2 :from (:id inv)]))
      {:skip :swap-places :msg "no 2nd place"})
    {:skip :swap-places :msg "no 1st place"}))

(defmethod mutate-m :swap-trans [inv & args]
  (if-let [tr1 (:name (random-trans (:pn inv)))]
    (if-let [tr2 (:name (random-trans (:pn inv):subset #(filter (fn [tr] (not= (:name tr) tr1)) %)))]
      (-> inv 
          (update :pn #(swap-arcs % tr1 tr2))
          (update :history conj [:swap-arcs tr1 tr2 :from (:id inv)]))
      {:skip :swap-trans :msg "no 2nd trans"})
    {:skip :swap-trans :msg "no 1st trans"}))

(defmethod mutate-m :add-inhibitor [inv & args]
  (if-let [tr (random-trans (:pn inv))]
    (if-let [pl (random-place (:pn inv))]
      (if-let [have-one (some #(when (and (= (:name pl) (:source %))
                                          (= (:name tr) (:target %))) %)
                              (filter #(= (:type %) :inhibitor) (-> inv :pn :arcs)))]
        (as-> inv ?i
          (update-in ?i [:pn :arcs (pnu/arc-index (:pn ?i) (:name have-one)) :multiplicity] inc)
          (update    ?i :history conj [:add-inhibitor :have-one (:name have-one) :from (:id ?i)]))
        (as-> inv ?i
          (update ?i :pn #(pnu/add-pn % (pnu/make-arc % (:name pl) (:name tr) :type :inhibitor)))
          (update ?i :history conj [:add-inhibitor (-> ?i :pn :arcs last :name) :from (:id ?i)])))
      {:skip :add-inhibitor :msg "No place"})
    {:skip :add-inhibitor :msg "No trans"}))

(defmethod mutate-m :bump-inhibitor-3 [inv & args]
  (if-let [inh (random-inhib (:pn inv))]
    (-> inv
        (update-in [:pn :arcs (pnu/arc-index (:pn inv) (:name inh)) :multiplicity] #(+ % 3))
        (update    :history conj [:bump-inhibitor-3 (:name inh) :from (:id inv)]))
    {:skip :bump-inhibitor-3 :msg "No inhib"}))

(defmethod mutate-m :remove-inhibitor [inv & args]
  (if-let [ar (random-arc (:pn inv) :subset #(filter (fn [ar] (= :inhibitor (:type ar))) %))]
    (if (= 1 (:multiplicity ar))
      (-> inv
          (update-in [:pn :arcs] (fn [arcs] (vec (remove #(=  % ar) arcs))))
          (update    :history conj [:remove-inhib (:name ar) :from (:id inv)]))
      (-> inv
          (update-in [:pn :arcs (pnu/arc-index (:pn inv) (:name ar)) :multiplicity] dec)
          (update    :history conj [:remove-inhib :dec (:name ar) :from (:id inv)])))
    {:skip :remove-inhibitor :msg "No inhibitor arcs"}))


*** Running with new add-buffer mutation operator

I'm stuck with simple-reach not fully expanding on [1 1 1 1 3] and a pn with a buffer. 

*** No implementation of method: :sch-send! of protocol: #'taoensso.sente.interfaces/IServerChan found 

for class: org.httpkit.server.AsyncChannel

Oh, sente!

Does this just not get loaded? 

**** Here is the code for the http-client (none)
(ns gov.nist.sinet.client.cexample
  (:require [clojure.string :as str]
            [org.httpkit.client :as hkit-c]  ; <============ DNE
            [reagent.core :as reagent]
            [re-frame.core :as rf]))

**** Here is the code for the http-server
(ns gov.nist.sinet.sexample
  (:require [clojure.string :as str]
            [org.httpkit.server :as hkit-s]
            [reagent.core :as reagent]
            [re-frame.core :as rf]))

(defn handler [req]
  (hkit-s/with-channel req channel              ; get the channel
    ;; communicate with client using method defined above
    (hkit-s/on-close channel (fn [status] (println "channel closed")))
    (if (hkit-s/websocket? channel)
      (println "WebSocket channel")
      (println "HTTP channel"))
    (hkit-s/on-receive channel (fn [data]       ; data received from client
           ;; An optional param can pass to send!: close-after-send?
           ;; When unspecified, `close-after-send?` defaults to true for HTTP channels
           ;; and false for WebSocket.  (send! channel data close-after-send?)
                                 (hkit-s/send! channel data))))) ; data is sent directly to the client




** <2017-12-18 Mon>

I worked on:
  (1) client/draw: not losing the graphics after moving things around. 
  (2) Fixing add-buffer (The error is now apparent thanks to (1).).
  (3) Adjusting the clojure.spec for PNs with inhibitor arcs.
** <2017-12-19 Tue>

The GP now works. Hurray! It finds something acceptable in 2 generations on the 2-machine example. 

DONE: Need to not add an inhibitor where one already exists (a problem both with :add-inhibitor and :add-buffer). 
      (The problem was actually with fit/buffers-to-constrain; :add-inhibitor DNE.)

Moving on to a 3-machine example; investigating move-on versus complete-job in MJPdes.

Fails at find-interpretation. 

[:place-1 :place-2 :place-3 :place-4 :place-5 :place-6 :Place-177 :Place-178]
Here are the starting links: (It looks like only a subset of the possible buffer contents.)

[{:M [0 1 0 1 0 1 1 1],
  :fire :m2-complete-job,
  :Mp [0 1 0 0 1 1 1 1],
  :rate 1.0,
  :indx 0,
  :job 1356}
 {:M [0 1 0 1 0 1 1 0],
  :fire :m2-complete-job,
  :Mp [0 1 0 0 1 1 1 0],
  :rate 1.0,
  :indx 0,
  :job 1356}
 {:M [0 1 0 1 0 1 2 1],
  :fire :m2-complete-job,
  :Mp [0 1 0 0 1 1 2 1],
  :rate 1.0,
  :indx 0,
  :job 1356}
 {:M [0 1 0 1 0 1 2 0],
  :fire :m2-complete-job,
  :Mp [0 1 0 0 1 1 2 0],
  :rate 1.0,
  :indx 0,
  :job 1356}]

Best of these is n=3, stops at :indx 155
                                                            :b1       :b2
[:place-1 :place-2 :place-3 :place-4 :place-5 :place-6 :Place-177 :Place-178]
{:M [0 1 0 1 0 1 2 2], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 2], :rate-fn, :rate 1.0, :m :m2, :job 1381, :clk 2033.3367, :indx 155}

{:clk 2033.3367 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1381 :line 155}
{:clk 2033.3367 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1382 :line 156}

---> As shown, there should be n=1 in :b2 at line 155, according to the marking, there is 2.
I think that means a better starting marking would have one less, but this is starting with [0 1 0 1 0 1 2 0] -- nothing in :b2

It can't do line 156 because under the assumed marking the machine is blocked. That part makes sense! 
So if it is really starting with 0 in :b2, how does it get here? (Check log too). 

--> log suggest [0 1 0 1 0 1 2 0]  should be the right starting place. 

That is all machines busy. First , buffers full!

[0 1 0 1 0 1 2 0]
{:clk 1999.6152 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 0 :j 1356 :line 0}
{:clk 1999.6152 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1357 :line 1}
{:clk 1999.6152 :act :m1-unblocked :m :m1 :mjpact :ub :line 2}
{:clk 1999.6152 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1359 :line 3}
{:clk 1999.6152 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType1 :ends 2000.6152 :j 1360 :line 4}
{:clk 2000.1007 :act :m3-complete-job :m :m3 :mjpact :ej :ent 1992.4608 :j 1355 :line 5}
{:clk 2000.1007 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 1 :j 1356 :line 6}
{:clk 2000.6152 :act :m1-blocked :m :m1 :mjpact :bl :line 7}
{:clk 2001.1152 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 0 :j 1357 :line 8}
{:clk 2001.1152 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1358 :line 9}
{:clk 2001.1152 :act :m1-unblocked :m :m1 :mjpact :ub :line 10}
{:clk 2001.1152 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1360 :line 11}


Nothing goes past 155. 
(defn foo [pn]
  (let [starts (:rgraph pn)
        log (-> (app-info) :problem :scada-log)]
    (doall (map #(interpret-scada pn log (assoc % :indx 0, :job 1356))
                starts))))

{:clk 2029.4593 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType1 :ends 2030.4593 :j 1383 :line 144}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1383, :indx 144}

{:clk 2029.8525 :act :m2-blocked :m :m2 :mjpact :bl :line 145}
{:clk 2030.4593 :act :m1-blocked :m :m1 :mjpact :bl :line 146}

{:clk 2031.8367 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2021.4593 :j 1377 :line 147}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1377, :indx 147}

{:clk 2031.8367 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1378 :line 148}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1378, :indx 148}

{:clk 2031.8367 :act :m2-unblocked :m :m2 :mjpact :ub :line 149}

{:clk 2031.8367 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1380 :line 150}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1380, :indx 150}

{:clk 2031.8367 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1381 :line 151}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1381, :indx 151}

{:clk 2031.8367 :act :m1-unblocked :m :m1 :mjpact :ub :line 152}

{:clk 2031.8367 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1383 :line 153}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1383, :indx 153}

{:clk 2031.8367 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType1 :ends 2033.4168 :j 1384 :line 154}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1384, :indx 154}

{:clk 2033.3367 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1381 :line 155}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 2], :rate 1.0, :m :m2, :job 1381, :indx 155}
**** If these markings were correct, m2 would be blocking now. It is not because n=1.
     The log starts with zero in :b2, and the starts[3] marking reflects this:
     starts[3] = {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :indx 0, :job 1356}
     So how do I get to messed up landing on n=1 here? 

{:clk 2033.3367 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1382 :line 156}
{:clk 2033.3367 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2022.9593 :j 1378 :line 157}
{:clk 2033.3367 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1379 :line 158}

** <2017-12-20 Wed>

*** Deep dive into the log and rgraph:

log =  {:clk 1999.6152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1356, :line 0}
start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :indx 0, :job 1356}

log =  {:clk 1999.6152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1357, :line 1}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1357, :indx 1}

log =  {:clk 1999.6152, :act :m1-unblocked, :m :m1, :mjpact :ub, :line 2}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1357, :indx 2}
log =  {:clk 1999.6152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1359, :line 3}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1359, :indx 3}

log =  {:clk 1999.6152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2000.6152, :j 1360, :line 4}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1360, :indx 4}

log =  {:clk 2000.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1992.4608, :j 1355, :line 5}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1355, :indx 5}

log =  {:clk 2000.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1356, :line 6}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1356, :indx 6}

log =  {:clk 2000.6152, :act :m1-blocked, :m :m1, :mjpact :bl, :line 7}
matched =  {:act :m1-blocked, :prev-act :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :state [0 1 0 1 0 1 2 0], :job 1356, :indx 7}
**** This part is hard to understand and messed up! 
**** There is no token in place-3 (:m1 blocked) at this point, but there should be starting with :m1-blocked.
**** DES is noting that 1 time unit has elapsed since :m1-start-job at 1999.6152. 
**** Essentially, DES.m1-blocked corresponds to PN.m1-complete-job where the buffer is full. 
**** This is, of course, what the exceptional code recognizes. 

log =  {:clk 2001.1152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1357, :line 8}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1357, :indx 8}
**** According to PN :m1 was working on a part (:place-2 = 1). THAT'S NOT TRUE; :m1 IS BLOCKED. ---> START OF WRONG

log =  {:clk 2001.1152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1358, :line 9}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1358, :indx 9}

log =  {:clk 2001.1152, :act :m1-unblocked, :m :m1, :mjpact :ub, :line 10}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1358, :indx 10}
log =  {:clk 2001.1152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1360, :line 11}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1360, :indx 11}
**** Finally here (:Mp) PN moves into m1 blocked (:place-3 = 1).                                 ---> END OF WRONG 
**** m1-unblocked/m1-complete-job is "move-off" WHICH IS SIGNIFIED IN MJPdes WITH :M1-COMPLETE-JOB. 
***** This 'error' has consequences in terms of quantification of sojourn times!
***** Adjustment ("re-interpretation of PN") will be necessary, setting :m1-complete-job to the time
***** of :m1-blocked.  

****** The question now is whether this has is what is causing the problem at line 155. 

log =  {:clk 2001.1152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2002.6152, :j 1361, :line 12}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1361, :indx 12}

*** More of log (not studied)

log =  {:clk 2001.6007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1993.9608, :j 1356, :line 13}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1356, :indx 13}
log =  {:clk 2001.6007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1357, :line 14}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1357, :indx 14}
log =  {:clk 2002.1152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1358, :line 15}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1358, :indx 15}
log =  {:clk 2002.1152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1359, :line 16}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1359, :indx 16}
log =  {:clk 2002.6152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1361, :line 17}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1361, :indx 17}
log =  {:clk 2002.6152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2004.1152, :j 1362, :line 18}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1362, :indx 18}
log =  {:clk 2003.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1995.4608, :j 1357, :line 19}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1357, :indx 19}
log =  {:clk 2003.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1358, :line 20}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1358, :indx 20}
log =  {:clk 2003.1152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1359, :line 21}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1359, :indx 21}
log =  {:clk 2003.1152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1360, :line 22}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1360, :indx 22}
log =  {:clk 2004.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1996.9608, :j 1358, :line 23}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1358, :indx 23}
log =  {:clk 2004.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1359, :line 24}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1359, :indx 24}
log =  {:clk 2004.1152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1362, :line 25}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1362, :indx 25}
log =  {:clk 2004.1152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2005.6152, :j 1363, :line 26}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1363, :indx 26}
log =  {:clk 2004.1152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1360, :line 27}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1360, :indx 27}
log =  {:clk 2004.1152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1361, :line 28}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1361, :indx 28}
log =  {:clk 2005.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1997.9608, :j 1359, :line 29}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1359, :indx 29}
log =  {:clk 2005.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1360, :line 30}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1360, :indx 30}
log =  {:clk 2005.6152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1363, :line 31}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1363, :indx 31}
log =  {:clk 2005.6152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2007.1152, :j 1364, :line 32}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1364, :indx 32}
log =  {:clk 2005.6152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1361, :line 33}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1361, :indx 33}
log =  {:clk 2005.6152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1362, :line 34}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1362, :indx 34}
log =  {:clk 2006.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 1999.6152, :j 1360, :line 35}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1360, :indx 35}
log =  {:clk 2006.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1361, :line 36}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1361, :indx 36}
log =  {:clk 2007.1152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1364, :line 37}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1364, :indx 37}
log =  {:clk 2007.1152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2008.1152, :j 1365, :line 38}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1365, :indx 38}
log =  {:clk 2007.1152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1362, :line 39}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1362, :indx 39}
log =  {:clk 2007.1152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1363, :line 40}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1363, :indx 40}
log =  {:clk 2007.6007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2001.1152, :j 1361, :line 41}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1361, :indx 41}
log =  {:clk 2007.6007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1362, :line 42}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1362, :indx 42}
log =  {:clk 2008.1152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1365, :line 43}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1365, :indx 43}
log =  {:clk 2008.1152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2009.1152, :j 1366, :line 44}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1366, :indx 44}
log =  {:clk 2008.6152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1363, :line 45}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1363, :indx 45}
log =  {:clk 2008.6152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1364, :line 46}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1364, :indx 46}
log =  {:clk 2009.1007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2002.6152, :j 1362, :line 47}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1362, :indx 47}
log =  {:clk 2009.1007, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1363, :line 48}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1363, :indx 48}
log =  {:clk 2009.1152, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1366, :line 49}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1366, :indx 49}
log =  {:clk 2009.1152, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2010.9593, :j 1367, :line 50}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1367, :indx 50}
log =  {:clk 2010.6007, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2004.1152, :j 1363, :line 51}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 0], :rate 1.0, :m :m3, :job 1363, :indx 51}
log =  {:clk 2010.6007, :act :m3-starved, :m :m3, :mjpact :st, :line 52}
matched =  {:act :m3-starved, :prev-act :m3-complete-job, :Mp [1 1 0 1 0 0 2 0], :state [1 1 0 1 0 0 2 0], :job 1363, :indx 52}
log =  {:clk 2010.7528, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1364, :line 53}
matched =  {:M [1 1 0 1 0 0 2 0], :fire :m2-complete-job, :Mp [1 1 0 0 1 0 2 0], :rate 1.0, :m :m2, :job 1364, :indx 53}
log =  {:clk 2010.7528, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1365, :line 54}
matched =  {:M [1 1 0 0 1 0 2 0], :fire :m2-start-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m2, :job 1365, :indx 54}
log =  {:clk 2010.7528, :act :m3-unstarved, :m :m3, :mjpact :us, :line 55}
matched =  {:act :m3-unstarved, :prev-act :m2-start-job, :Mp [1 1 0 1 0 0 1 1], :state [1 1 0 1 0 0 1 1], :job 1365, :indx 55}
log =  {:clk 2010.7528, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1364, :line 56}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1364, :indx 56}
log =  {:clk 2010.9593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1367, :line 57}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1367, :indx 57}
log =  {:clk 2010.9593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2012.4593, :j 1368, :line 58}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1368, :indx 58}
log =  {:clk 2011.7528, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1365, :line 59}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1365, :indx 59}
log =  {:clk 2011.7528, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1366, :line 60}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1366, :indx 60}
log =  {:clk 2012.2528, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2005.6152, :j 1364, :line 61}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1364, :indx 61}
log =  {:clk 2012.2528, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1365, :line 62}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1365, :indx 62}
log =  {:clk 2012.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1368, :line 63}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1368, :indx 63}
log =  {:clk 2012.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2013.4593, :j 1369, :line 64}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1369, :indx 64}
log =  {:clk 2012.7528, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1366, :line 65}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1366, :indx 65}
log =  {:clk 2012.7528, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1367, :line 66}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1367, :indx 66}
log =  {:clk 2013.2528, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2007.1152, :j 1365, :line 67}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1365, :indx 67}
log =  {:clk 2013.2528, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1366, :line 68}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1366, :indx 68}
log =  {:clk 2013.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1369, :line 69}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1369, :indx 69}
log =  {:clk 2013.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2014.9593, :j 1370, :line 70}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1370, :indx 70}
log =  {:clk 2013.7528, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1367, :line 71}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1367, :indx 71}
log =  {:clk 2013.7528, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1368, :line 72}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1368, :indx 72}
log =  {:clk 2014.2528, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2008.1152, :j 1366, :line 73}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1366, :indx 73}
log =  {:clk 2014.2528, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1367, :line 74}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1367, :indx 74}
log =  {:clk 2014.9593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1370, :line 75}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1370, :indx 75}
log =  {:clk 2014.9593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2016.4593, :j 1371, :line 76}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1371, :indx 76}
log =  {:clk 2015.2528, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1368, :line 77}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1368, :indx 77}
log =  {:clk 2015.2528, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1369, :line 78}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1369, :indx 78}
log =  {:clk 2016.2543, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1369, :line 79}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1369, :indx 79}
log =  {:clk 2016.2543, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 1, :j 1370, :line 80}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1370, :indx 80}
log =  {:clk 2016.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 0, :j 1371, :line 81}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1371, :indx 81}
log =  {:clk 2016.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2017.4593, :j 1372, :line 82}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1372, :indx 82}
log =  {:clk 2016.845, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2009.1152, :j 1367, :line 83}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1367, :indx 83}
log =  {:clk 2016.845, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1368, :line 84}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1368, :indx 84}
log =  {:clk 2017.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1372, :line 85}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1372, :indx 85}
log =  {:clk 2017.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2018.4593, :j 1373, :line 86}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1373, :indx 86}
log =  {:clk 2017.8525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1370, :line 87}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1370, :indx 87}
log =  {:clk 2017.8525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1371, :line 88}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1371, :indx 88}
log =  {:clk 2018.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2010.9593, :j 1368, :line 89}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1368, :indx 89}
log =  {:clk 2018.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1369, :line 90}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1369, :indx 90}
log =  {:clk 2018.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1373, :line 91}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1373, :indx 91}
log =  {:clk 2018.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2019.4593, :j 1374, :line 92}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1374, :indx 92}
log =  {:clk 2019.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2012.4593, :j 1369, :line 93}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1369, :indx 93}
log =  {:clk 2019.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1370, :line 94}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1370, :indx 94}
log =  {:clk 2019.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1371, :line 95}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1371, :indx 95}
log =  {:clk 2019.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1372, :line 96}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1372, :indx 96}
log =  {:clk 2019.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1374, :line 97}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1374, :indx 97}
log =  {:clk 2019.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2020.4593, :j 1375, :line 98}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1375, :indx 98}
log =  {:clk 2020.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1372, :line 99}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1372, :indx 99}
log =  {:clk 2020.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1373, :line 100}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1373, :indx 100}
log =  {:clk 2020.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1375, :line 101}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1375, :indx 101}
log =  {:clk 2020.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2021.4593, :j 1376, :line 102}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1376, :indx 102}
log =  {:clk 2020.845, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2013.4593, :j 1370, :line 103}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1370, :indx 103}
log =  {:clk 2020.845, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1371, :line 104}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1371, :indx 104}
log =  {:clk 2021.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1373, :line 105}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1373, :indx 105}
log =  {:clk 2021.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1374, :line 106}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1374, :indx 106}
log =  {:clk 2021.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1376, :line 107}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1376, :indx 107}
log =  {:clk 2021.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2022.9593, :j 1377, :line 108}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1377, :indx 108}
log =  {:clk 2022.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2014.9593, :j 1371, :line 109}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1371, :indx 109}
log =  {:clk 2022.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1372, :line 110}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1372, :indx 110}
log =  {:clk 2022.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1374, :line 111}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1374, :indx 111}
log =  {:clk 2022.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1375, :line 112}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1375, :indx 112}
log =  {:clk 2022.9593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1377, :line 113}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1377, :indx 113}
log =  {:clk 2022.9593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2024.4593, :j 1378, :line 114}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1378, :indx 114}
log =  {:clk 2023.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2016.4593, :j 1372, :line 115}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1372, :indx 115}
log =  {:clk 2023.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1373, :line 116}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1373, :indx 116}
log =  {:clk 2023.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1375, :line 117}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1375, :indx 117}
log =  {:clk 2023.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1376, :line 118}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1376, :indx 118}
log =  {:clk 2024.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2017.4593, :j 1373, :line 119}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1373, :indx 119}
log =  {:clk 2024.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1374, :line 120}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1374, :indx 120}
log =  {:clk 2024.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1376, :line 121}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1376, :indx 121}
log =  {:clk 2024.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 1, :j 1377, :line 122}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1377, :indx 122}
log =  {:clk 2024.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 0, :j 1378, :line 123}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1378, :indx 123}
log =  {:clk 2024.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2025.9593, :j 1379, :line 124}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1379, :indx 124}
log =  {:clk 2025.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2018.4593, :j 1374, :line 125}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1374, :indx 125}
log =  {:clk 2025.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1375, :line 126}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1375, :indx 126}
log =  {:clk 2025.8525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1377, :line 127}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1377, :indx 127}
log =  {:clk 2025.8525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 1, :j 1378, :line 128}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1378, :indx 128}
log =  {:clk 2025.9593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 0, :j 1379, :line 129}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1379, :indx 129}
log =  {:clk 2025.9593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2026.9593, :j 1380, :line 130}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1380, :indx 130}
log =  {:clk 2026.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2019.4593, :j 1375, :line 131}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1375, :indx 131}
log =  {:clk 2026.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1376, :line 132}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1376, :indx 132}
log =  {:clk 2026.9593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1380, :line 133}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1380, :indx 133}
log =  {:clk 2026.9593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType2, :ends 2028.4593, :j 1381, :line 134}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1381, :indx 134}
log =  {:clk 2027.345, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2020.4593, :j 1376, :line 135}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1376, :indx 135}
log =  {:clk 2027.345, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 1, :j 1377, :line 136}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1377, :indx 136}
log =  {:clk 2027.3525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1378, :line 137}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1378, :indx 137}
log =  {:clk 2027.3525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1379, :line 138}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1379, :indx 138}
log =  {:clk 2028.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1381, :line 139}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1381, :indx 139}
log =  {:clk 2028.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2029.4593, :j 1382, :line 140}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1382, :indx 140}
log =  {:clk 2028.8525, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1379, :line 141}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1379, :indx 141}
log =  {:clk 2028.8525, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1380, :line 142}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1380, :indx 142}
log =  {:clk 2029.4593, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1382, :line 143}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1382, :indx 143}
log =  {:clk 2029.4593, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2030.4593, :j 1383, :line 144}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1383, :indx 144}
log =  {:clk 2029.8525, :act :m2-blocked, :m :m2, :mjpact :bl, :line 145}

*** Deep dive 2: Log where things get botched up
matched =  {:act :m2-blocked, :prev-act :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :state [0 1 0 1 0 1 2 2], :job 1383, :indx 145}
log =  {:clk 2030.4593, :act :m1-blocked, :m :m1, :mjpact :bl, :line 146}
matched =  {:act :m1-blocked, :prev-act nil, :Mp [0 1 0 1 0 1 2 2], :state [0 1 0 1 0 1 2 2], :job 1383, :indx 146}
log =  {:clk 2031.8367, :act :m3-complete-job, :m :m3, :mjpact :ej, :ent 2021.4593, :j 1377, :line 147}
**** Both buffers are full, :m2 and :m1 blocked. 

matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1377, :indx 147}
log =  {:clk 2031.8367, :act :m3-start-job, :m :m3, :mjpact :sm, :bf :b2, :n 2, :j 1378, :line 148}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1378, :indx 148}
**** :m3 pulls a job, :b2 n: 2->1 ...
log =  {:clk 2031.8367, :act :m2-unblocked, :m :m2, :mjpact :ub, :line 149}
matched =  {:act :m2-unblocked, :prev-act :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :state [0 1 0 1 0 1 2 1], :job 1378, :indx 149}
****  ...unblocking :m2.

log =  {:clk 2031.8367, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1380, :line 150}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1380, :indx 150}
**** ...weirdness noted above about unblocking/complete-job with BAS, place-5:0->1 place-4:1->0

log =  {:clk 2031.8367, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1381, :line 151}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1381, :indx 151}
**** ...m2 gets busy. b1 n:2->1

log =  {:clk 2031.8367, :act :m1-unblocked, :m :m1, :mjpact :ub, :line 152}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :state [0 1 0 1 0 1 1 2], :job 1381, :indx 152}
**** ...unblocking :m1. 

log =  {:clk 2031.8367, :act :m1-complete-job, :m :m1, :mjpact :bj, :bf :b1, :n 1, :j 1383, :line 153}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1383, :indx 153}
**** :place-2:1->0 :place-3:0->1.

log =  {:clk 2031.8367, :act :m1-start-job, :m :m1, :mjpact :aj, :jt :jobType1, :ends 2033.4168, :j 1384, :line 154}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1384, :indx 154}
**** :place-2:0->1 :place-3:1->0.

log =  {:clk 2033.3367, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 1, :j 1381, :line 155}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 2], :rate 1.0, :m :m2, :job 1381, :indx 155}
**** At :M m1, m2, m3 are busy. At :Mp m2 goes into blocking (place-5 = 1). 

log =  {:clk 2033.3367, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1382, :line 156}
matched =  nil

Problem: ====> :m2-start-job would place another part in :b2 (:Place-178), exceeding max-k. 
Question: Is the contemporaneous ordering wrong/not helpful?

{:clk 2033.3367 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1381 :line 155}
{:clk 2033.3367 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1382 :line 156}
{:clk 2033.3367 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2022.9593 :j 1378 :line 157}
{:clk 2033.3367 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1379 :line 158}

It could have done: <==================================================================== CONTEMPORANEOUS
- m3-complete-job 
- m3-start-job
- m2-start-job
- m2-complete-job

I don't know whether in general I'll be able to get this right in MJPdes, so 
I'm going to keep a atom buffer in find-interpretation for all messages and pick from them. 

({:M [0 1 0 0 1 1 2 2],
  :fire :m3-complete-job,
  :Mp [1 1 0 0 1 0 2 2],
  :rate 1.0}
 {:M [0 1 0 0 1 1 2 2],
  :fire :m1-complete-job,
  :Mp [0 0 1 0 1 1 2 2],
  :rate 1.0})

***** {:clk 2033.3367 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1382 :line 156}
***** {:clk 2033.3367 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2022.9593 :j 1378 :line 157}
***** {:clk 2033.3367 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1379 :line 158}
***** {:clk 2033.4168 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1384 :line 159}
***** {:clk 2033.4168 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType2 :ends 2034.9168 :j 1385 :line 160}

(defn foo [pn]
  (let [starts (:rgraph pn)
        log (-> (app-info) :problem :scada-log)]
    (doall (map #(interpret-scada pn log (assoc % :indx 0, :job 1356))
                starts))))

(defn foo1 [n]
  (let [log (-> (app-info) :problem :scada-log)]
    (interpret-scada pnpn1 log (nth starts n)))
  true)




*** The problem is that I should be looking at all contemporaneous messages for the match. 
I wrote the code to do that. 

** <2017-12-21 Thu>

*** Meeting with Charles

UPR Architectural Decision -- re-architect, 
  "commercial implementation" --> "industrial pilot."  

** <2018-01-04 Thu>
I started cleaning up the 3-machine test, which before the break I had started an implementation
of selecting a message from all contemporaneous messages. 

I did not save the PN so I'm going to have to start with that on Friday. 
** <2018-01-05 Fri>

From a long time back, I had a [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/m3-serial-line.jpg][complete 3-machine description (with starve/block on m2)]].  
What the code is capable of now is just to add the two buffers. 
I will call this 'hopeful-pn-2'

*** Note that I had to hit it a few times with (mutate iii :force :add-buffer) to get both buffers. Is that what I want? 
*** hopeful-pn-2

[[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/m3-hopeful.jpg][m3-hopeful.jpg]]

[[file:~/Documents/git/sinet/data/PNs/hopeful-pn-2.clj::%3B%3B%3B%20A%20three-machine%20system%20with%20two%20buffers%20(mutate%20:add-buffer)-ed%20in.][hopeful-pn-2.clj in data/PNs]]. It is also used in fitness_test.clj
(def pnpn (load-file "data/PNs/hopeful-pn-2.clj"))


6.98 secs before I switch to transient pn (but things aren't working any way). 
7.52 afterwards! (job 1356)
These are much faster if I don't go to N=4! 

*** Since :max-max-k is 3 and in fact the MJPdes model has N=2 for each buffer, how is 
    it that I'm seeing a rgraph like with 4 in some places? ... Fixed. 

Ugh! job 1356 is line 0!

*** Best result is only 51 lines. What was it before I started? Answer: Line 155. Thus I'm not even back to normal yet!
start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :line 0, :job 1356}

I don't seem to have data about the starting point for one that went 155 lines. Can I get it back? 
Answer: Yes!

*** Goes to 155 SAME START (GOOD!)
start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :indx 0, :job 1356}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1357, :indx 1}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1357, :indx 2}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1359, :indx 3}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1360, :indx 4}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1355, :indx 5}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1356, :indx 6}
matched =  {:act :m1-blocked, :prev-act :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :state [0 1 0 1 0 1 2 0], :job 1356, :indx 7}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1357, :indx 8}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1358, :indx 9}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1358, :indx 10}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1360, :indx 11}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1361, :indx 12}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1356, :indx 13}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1357, :indx 14}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1358, :indx 15}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1359, :indx 16}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1361, :indx 17}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1362, :indx 18}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1357, :indx 19}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1358, :indx 20}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1359, :indx 21}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1360, :indx 22}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1358, :indx 23}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1359, :indx 24}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1362, :indx 25}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1363, :indx 26}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1360, :indx 27}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1361, :indx 28}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1359, :indx 29}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1360, :indx 30}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1363, :indx 31}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1364, :indx 32}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1361, :indx 33}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1362, :indx 34}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1360, :indx 35}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1361, :indx 36}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1364, :indx 37}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1365, :indx 38}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1362, :indx 39}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1363, :indx 40}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1361, :indx 41}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1362, :indx 42}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1365, :indx 43}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1366, :indx 44}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1363, :indx 45}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1364, :indx 46}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1362, :indx 47}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1363, :indx 48}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1366, :indx 49}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1367, :indx 50}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 0], :rate 1.0, :m :m3, :job 1363, :indx 51}
matched =  {:act :m3-starved, :prev-act :m3-complete-job, :Mp [1 1 0 1 0 0 2 0], :state [1 1 0 1 0 0 2 0], :job 1363, :indx 52}
matched =  {:M [1 1 0 1 0 0 2 0], :fire :m2-complete-job, :Mp [1 1 0 0 1 0 2 0], :rate 1.0, :m :m2, :job 1364, :indx 53}
matched =  {:M [1 1 0 0 1 0 2 0], :fire :m2-start-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m2, :job 1365, :indx 54}
matched =  {:act :m3-unstarved, :prev-act :m2-start-job, :Mp [1 1 0 1 0 0 1 1], :state [1 1 0 1 0 0 1 1], :job 1365, :indx 55}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1364, :indx 56}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1367, :indx 57}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1368, :indx 58}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1365, :indx 59}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1366, :indx 60}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1364, :indx 61}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1365, :indx 62}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1368, :indx 63}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1369, :indx 64}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1366, :indx 65}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1367, :indx 66}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1365, :indx 67}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1366, :indx 68}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1369, :indx 69}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1370, :indx 70}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1367, :indx 71}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1368, :indx 72}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1366, :indx 73}
matched =  {:M [1 1 0 1 0 0 1 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m3, :job 1367, :indx 74}
matched =  {:M [0 1 0 1 0 1 1 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 0], :rate 1.0, :m :m1, :job 1370, :indx 75}
matched =  {:M [0 0 1 1 0 1 1 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m1, :job 1371, :indx 76}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1368, :indx 77}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1369, :indx 78}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1369, :indx 79}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1370, :indx 80}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1371, :indx 81}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1372, :indx 82}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1367, :indx 83}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1368, :indx 84}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1372, :indx 85}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1373, :indx 86}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1370, :indx 87}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1371, :indx 88}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1368, :indx 89}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1369, :indx 90}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1373, :indx 91}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1374, :indx 92}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1369, :indx 93}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1370, :indx 94}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1371, :indx 95}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1372, :indx 96}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1374, :indx 97}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1375, :indx 98}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1372, :indx 99}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1373, :indx 100}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1375, :indx 101}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1376, :indx 102}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1370, :indx 103}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1371, :indx 104}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1373, :indx 105}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1374, :indx 106}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1376, :indx 107}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1377, :indx 108}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1371, :indx 109}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1372, :indx 110}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1374, :indx 111}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1375, :indx 112}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1377, :indx 113}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1378, :indx 114}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1372, :indx 115}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1373, :indx 116}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1375, :indx 117}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1376, :indx 118}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1373, :indx 119}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1374, :indx 120}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1376, :indx 121}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1377, :indx 122}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1378, :indx 123}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1379, :indx 124}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1374, :indx 125}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1375, :indx 126}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1377, :indx 127}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1378, :indx 128}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1379, :indx 129}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1380, :indx 130}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1375, :indx 131}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1376, :indx 132}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1380, :indx 133}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1381, :indx 134}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 1], :rate 1.0, :m :m3, :job 1376, :indx 135}
matched =  {:M [1 1 0 1 0 0 2 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 0], :rate 1.0, :m :m3, :job 1377, :indx 136}
matched =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :m :m2, :job 1378, :indx 137}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1379, :indx 138}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 1], :rate 1.0, :m :m1, :job 1381, :indx 139}
matched =  {:M [0 0 1 1 0 1 1 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m1, :job 1382, :indx 140}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1379, :indx 141}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1380, :indx 142}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1382, :indx 143}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1383, :indx 144}
matched =  {:act :m2-blocked, :prev-act :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :state [0 1 0 1 0 1 2 2], :job 1383, :indx 145}
matched =  {:act :m1-blocked, :prev-act nil, :Mp [0 1 0 1 0 1 2 2], :state [0 1 0 1 0 1 2 2], :job 1383, :indx 146}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 2 2], :rate 1.0, :m :m3, :job 1377, :indx 147}
matched =  {:M [1 1 0 1 0 0 2 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :rate 1.0, :m :m3, :job 1378, :indx 148}
matched =  {:act :m2-unblocked, :prev-act :m3-start-job, :Mp [0 1 0 1 0 1 2 1], :state [0 1 0 1 0 1 2 1], :job 1378, :indx 149}
matched =  {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :m :m2, :job 1380, :indx 150}
matched =  {:M [0 1 0 0 1 1 2 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m2, :job 1381, :indx 151}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 2], :state [0 1 0 1 0 1 1 2], :job 1381, :indx 152}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 1 2], :rate 1.0, :m :m1, :job 1383, :indx 153}
matched =  {:M [0 0 1 1 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 2 2], :rate 1.0, :m :m1, :job 1384, :indx 154}
matched =  {:M [0 1 0 1 0 1 2 2], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 2], :rate 1.0, :m :m2, :job 1381, :indx 155}
matched =  nil

*** NEXT STEP: Run the new msg-buf version and see where it goes wrong. 

** <2018-01-06 Sat>

*** Continuing with debug; here's from the msg-buf approach

start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate-fn #function[gov.nist.spntools.util.reach/next-links/fn--32658/fn--32663], :rate 1.0, :line 0, :job 1356}
matched =  {:fire :m2-complete-job, :M [0 1 0 1 0 1 1 1], :Mp [0 1 0 0 1 1 1 1], :m :m2, :rate 1.0, :relax? :active, :line 0, :job 1356}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1357, :line 1}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :state [0 1 0 1 0 1 0 2], :job 1357, :line 2}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1359, :line 3}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1360, :line 4}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1355, :line 5}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1356, :line 6}
matched =  {:act :m1-blocked, :prev-act :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1356, :line 7}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1357, :line 8}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1358, :line 9}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :state [0 1 0 1 0 1 0 2], :job 1358, :line 10}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1360, :line 11}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1361, :line 12}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1356, :line 13}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1357, :line 14}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1358, :line 15}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1359, :line 16}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 2], :rate 1.0, :m :m1, :job 1361, :line 17}
matched =  {:M [0 0 1 1 0 1 0 2], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 2], :rate 1.0, :m :m1, :job 1362, :line 18}
matched =  {:M [0 1 0 1 0 1 1 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 2], :rate 1.0, :m :m3, :job 1357, :line 19}
matched =  {:M [1 1 0 1 0 0 1 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m3, :job 1358, :line 20}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1359, :line 21}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1360, :line 22}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1358, :line 23}
matched =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1359, :line 24}
matched =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1362, :line 25}
matched =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1363, :line 26}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1360, :line 27}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1361, :line 28}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1359, :line 29}
matched =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1360, :line 30}
matched =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1363, :line 31}
matched =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1364, :line 32}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1361, :line 33}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1362, :line 34}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1360, :line 35}
matched =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1361, :line 36}
matched =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1364, :line 37}
matched =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1365, :line 38}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1362, :line 39}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1363, :line 40}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1361, :line 41}
matched =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1362, :line 42}
matched =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1365, :line 43}
matched =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1366, :line 44}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1363, :line 45}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1364, :line 46}
matched =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1362, :line 47}
matched =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1363, :line 48}
matched =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1366, :line 49}
matched =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1367, :line 50}
matched =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1363, :line 51}
matched =  nil

*** It goes wrong very quickly!
**** good
start =    {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :indx 0, :job 1356}
matched =  {:M [0 1 0 0 1 1 2 0], :fire :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m2, :job 1357, :indx 1}
matched =  {:act :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 1 1], :state [0 1 0 1 0 1 1 1], :job 1357, :indx 2}
**** bad
start =    {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :line 0, :job 1356}
matched =  {:fire :m2-complete-job, :M [0 1 0 1 0 1 1 1], :Mp [0 1 0 0 1 1 1 1], :m :m2, :rate 1.0, :relax? :active, :line 0, :job 1356}
matched =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1357, :line 1}
matched =  {:exceptional :m1-unblocked, :prev-act :m2-start-job, :Mp [0 1 0 1 0 1 0 2], :state [0 1 0 1 0 1 0 2], :job 1357, :line 2}

The weird {:fire... comes from next-match (5), which is just saying that something is starting a job that we don't
know about because we are starting up. 


[
{:clk 1999.6152 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 0 :j 1356 :line 0}
{:clk 1999.6152 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1357 :line 1}
{:clk 1999.6152 :act :m1-unblocked :m :m1 :mjpact :ub :line 2}

;;; (5) If job not= current job but on :active-jobs and rgraph matches on that history,
;;;     no problem (add to interp with a note).

But why would 1357 be on active jobs? 

*** Reworking interpretation!
I added scada/active-jobs, and now I'm looking back at the link-match stuff wondering how
I decided to use loom! (There is nothing in the notes about this.) It says it relaxes
requirement to match rgraph. Why is this necessary?  This isn't going to work for colored PNs, I think. 

Do I have a test case for interpretation?  YES!

**** fitness-test/full-winner-process 
 I *think* that because I'm now using scada/active-jobs I'm picking up more message. 
 Testing that hypothesis....
 Nope! However:
gov.nist.sinet.fitness-test> (apply + (vals (:ordinary msg-table)))
2818
gov.nist.sinet.fitness-test> (apply + (vals (:ordinary old-msg-table)))
2818

***** I am temporarily living with a new msg-table and trans-count for testing. 
The new stuff *may* be better; *may* be worse. I'm adding a TODO to investigate it *later*. 

**** Back to the 3-machine case
Now all 4 starting links stop at line 51. Interesting!
First starved (:m3-starved) happens at line 52. Investigating fit/starved? ...  Check the output :Mp values for 

None of the interpretations have m3-starving at this point. This means it is stopping correctly
because the :Mp values for :place-14 should be 0. 

So either: 
  (1) The starting points aren't good (not all of them). 
  (2) Stepping through the rgraph is wrong.
  (3) ???

Some starting-points do have zero in place-14. (Not that after 51 steps that should matter). 
Will have to study *log* to see whether it looks funky. 

***** One bug in starved? fixed: The previous message has to agree on machine!
** <2018-01-07 Sun>

*** I verified with fitness_test that the starved? predicate didn't need/shouldn't have a machine test.
*** Commenting out loom code in link-match is not itself a solution. (Fails fitt/full-winner-process.)
 I am going to try a quick-and-dirty version of permutation path search on contemporary to see if I can get it to go. 
 BTW: Regarding last night's question about why I even used the loom code for interpretation, I think it was due to 
      the need for re-ordering of log messages (which is what I'm addressing with permutations). 

*** The use of loom might not have been for permutations.
It was for new jobs and early jobs that need to disappear?
Thus :relax? :add-job and :relax? :active.   

:relax? :add-job is executed twice. 

Q: What if I can get things to work without loom? Should I punt on this morning's work to do permutations?
A: I don't think permutations is going to be costly, provided original ordering is tried first. 
   I'll at least keep the code around for a while. 

*** I'm exploring the loom-based solution (see new notes in link-match) and the possibility of finessing things somewhat.

**** No even message lines except exceptional (which occur by themselves, others occur in twos). 
Ah, this is no big deal; it is just that the print statement needs to go elsewhere.

**** Infinite loop on :line 3000. Seems like it should be able to stop!
     This problem only occurs when the :Mp test on (3) and (5) is used. 

I think I'm finally beginning to understand transient/persistent! It seems it keeps track of what 
you are doing and produced an error : IllegalAccessError Transient used after persistent!

{:clk 2838.0093 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 3 :j 2399 :line 2998}
{:clk 2838.0093 :act :m1-unblocked :m :m1 :mjpact :ub :line 2999}
{:clk 2838.0093 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 2 :j 2402 :line 3000}
{:clk 2838.0093 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType1 :ends 2839.0093 :j 2403 :line 3001}

graph-link =  {:M [1 0 1 0 3], :fire :m2-start-job, :Mp [0 0 1 1 2], :rate 1.0, :m :m2, :job 2399, :clk 2838.0093, :line 2998}
graph-link =  {:M [0 0 1 1 2], :fire :m1-start-job, :Mp [0 1 0 1 3], :rate 1.0, :m :m1, :job 2403, :clk 2838.0093, :line 3001}

---> With the old code it just returns nil (doesn't get stuck). 

;;; Does this make sense? 

m =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1361, :clk 2007.6007, :line 41}
m =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job,    :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1362, :clk 2007.6007, :line 42}
m =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1365, :clk 2008.1152, :line 43}
m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1366, :clk 2008.1152, :line 44}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1363, :clk 2008.6152, :line 45}
m =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job,    :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1364, :clk 2008.6152, :line 46}
m =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1362, :clk 2009.1007, :line 47}
m =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job,    :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1363, :clk 2009.1007, :line 48}
m =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1366, :clk 2009.1152, :line 49}
m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1367, :clk 2009.1152, :line 50}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1363, :clk 2010.6007, :line 51}

If so, maybe new way of calculating start-links, based on k. 

*** I'm implementing a new way to create start-links. The old way was cheezy and not working.

**** I'm giving up on writing an analytical method, below
(defn all-marks-by-k
  "Return a vector of all states given k."
  [pn k]
  (let [pn (pnr/renumber-pids pn)
        machines (util/machines-of pn)
        pulls-from (zipmap machines (map #(util/pulls-from pn %) machines))
        related-places (util/related-places pn)
        mkey (:marking-key pn)
        n-machine-states (apply * (map #(count %) (vals related-places)))
        n-buffer-states (Math/pow (inc k) (count (util/buffers-of pn)))
        size (* n-machine-states (int n-buffer-states))
        ;; POD probably a silly implementation, but no sleep last night!
        states (mapv vec (repeat size (repeat (count mkey) :x)))]
    (reduce (fn [states [pos v]]



There are 4 starting links originally. There are 36 (half of rgraph!) in the new one. 

starting links =  
[{:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :line 0, :job 1356} 
 {:M [0 1 0 1 0 1 1 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 0], :rate 1.0, :line 0, :job 1356} 
 {:M [0 1 0 1 0 1 2 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :rate 1.0, :line 0, :job 1356} 
 {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 0], :rate 1.0, :line 0, :job 1356}]

**** All this old starting-links stuff gone:
;;; POD no test on index okay? 
(defn next-ordinary
  "Return the next ordinary message, at index n or later."
  [pn log n]
  (let [last-ix (-> log last :line)]
    (loop [indx n]
      (if (> indx last-ix)
        nil
        (if-let [msg (ordinary? (nth log indx))]
          msg
          (recur (inc indx)))))))

(defn next-paths
  "Extend or eliminate paths depending on the PN's reachability graph."
  [pn log paths msg-indx]
  (let [next-msg (next-ordinary pn log msg-indx)
        from (-> paths first last :Mp) ; current state along first path
        all-steps  (filter #(= (:M %) from) (:rgraph pn))
        good-steps (filter #(= (:fire %) (:act next-msg)) all-steps)   ; matches a msg
        good-steps (map #(assoc % :line (:line next-msg)) good-steps)] ; track where you found it.
    (if (empty? good-steps) ; This path is a dead end. 
      (rest paths)
      (into (mapv #(conj (first paths) %) good-steps) (rest paths))))) ; depth-first

(defn starting-links
  "Return all links (containing reference scada log line) that interpret 
   the SCADA log well from start-indx (usually 0)."
  [pn log start-indx & {:keys [diag-path]}]
  (let [rgraph (:rgraph pn)
        winners (atom [])]
    (loop [paths
           (or diag-path
               (mapv
                vector
                (mapv #(assoc % :line start-indx)
                      (filter #(= (:act (next-ordinary pn log start-indx))
                                  (:fire %))
                              rgraph))))]
      (let [new-paths (if (> (-> paths first count) 50)
                        (do
                          (swap! winners #(conj % (-> paths first first)))
                          (rest paths))
                        paths)]
        (when (not-empty new-paths) 
          (recur (next-paths pn log new-paths (-> new-paths first last :line inc))))))
    (let [job (:j (nth log start-indx))]
      (mapv #(assoc % :job job) @winners))))

**** Old starved?
#_(defn starved?
  "Return true if the argument machine (in msg) is starved."
  [llink msg pn]
  (let [^clojure.lang.PersistentVector mkey (:marking-key pn)]
    (let [bufs ((:m msg) (:pulls-from pn))]
      (if (= 0 (nth (:Mp llink)
                    (.indexOf mkey (first bufs))))
        true
        false))))


**** It looks like it never tries after the first iteration. 
***** Bug I'm using reduce where I should be iterating. 
                   (reduce (fn [pn start]
                             (if (full-interp? pn log)
                               pn
                               (interpret-scada pn log start)))
                           ?pn
                           (starting-links ?pn log))))
FIXED. 
**** Still no good, but this one looks wrong:
m =  {:M [1 1 0 1 0 0 0 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 0], :rate 1.0, :m :m3, :job 1363, :clk 2009.1007, :line 48}
m =  {:M [0 1 0 1 0 1 0 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 0], :rate 1.0, :m :m1, :job 1366, :clk 2009.1152, :line 49}
m =  {:M [0 0 1 1 0 1 0 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m1, :job 1367, :clk 2009.1152, :line 50}
m =  {:M [0 1 0 1 0 1 1 0], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 0], :rate 1.0, :m :m3, :job 1363, :clk 2010.6007, :line 51}
STARVED IS INCONSISTENT...................

I got it with this AM's algorithm. Do I get it with the straight one? 

m =  {:M [1 1 0 1 0 0 0 1], :fire :m3-start-job, :Mp [0 1 0 1 0 1 0 0], :rate 1.0, :m :m3, :job 1363, :clk 2009.1007, :line 48}
m =  {:M [0 1 0 1 0 1 0 0], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 0], :rate 1.0, :m :m1, :job 1366, :clk 2009.1152, :line 49}
m =  {:M [0 0 1 1 0 1 0 0], :fire :m1-start-job, :Mp [0 1 0 1 0 1 1 0], :rate 1.0, :m :m1, :job 1367, :clk 2009.1152, :line 50}
m =  {:M [0 1 0 1 0 1 1 0], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 0], :rate 1.0, :m :m3, :job 1363, :clk 2010.6007, :line 51}

typo in starved....
.... Still dead (not at line 307 regardless). (no better with AM's method). 
**** Next thing to do is look at the :n value of buffers in log at line 307. 

m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1404, :clk 2065.6827, :line 300}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :m :m2, :job 1401, :clk 2066.1827, :line 301}
m =  {:M [0 1 0 0 1 1 1 1], :fire :m2-start-job,    :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1402, :clk 2066.1827, :line 302}
m =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1400, :clk 2066.6153, :line 303}
m =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job,    :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1401, :clk 2066.6153, :line 304}
m =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1404, :clk 2067.1827, :line 305}
m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1405, :clk 2067.1827, :line 306}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1401, :clk 2067.6153, :line 307}
STARVED IS INCONSISTENT...................
llink =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1401, :clk 2067.6153, :line 307}
msg =  {:clk 2067.6153, :act :m3-starved, :m :m3, :mjpact :st, :line 308}
marking-key =  [:place-1 :place-2 :place-3 :place-4 :place-5 :place-6 :Place-13 :Place-14]
buf =  :Place-14
...................

- 304: m3 starts a job with at 304 with one in the buffer, leaving none in the buffer. 
- 307: m3 finishes job. Yup, it's legit. 
- 307: Yup, it's legit. 
- 301: THIS looks wrong. :m2-complete-job doesn't result in addition to :place-14. 
  But that is what the PN does. It doesn't add the token until m2-start-job. Since there
  is nothing in :Place-13, it isn't happening. 


{:clk 2066.1827 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 0 :j 1401 :line 301}
{:clk 2066.1827 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1402 :line 302}
{:clk 2066.6153 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2056.0373 :j 1400 :line 303}
{:clk 2066.6153 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 1 :j 1401 :line 304}
{:clk 2067.1827 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1404 :line 305}
{:clk 2067.1827 :act :m1-start-job :m :m1 :mjpact :aj :jt :jobType1 :ends 2068.1827 :j 1405 :line 306}
{:clk 2067.6153 :act :m3-complete-job :m :m3 :mjpact :ej :ent 2057.0373 :j 1401 :line 307}
{:clk 2067.6153 :act :m3-starved :m :m3 :mjpact :st :line 308}

*** hopeful-pn-2 is not good enough. m3-for-causal.jpg would work, but it is too complicated.
hopeful-pn-3 is hopeful-pn-2 with one arc moved:
Move arc from [:m2-start-job :Place-14] to [:m2-end-job :Place-14]

*** code: tryme for 2-machine / hope-pn testcase (also in fitness_test.clj)
(declare find-interpretation compute-msg-table)
(defn tryme []
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        hopeful-pn (-> (load-file "data/PNs/hopeful-pn.clj")
                       (assoc :pulls-from {:m1 [], :m2 [:Place-103]}))
        patterns (scada/scada-patterns log)
        msg-types (conj (scada/exceptional-msgs patterns log) :ordinary)
        pn (find-interpretation hopeful-pn log 3 3)]
    (compute-msg-table pn msg-types)))

(def diag-start-link {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 1], :rate 1.0, :line 0, :job 1356})
      

**** Thus far, hopeful-pn-3 didn't solve anything. 

m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1404, :clk 2065.6827, :line 300}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 1 2], :rate 1.0, :m :m2, :job 1401, :clk 2066.1827, :line 301}
m =  {:M [0 1 0 0 1 1 1 2], :fire :m2-start-job,    :Mp [0 1 0 1 0 1 0 2], :rate 1.0, :m :m2, :job 1402, :clk 2066.1827, :line 302}
m =  {:M [0 1 0 1 0 1 0 2], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 0 2], :rate 1.0, :m :m3, :job 1400, :clk 2066.6153, :line 303}
m =  {:M [1 1 0 1 0 0 0 2], :fire :m3-start-job,    :Mp [0 1 0 1 0 1 0 1], :rate 1.0, :m :m3, :job 1401, :clk 2066.6153, :line 304}
m =  {:M [0 1 0 1 0 1 0 1], :fire :m1-complete-job, :Mp [0 0 1 1 0 1 0 1], :rate 1.0, :m :m1, :job 1404, :clk 2067.1827, :line 305}
m =  {:M [0 0 1 1 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 1 0 1 1 1], :rate 1.0, :m :m1, :job 1405, :clk 2067.1827, :line 306}
m =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1401, :clk 2067.6153, :line 307}
STARVED IS INCONSISTENT...................
llink =  {:M [0 1 0 1 0 1 1 1], :fire :m3-complete-job, :Mp [1 1 0 1 0 0 1 1], :rate 1.0, :m :m3, :job 1401, :clk 2067.6153, :line 307}
msg =  {:clk 2067.6153, :act :m3-starved, :m :m3, :mjpact :st, :line 308}
marking-key =  [:place-1 :place-2 :place-3 :place-4 :place-5 :place-6 :Place-13 :Place-14]
buf =  :Place-14

- 301 :m2-complete-job now does indeed result in a part in the buffer earlier BUT THIS ISN'T HELPFUL! After all, 
  things are as there were before, except that for 1 additional link the buffer is correct. 
  The buffer has too much, not too little!

**** Next thing, write some code to put buffer occupancies in the message, so for diagnostics you can test them against markers.
(def pnpn1 (-> (load-file "data/PNs/hopeful-pn-3.clj")
               (assoc :pulls-from {:m1 [], :m2 [:Place-13], :m3 [:Place-14]})
               (assoc :place-map {:b1 :Place-13 :b2 :Place-14})
               (assoc :start-occupy {:Place-13 2 :Place-14 0})))

** <2018-01-08 Mon>

I'm writing the diagnostic stuff.

*** code: weirdness in contemp-search

  (if (:last-link pn) ; POD makes no sense to me that this doesn't work!
    (next-match-contemp-2 pn msg)
    pn)
  #_(if (:failed? pn) 
      pn
      (if (not (:last-link pn))
        (assoc! pn :failed? true)
        (next-match-contemp-2 pn msg))))

*** code: the Sunday AM project to try all permutations of contemporary messages

;;;========start====================================================
(defn next-match-contemp-2
  "next-match msg and update pn."
  [pn msg]
  (let [match-info (next-match pn msg)]
    (let [matched (dissoc (:matched match-info) :rate-fn)
          line (:line matched)]
      (println "m = " matched)
      (-> pn ; update! would be nice here!
          (assoc! :active-jobs (:active-jobs match-info))
          (assoc! :graph-link (:graph-link match-info))
          (assoc! :interp (conj! (:interp pn) matched))
          (assoc! :last-link matched)))))

(defn order-buf
  "Return a vector of messages ordered according to the 
   argument vector ORDER, which contains line numbers."
  [buf order]
  (let [result (mapv (fn [line-num] (some #(when (== (:line %) line-num) %) buf)) order)]
    (when-not (every? identity result) (ex-info "order-buf" {:order order}))
    result))

(defn contemp-search
  "Look for a path through the contemporary messages;
   when one is found, update pn appropriately."
  [pn]
  (let [pn (persistent! pn)
        mutes (combo/permutations (map :line (:msg-buf pn)))]
    (loop [order mutes]
      (let [msgs (order-buf (:msg-buf pn) (first order))
            result (reduce (fn [pn msg]
                             (if (:last-link pn) ; POD makes no sense to me that this doesn't work!
                               (next-match-contemp-2 pn msg)
                               pn)
                             #_(if (:failed? pn) 
                                 pn
                                 (if (not (:last-link pn))
                                   (assoc! pn :failed? true)
                                   (next-match-contemp-2 pn msg))))
                           (transient pn)
                           msgs)]
        (cond (:last-link result)    (assoc! result :msg-buf []),
              (empty? (rest order))  (assoc! result :last-link nil),
              true (recur (vec (rest order))))))))
;;;=======end=====================================================


*** code: workflow fitness !!!

;;;===========================================
;;; Fitness measure
;;;===========================================
(defn act2trans
  "Return the transition (its name) responsible for the argument act."
  [pn act]
  (some #(when (= act (-> % :rep :act)) (:name %))
        (:transitions pn)))

(defn violates?
  "Return true if the qpn-job violates the argument relation."
  [qpn-job relation]
  (not (relation qpn-job)))

(defn avg-scada-process-steps
  "Calculate the weighted average number of steps in a SCADA pattern."
  [patterns]
  (let [npat (count patterns)]
    (when (zero? npat)
      (throw (ex-info "Insufficient data to find a pattern" {})))
    (let [njobs (apply + (map #(:njobs %) patterns))]
      (/ (apply + (map #(* (/ (:njobs %) njobs) (count (:form %))) patterns))
         npat))))

;;; +1 for every precedence constraint violated. +1 for each act not manifest in the QPN log. 
;;; Will need something more for loops, but we'll get to that later.
(defn calc-process-disorder
  "For a single QPN job-trace, return a map {:score <> :pattern-id <>} indicating the 
   score and pattern-id from the best matching SCADA patterns. Note that in assembly lines,
   there is only one SCADA pattern."
  [job-trace patterns]
  (loop [pats patterns
         best {:score 99999 :pattern-id -1}]
    (let [pat (first pats)
          ;; How many of the pattern actions are represented in this QPN trace?
          ;; POD Should this also consider acts in the qpn job trace but not in the pattern?
          nact-diff (Math/abs (- (count job-trace)
                                 (count (set/intersection (set (map :act (:form pat)))
                                                          (set (map :act job-trace))))))
          nviolates (reduce (fn [score rel] (if (violates? job-trace rel) (inc score) score))
                            0
                            (:relations pat))
          this-score (+ nact-diff nviolates) ; POD Add here to force failure.
          best  (if (< this-score (:score best))
                  {:score this-score :pattern-id (:id pat)}
                  best)]
      (cond (== this-score 0) {:score 0 :pattern-id (:id pat)}
            (empty? (next pats)) best
            true (recur (next pats) best)))))

(defn trunc-qpn-log-at-cycle
  "Return a log that stops when it sees the same message a second time on the same job."
  [qpn-log]
  (loop [log qpn-log
         short-log []]
    (let [msg (first log)]
      (if (or (empty? log) (some #(= msg %) short-log))
        short-log
        (recur (next log) (conj short-log msg))))))

;;; SCADA log processes produces multiple patterns. There is one pattern per colour for
;;; a transfer/flow or assembly line. Associated with each colour-tagged
;;; pattern are sojourn times and breakdown/repair rates. (POD, that is a ToDo!)
;;; workflow-fitness looks at a range (tkn-range) of qpn jobs, finding the error in each relative
;;; to the (typically one) SCADA log pattern, producing the average error relative to this pattern.

;;; What is the GP doing?
;;;   1) It is finding a PN that best matches the log. That PN has colour. SCADA logs
;;;      also have colour. The PNs could have multiple paths for different job types or
;;;      could combine paths where that makes more sense. 

;;; The individuals have to cope with all job types. I will keep scores on how well
;;; the PN does against each SCADA job type (colour). Then I can use crossover to combine
;;; the best of multiple colour paths. (One Inv does well on blue, another does well on red...)
;;; Maybe the GP is two-phase, where the first phase optimises for individual colours (no crossover)
;;; and the second phase predominantly does crossover on these individuals. Maybe they aren't
;;; so much phases as a function that increases the portion of crossovers as the colour-wise
;;; scores increase. Early on, perhaps scoring is about being good at one color, and later about
;;; being good at all of them. Maybe in addition to increasing cross-over, I penalize more for
;;; not handling multiple types (and do this by weighting, according to the proportion of each job
;;; type seen).

;;; So that's all good, but what do I mean by "does well on blue" etc.? With the SCADA log
;;; I'll have information about workstation reliability, colour of jobs, and time spent on
;;; at each workstation. I can keep patterns for each color. Indeed, it is not even necessary
;;; that something is reported at each workstation -- some workstations in the line could
;;; "disappear" and there would be a different section of path for some color where this occurs.
;;; I don't think there is a challenge here except in finding buffer sizes. Maybe that is a good
;;; thing. Do the ANN on the buffer size and be done with it. (BTW, maybe there are similar
;;; problems such as not having sufficient carriers, etc.)

;;; A problem here is that I don't have anything in the GP fitness measurement currently that
;;; would encourage the introduction of inhibitor arcs (and their multiplicity) as means of
;;; specifying buffer capacity. Should I just explicitly edit the PN according to the results
;;; of the ANN classification? (And how exactly do you I get the ANN to tell me that it is
;;; focusing on the quantity of tokens in place x?) [2017-10-07 That should not be hard.]

;;; The steady-state and dynamic analyses are looking more and more like validation activities.
;;; Maybe I translate to DES to do these. (Do I feed back the results? How? What?)

;;; A potentially negative aspect of the above is that it may completely separates jobs of
;;; different types. Can this be fixed with flexible cross-over? For example, I could 
;;; make some part of the red/blue, another part of the path separate red and blue. 


;;; (workflow-fitness (:pn i1) (:scada-patterns +problem+)) ; i1 is in the file data/test-m2-bas.clj
;;; Problem here is to run enough steps to get enough jobs to be able to trim some.
;;; POD Note that this treats jobs that return to workstation as damaged. 
(defn workflow-fitness
  "Generate a QPN log for the PN and return the score WRT SCADA patterns. The disorder score is the
   average (across a range of complete QPN jobs) of the process disorder of the best matched process.
   If there are very few jobs (perhaps because :elim :intro weirdness), then just score them.
   The total disorder score is number of violations of event orderings."
  [inv]
  (handling-evolve [inv]
    (let [patterns (-> (util/app-info) :problem :scada-patterns)
          pn (sim/simulate (:pn inv) :max-steps (* 50 (avg-scada-process-steps patterns)))
          max-tkn (-> pn :sim :max-tkn) ; max-tkn is number of tokens generated by sim.
          warm-up (-> (util/app-info) :gp-params :aqpn-warm-up)
          disorder ;; Calculate disorder
          (if (> max-tkn 20)
            (let [tkn-range (range warm-up (- (-> pn :sim :max-tkn) warm-up))
                  sum-error (reduce (fn [sum tkn-id] ; sum disorder on simulation job.
                                      ;; POD I am not using :pattern-id yet. Needs thought. 
                                      (+ sum (:score (calc-process-disorder (qpn-log-about pn tkn-id) patterns))))
                                    0
                                    tkn-range)]
              ;; Average over all the jobs. 
              (double (/ sum-error (count tkn-range))))
            ;; Otherwise at most just a few jobs. It is either not eliminating jobs-ids, or 
            ;; not even creating a log. 
            (let [tkn-id (max (Math/round (/ (-> pn :sim :max-tkn) 2.0)) 1)
                  qpn-log (qpn-log-about pn tkn-id)]
              (+ (-> (util/app-info) :gp-params :no-new-jobs-penalty)
                 (if (empty? qpn-log)
                   (-> (util/app-info) :gp-params :no-qpn-log-penalty)
                   (:score (calc-process-disorder
                            (trunc-qpn-log-at-cycle qpn-log)
                            patterns))))))]
      (assoc inv :disorder disorder))))



*** code: workflow fitness testing !!!
 
#_(load-file "data/SCADA-logs/scada-f0.clj") ; defines fit/scada-log-f0
#_(load-file "data/test-individuals/test-m2-bas.clj") ; defines (in .gp) test-m2-bas individual (a perfect individual for scada-log-f0)
#_(load-file "data/QPN-logs/qpn-m2-bas.clj") ; defines fit/qpn-m2-bas (a log for the perfect individual above)

#_(deftest scada-pattern-disorder
  (testing "scada-pattern-generation-and-qpn-disorder"
    (let [pats (as-> (:log fit/scada-log-f0) ?pats
                 (fit/scada-patterns ?pats)
                 (map #(dissoc % :jobs) ?pats))]
      (is (= (count pats) 1))
      (is (= (dissoc (first pats) :relations)
             {:id 3, :form
              [{:act :aj, :jt \*}
               {:act :bj, :bf \*, :n \*}
               {:act :sm, :bf \*, :n \*}
             {:act :ej, :m \*}]}))
      (is (= 0
             (fit/calc-process-disorder (fit/qpn-log-about gp/test-m2-bas 22) 22)
             gp/test-m2-bas ; pod I'm guessing
              (first pats)
              22
              (fit/qpn-gather-tkn fit/qpn-m2-bas 22)))
      (is (= 1
             (fit/calc-process-disorder
              gp/test-m2-bas
              (first pats)
              22
              [{:act :bj, :tkns [{:type :a, :id 22}]}
               {:act :aj, :tkns [{:type :a, :id 21} {:type :a, :id 22}]}
               {:act :aj, :tkns [{:type :a, :id 23} {:type :a, :id 22}]}
               {:act :sm, :tkns [{:type :a, :id 22}]}
               {:act :ej, :tkns [{:type :a, :id 22}]}])))
      (is (= 4
             (fit/calc-process-disorder
              gp/test-m2-bas
              (first pats)
              22
              [{:act :ej, :tkns [{:type :a, :id 22}]}
               {:act :bj, :tkns [{:type :a, :id 22}]}
               {:act :aj, :tkns [{:type :a, :id 21} {:type :a, :id 22}]}
               {:act :aj, :tkns [{:type :a, :id 23} {:type :a, :id 22}]}
               {:act :sm, :tkns [{:type :a, :id 22}]}]))))))

(defn m2-inhib-bas-workflow-fit
  "Setup the m2-inhib-bas PN for a fitness test"
  [steps]    
  (let [pn (-> "data/PNs/m2-inhib-bas.xml" 
               spn/run-ready
               gp/add-color-binding
               (gp/diag-force-priority [{:source :m1-start-job, :target :buffer :priority 2}])
               (sim/simulate :max-steps steps))]
    (fit/workflow-fitness (map->Inv {:pn pn}))))

(deftest perfect-fitness-scores-zero
  (testing "That a PN matching the log scores zero."
    (is true (=* 0.0 (:disorder (m2-inhib-bas-workflow-fit 200)) 0.01))))



;;;(alias 'gp 'gov.nist.sinet.gp)
;;;;(alias 'scada 'gov.nist.sinet.scada)
;;; These are useful to understanding how things work. 
;;; This one for an Eden INV:
#_(def eee
    (let [pn (->> (scada/random-job-trace)
                  (gp/initial-individual-pn))]
      (-> (gp/map->Inv {:pn pn})
           gp/add-scada-report-fns
           gp/add-color-binding
          (update :pn
                  (fn [pn]
                    (reduce (fn [pn trans] (gp/assign-flow-priorities pn trans))
                            pn
                            (->> pn :transitions (map :name))))))))

;;; This one to show it on the client: (not working; I don't know why.)
#_(-> eee
      gp/clean-inv-for-transmit
      gp/diag-push-pn)

;;; This one for a typical-job:
;;;(def jjj (-> eee :pn (sim/simulate :max-steps 50) (fit/qpn-log-about 1) trunc-qpn-log-at-cycle))
;;; ==> 
;;;[{:tkns [{:jtype :blue, :id 1}], :rep {:name :m1-start-job, :act :aj, :m :m1}}
;;; {:tkns [{:jtype :blue, :id 1}], :rep {:name :m1-complete-job, :act :bj, :m :m1, :bf :b1}}
;;; {:tkns [{:jtype :blue, :id 1}], :rep {:name :m2-start-job, :act :sm, :m :m2, :bf :b1}}
;;; {:tkns [{:jtype :blue, :id 1}], :rep {:name :m2-complete-job, :act :ej, :m :m2}}]

;;; This one (finally!) to calculate job disorder:
;;; (calc-process-disorder jjj (-> (util/app-info) :problem :scada-patterns))
;;; ==> 0 (but of course it is going to get hit for not introducing a new token.

#_(defn diag-one-that-runs
  "Return the first PN that can generate at least modest amount of log!"
  []
  (some #(let [pn (sim/simulate (:pn %) :max-steps 100)]
           (when (> (-> pn :sim :log count) 20) %))
        (-> (util/app-info) :pop)))

;;; POD NYI    
#_(defn diag-process-disorder
  "Report how messed up this PN is." 
  [inv]
  (let [patterns (-> (app-info) :problem :scada-patterns)
        sim (-> inv :pn (sim/simulate :max-steps (* 50 (avg-scada-process-steps patterns))))]))

;;; This needs to be commented out. (load order)
#_(defn m2-inhib-bas
  "Setup the m2-inhib-bas PN for a fitness test"
  [steps]
  (let [pn (-> "data/PNs/m2-inhib-bas.xml" 
               gov.nist.spntools.core/run-ready
               gp/add-color-binding
               (gp/diag-force-priority [{:source :m1-start-job, :target :buffer :priority 2}])
               #_(sim/simulate :max-steps steps))]
    #_(workflow-fitness (util/map->Inv {:pn pn}))
    pn))


*** code: fitness_test fixture

;;; POD Better than this would be to use the new MJPdes output directly. (Don't mess with app-info.)
#_(defn problem-setting-fixture
  "Set the 'problem' (the log we look at) to the m2-inhib-bas problem."
  [f]
  (let [orig-scada (-> (app-info) :problem :scada-data-file)]
    (swap! app/problem #(assoc % :scada-data-file "data/SCADA-logs/scada-m2-inhib-bas.clj"))
    (util/big-reset) ;; POD need something less extreme than this! stop and start app!
    (f) ; The canonical fixture function, in this case called using the 'once' procedure
    (swap! app/problem #(assoc % :scada-data-file orig-scada))
    (util/big-reset)))

#_(use-fixtures :once problem-setting-fixture)


*** code: scada ordering relations
(defn ordering-fn
  "Return a function : trace -> boolean indicating whether the ordering relationship 
   is violated by the argument QPN process trace. If one or both of the arguments 
   does not even appear in the trace, it is considered violated."
  [x y]
  (fn [trace]
    (let [pos-x (pos-in-trace trace x)
          pos-y (pos-in-trace trace y)]
      (if (and pos-x pos-y)
        (<= (pos-in-trace trace x) (pos-in-trace trace y))
        true))))

(defn scada-ordering-relations
  "Calculate ordering functions for a SCADA pattern."
  [p]
  (loop [events (:form p)
         ordering []]
    (if (empty? (rest events))
      ordering
      (recur
       (next events)
       (into ordering
             (reduce (fn [m s] (conj m (ordering-fn (:act (first events)) (:act s))))
                     []
                     (rest events)))))))

(defn pos-in-trace
  "Return the position of the argument action in the argument QPN process trace."
  [trace act]
  (let [^clojure.lang.PersistentVector acts (vec (map :act trace))
        idx (.indexOf acts act)]
    (if (< idx 0) false idx)))




*** A graph of calls

 find-interpretation ==> interpret-scada ==>  next-match-contemp            ==> next-match        ==> diag-update-occupy
                                             - move mathch-info to pn     - creates match-info        - update occupy map
                                                                          - fails on starve            

                                                                             link-match   
                                                                          -  add occupy info
*** Looking at the problem starting

I think I should looking at log line 1, not 0. 0 is the start-link.
start =  {:M [0 0 1 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 0 1 0 1 1 2 1], :line 0, :occupy {:Place-13 2, :Place-14 0}}
m =  {:M [0 0 1 1 0 1 1 1], :Mp [0 0 1 0 1 1 1 2], :fire :m2-complete-job, :line 0, :occupy {:Place-13 2, :Place-14 1}, :relax? :active}

--> Done. No better, (worse) but it make sense.

start =  {:M [0 0 1 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 0 1 0 1 1 2 1], :line 0, :occupy {:Place-13 2, :Place-14 0}}
m =  {:M [0 0 1 0 1 1 2 1], :Mp [0 0 1 1 0 1 1 1], :fire :m2-start-job, :line 1, :occupy {:Place-13 1, :Place-14 0}}
=======>  Occupancy wrong on  :Place-13

The diag looks wrong. In processing the llink :m2-complete-job, I should add to buffer :b2, instead this shows removing from :b1

According to the log, we want to start at 

<2018-01-09 Tue>

I only wrote the crossed? code in client/draw.clj I read Semyon's paper.

<2018-01-10 Wed>

I am picking up on the diag-update-occupy and the interpretation work (that has dragged on for two weeks now!) 


start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :line 0, :occupy {:Place-13 2, :Place-14 0}}
    m =  {:M [0 1 0 0 1 1 2 1], :Mp [0 1 0 1 0 1 1 1], :fire :m2-start-job, :line 1, :occupy {:Place-13 1, :Place-14 0}}

Need :Place-14 = 1 to account for the first complete job. As below:

(def pnpn1 (-> (load-file "data/PNs/hopeful-pn-3.clj")
                                       reasonably-marked-pn
                                       (assoc :pulls-from {:m1 [], :m2 [:Place-13], :m3 [:Place-14]})
                                       (assoc :place-map {:b1 :Place-13 :b2 :Place-14})
                                       (assoc :start-occupy {:Place-13 2 :Place-14 1})))

Now it looks like I am keeping the link :Mp in-sync with :occupy. 

start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :line 0, :occupy {:Place-13 2, :Place-14 1}}
m =  {:M [0 1 0 0 1 1 2 1], :Mp [0 1 0 1 0 1 1 1], :fire :m2-start-job, :line 1, :occupy {:Place-13 1, :Place-14 1}}
m =  {:Mp [0 1 0 1 0 1 1 1], :act :m1-unblocked, :exceptional true, :line 2, :occupy {:Place-13 1, :Place-14 1}, :prev-act :m2-start-job, :state [0 1 0 1 0 1 1 1]}
m =  {:M [0 1 0 1 0 1 1 1], :Mp [0 0 1 1 0 1 1 1], :fire :m1-complete-job, :line 3, :occupy {:Place-13 2, :Place-14 1}}
=======>  Occupancy wrong on  :Place-13
m =  {:M [0 0 1 1 0 1 1 1], :Mp [0 1 0 1 0 1 2 1], :fire :m1-start-job, :line 4, :occupy {:Place-13 2, :Place-14 1}}

This looks interesting. :m2-complete-job result in an update but :m1-complete-job does not. 

start =  {:M [0 1 0 1 0 1 2 0], :fire :m2-complete-job, :Mp [0 1 0 0 1 1 2 1], :line 0, :occupy {:Place-13 2, :Place-14 1}}
m = {:M [0 1 0 0 1 1 2 1], :Mp [0 1 0 1 0 1 1 1], :fire :m2-start-job, :line 1, :occupy {:Place-13 1, :Place-14 1}}
m = {:Mp [0 1 0 1 0 1 1 1], :act :m1-unblocked, :exceptional true, :line 2, :occupy {:Place-13 1, :Place-14 1}, :prev-act :m2-start-job, :state [0 1 0 1 0 1 1 1]}
m = {:M [0 1 0 1 0 1 1 1], :Mp [0 0 1 1 0 1 1 1], :fire :m1-complete-job, :line 3, :occupy {:Place-13 2, :Place-14 1}}
=======>  Occupancy wrong on  :Place-13

It makes sense because :m2 connects directly to the buffer whereas :m1 does not. 
The problem is with diag-update-occupy; In asserting that work moves to buffers 
when it is complete, we assume too much. In fact, the machine could be blocked, as 
it is here. Even if not blocked, there is the infinitessimal small period where 
it goes through the blocked state. For the time being, I'll live with this. 

**** The problem starting at line 32
m =  {:M [0 0 1 1 0 1 1 2], :Mp [0 1 0 1 0 1 2 2], :fire :m1-start-job, :line 32, :occupy {:Place-13 3, :Place-14 2}}

Failed on msg block: 
    {:clk 2005.6152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1361, :line 33}
    {:clk 2005.6152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1362, :line 34}

diag-update-occupy, despite all the work that went into it, is of limited value. 
There still remains the task of understanding what is going on here.
Even with :b1 set to 0, it runs up the buffer to where if fails on 

[:place-1 :place-2 :place-3 :place-4 :place-5 :place-6 :Place-13 :Place-14]
{:M [0 0 1 1 0 1 1 2], :Mp [0 1 0 1 0 1 2 2], :fire :m1-start-job, :line 32, :occupy {:Place-13 1, :Place-14 2}}

:M :m1 is not busy, :Mp :m1 is busy 
   :m1 is busy          :m2 is busy added to :b1. Okay. 

Failed on msg block: 
    {:clk 2005.6152, :act :m2-complete-job, :m :m2, :mjpact :bj, :bf :b2, :n 0, :j 1361, :line 33}
    {:clk 2005.6152, :act :m2-start-job, :m :m2, :mjpact :sm, :bf :b1, :n 2, :j 1362, :line 34}

Simple: m2 can't complete the job because the buffer is full. :line 34 is not possible yet. 

Something must be very wrong because the log message says
{:clk 2005.6152 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 0 :j 1361 :line 33}

**** Now with :bufs

I don't understand the MJP output here at all! m3 completes a job, 2 jobs in its input buffer.
It starts one of those jobs; there is STILL 2 jobs in the buffer.
m2 unblocks. WHY? There are STILL 2 jobs in the buffer!

{:clk 1999.7179 :act :m3-complete-job :m :m3 :mjpact :ej :ent 1990.4389 :j 1323 :bufs {:b1 1, :b2 2} :line 0}
{:clk 1999.7179 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1324 :bufs {:b1 1, :b2 2} :line 1}
{:clk 1999.7179 :act :m2-unblocked :m :m2 :mjpact :ub :bufs {:b1 1, :b2 2} :line 2}
{:clk 1999.7179 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1326 :bufs {:b1 1, :b2 1} :line 3}

** <2018-01-11 Thu>

I'm continuing with MJPdes inspection, now with names of job running and in buffers.

{:clk 1999.8745 :act :m3-complete-job :m :m3 :mjpact :ej :ent 1990.8793 :j 1307 
 :dets {:run {:m1 1313, :m2 1310, :m3 1307}, :bufs {:b1 [1311 1312], :b2 [1308 1309]}} :line 0}

{:clk 1999.8745 :act :m3-start-job :m :m3 :mjpact :sm :bf :b2 :n 2 :j 1308 
 :dets {:run {:m1 1313, :m2 1310, :m3 nil},  :bufs {:b1 [1311 1312], :b2 [1308 1309]}} :line 1}

{:clk 2000.8233 :act :m1-blocked :m :m1 :mjpact :bl 
 :dets {:run {:m1 1313, :m2 1310, :m3 1308}, :bufs {:b1 [1311 1312], :b2 [1309]}} :line 2}

**** As line 1 shows, when :m3-start-job j=1308, run=nil, and buf1=1308. <================
**** In line 2 (m1 blocked) 1308 is out of the buffer and on the machine. 

{:clk 2001.3233 :act :m2-complete-job :m :m2 :mjpact :bj :bf :b2 :n 1 :j 1310 
 :dets {:run {:m1 1313, :m2 1310, :m3 1308}, :bufs {:b1 [1311 1312], :b2 [1309]}} :line 3}

{:clk 2001.3233 :act :m2-start-job :m :m2 :mjpact :sm :bf :b1 :n 2 :j 1311 
 :dets {:run {:m1 1313, :m2 nil, :m3 1308}, :bufs {:b1 [1311 1312], :b2 [1309 1310]}} :line 4}

{:clk 2001.3233 :act :m1-unblocked :m :m1 :mjpact :ub 
 :dets {:run {:m1 nil, :m2 1311, :m3 1308}, :bufs {:b1 [1312 1313], :b2 [1309 1310]}} :line 5}

{:clk 2001.3233 :act :m1-complete-job :m :m1 :mjpact :bj :bf :b1 :n 1 :j 1313 
 :dets {:run {:m1 1313, :m2 1311, :m3 1308}, :bufs {:b1 [1312], :b2 [1309 1310]}} :line 6}



** <2018-01-12 Fri>

I am continuing to refactor intepretation with the view of stepping through the interpretation. 


#_(def pnpn1 (-> (load-file "data/PNs/hopeful-pn-3.clj")
               reasonably-marked-pn
	       (lax-reach 2)
               (assoc :pulls-from {:m1 [], :m2 [:Place-13], :m3 [:Place-14]})
               (assoc :place-map {:b1 :Place-13 :b2 :Place-14})
               (assoc :start-occupy {:Place-13 2 :Place-14 2})))



*** Rampage!
    (loop [pn (prep-interp pn log start-link)]
      (let [pn (cond-> pn 
                 (empty? (:msg-buf pn))
                 (assoc! :msg-buf (contemp-msgs
                                   log
                                   (next-time-line log (-> pn :last-link :line)))),
                 true (match-contemp-block))]
        (cond (not (:last-link pn))
              (-> pn ; failure
                  (assoc! :interp [])
                  (dissoc! :loom-steps #_:rgraph)
                  persistent!)
              (> (-> pn :last-link :line inc) last-indx)
              (-> pn ; success
                  (assoc! :interp (persistent! (:interp pn)))
                  (dissoc! :msg-buf :active-jobs :graph-link :loom-steps)
                  persistent!)
              true   ; continue
              (recur pn))))))

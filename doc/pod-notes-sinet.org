* Org Mode Tasks
** DONE Start using org for programming notes.
   CLOSED: [2017-10-14 Sat 18:06]
** DONE Learn how to 'open' and edit a link. Right now the org manual link is just the URL. 
   CLOSED: [2017-10-15 Sun 12:25]
** TODO Find out what good the source code marking is. I see that you can edit it with C-c ' but so what?

* Notes on org mode
** Useful Links
*** The tutorial 
 [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][The tutorial]]
 http://orgmode.org/manual/index.html
    
** Key bindings 
*** Opening and closing
**** Cntl-tab open/close at point
**** Shift-tab open/close whole document (circular)
**** Shift-cntl open/close current
*** Linking
**** C-c l (store link)
**** C-c C-l bring the link here
**** C-c C-l also to edit a link (when point is on the link)
**** Links look like this: [[link][description] ...] 
  Here I inserted elipsis to stop that from turning into a link. An actual 
  link to a web page would appear like this: [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][the tutorial]]. 
**** C-c C-o (open) open a link without the mouse.   
    This is especially sweet for local links. It splits showing two buffers. 

*** TODO Operations
**** M-Shift-Ret open a TODO.

**** C-c C-t (terminate?) marks a TODO as done.
*** Miscellaneous
**** Timestamps C-c . (C-c ! is similar but 'without creating an agenda entry' whatever that means.)

**** Source Code C-c ' (open and close) #+BEGIN_SRC clojure ... #+END_SRC


* Sinet TODOs
** DONE Try a more mild blocking situation.
   CLOSED: [2017-10-23 Mon 19:05]
** DONE Fix bug in pnr/simple-reach. See bug <2017-10-15 Sun>
   CLOSED: [2017-10-15 Sun 18:13]
** TODO Consider the possibility/advantages of an 'abbreviated' reachability graph. 
** TODO Decide whether setting all transitions to timed makes sense for simple-reach. See discussion <2017-10-15 Sun>
** TODO Investigate possible bugs with MJPdes 'coordination' and create more 'deterministic' test cases.
** TODO Conceive of a strategy for using exceptional fitness
 [I think I missed the whole point in the stuff below, but just to be sure: There are messages that
  are not associated with transitions. They are associated with STATES. I may have a place in the network
  that is essentially "M1-BLOCKED" but it won't be labelled as such! A nice thing about this is that 
  I DON'T WANT to get a M1-BLOCKED message every (vanishing) time that there is a token in that place.
  I only want these when the buffer is filled (a state where the buffer place looms large). That's what 
  will happen, and we don't have to worry about labeling the "m1-blocked" place!]

 In some cases like blocking/starving it seem that having a place represent the state is appropriate. 
 But is that generally the case? This ToDo is closely related to the next about vanishing transitions,
 but I don't think it is the same issue. I think I need to see the result of the "mild blocking" 
 situation before I can sort this out. Remember that the goal is to get rates out of these things. 

 (More on this): I think there might be quirk to what I'm trying to do: I'd like to allow the PN to handle 
 exceptional messages just as some do for block/starve, but block/starve are places, not transitions, and 
 they won't have meaningful names. I think I'll just wait to explore this after getting the exceptional 
 fitness hooked in. 

** TODO Deal with vanishing transitions. 
 I need to generate blocking/starving messages ONLY when the net sojourns at blocking/starving. 
 So simulation has to be better and I need to distinguish these immediate transitions some how. 

** TODO Find a way to find the pathname "to a namespace" so I can run tests on dependent packages. 
** DONE Create a project for simple neural nets. Sinet log date <2017-10-23 Mon> has some code for it. 
   CLOSED: [2017-11-01 Wed 19:53]

** DONE Fix MJPdes as described in log <2017-10-17 Tue>
   CLOSED: [2017-10-22 Sun 14:25]
** TODO Rewrite disorder code to use rgraph.

** TODO Need a way to get the world after a time out. 
** TODO Does the :pop really need to be on app-info?
** TODO Every arc needs a :bind and :priority  <----------------------------SOON
* Agenda for the next week:
** Consider more forgiving simple-reach -- one which moves tokens around. (Maybe remove add-token remove-token from GP).
** Integrate exceptional fitness, try using it to place buffer limits.
    In addition to adding an inhibitor with multiplicity, may need to attach functions that
    will emit messages on exceptional events.
** Add individuals that represent machine activity???
   Add genetic operators that combine machine perspective with job perspective. STAR
   Add genetic operators that keep edits within a machine. STAR
   Thought: Evolution here is essential from job perspective to machine/topology perspective.
             - At least when there are parallel workcenters, this will be true. 
             - Also true about learning about buffers and accommodating other jobs.
             - Probably want a "ready-made structure" for insertion of parallel workstations. 
** Add MJP 
    This entails
     (1) having an operator for adding other colours -- Not a crossover operator ???
     (2) watching the execution times, maybe doing GPtips like regression.
** Add Causal
    This entails making the infinitessimal generator parametric.

* Discussion
** Rationale for PNN
It is clear that I need a means to explain messages that do not correspond to transitions. 
I need to discover the pattern associated with these other messages, if such a pattern exists. 
The PNN is just the way to do this. Do we associate a semantics to these messages? We can assume
that in general that may not be possible, but there is a "PN semantics" in the case
of blocking and starvation that it would be useful to know. (Likewise for competition for
resources and deadlocking). In the blocking/starvation cases, there is still the matter
of determining where the problem buffer is. Once starving happens it continues upstream, 
and blocking continues downstream. (You could check for that in the causal model.)
Likewise could look at non-delivery of a part from a feeder line. 

*** Think about the role of PNN in causal modeling
The nice thing here is that using the parametric infinitessimal, I'll have real-numbered 
quantities of tokens in places. The PNN essentially shows the state changes while I move around the parameters.

*** Think about what is being inferred. 
*** What role do the "starving/blocking" places have? Can they be added?
*** Define the steps 
   - recognition of a pattern
   - hypothesis generation
   - hypothesis testing (causal? comparison?)
   - [TODO] Consider "evolution in stages" where fitness changes when milestones are reached.
** IDEA: Maybe award fitness to PNs that represent exceptional messages.
***       Award a little less to those who can at least cope with it with a NN. 

** Integrating exceptional fitness
No starting links because nothing can parse the log. Every individual is capable of only describing
the path of a single job through the production resources. I think I have few options:

*** 1) Hope for a population that gets it right.
   Use genetic operators to produce more varied individuals, including some that 
   might parse the log well enough to get an exceptional msg table with markings that
   can guide design.

*** 2) Use a next-ordinary-on-job
   Instead of next-ordinary, use next-ordinary-on-job. That will provide a parse
   and lead to the need for queues. 

   You could apply this to multiple jobs, but would that be helpful?

*** 3) Give some more thought about how the reachability graph can do this. 

*** Summary (and msg-table)
Preparation to do (1) and (2) is the same, I think: It must be possible to 
use the msg table markings to update the PN. This is a "semantic genetic operator"

{:m1-blocked   {[3 0 1 1 0] 30},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved   {[0 0 1 0 1] 14},
 :m2-unstarved {[0 0 1 1 0] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263}}

But that is a msg-table for N=3. A table for N=1 would have 1/0 for the first component of block/unblock.
So what? 

But why doesn't an individual emerge from evolution that can do this?
The winning individual came real close after just two iterations. 

*** After 30 I still didn't get one. 
(You need 5 places and just the four transitions.) The only mistake
was an arc from the buffer to m2-complete-job. That arc should have
went to m2-start job. I think it may have stopped because success is <= 1 ??? Nope: we are looking for 0.1 or better.

***** I'm following jobs, what if instead I followed machines? (Or did both?)
Essentially what is wrong with the algorithm now is that it doesn't look at what machines do.
A Machine accepts/creates a part and starts work on it. It puts/destroys a part when done. 
These are patterns I could inject into the initial population, similar to what I do for jobs. 
What I really need are operators that combine the two viewpoints!!!

*** I'm going to cut the pop down to 25 and cut out lots of operators. 
   Not enough experimentation yet, but so far, that didn't work. 

*** Let's force one close to this [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/close-to-correct-pn.jpg]]

Find the PN for this on Sunday 2017-10-29. 


** GP Operators 
*** Need better notion of locality!
**** hopeful-pn with an initial-marking [1 0 0 0 0] (where first is place-1)
     Doesn't even get a rgraph, yet it is SO CLOSE!
*** Semantic operators
**** Example failure is hopeful-pn with initial-marking token on place-1
** [[https://www.datasciencecentral.com/profiles/blogs/artificial-intelligence-is-not-fake-intelligence][This]] neural net chart is pretty good.
   Much better discussion of it [[http://www.asimovinstitute.org/neural-network-zoo/][here]].
   23 Types of Regression, [[https://www.datasciencecentral.com/profiles/blogs/23-types-of-regression][here]].

* Sinet Log *
** <2017-10-14 Sat>
*** I started with this log file: [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-out.clj::%5B][m2-j1-n3-block-out.clj]] which blocks like crazy. 
*** I switched from returning 'the first' good starting marking to all markings.
*** I then compared the results from all three:

I am indexing the nets by the starting state. Each will associate a different marking with the
exceptional msg (defined as :fires-on). They all map [3 0 1 1 0] to the highest value of the NN.
Yet only the second one was trained for that outcome! The problem is that higher values are
going to drive the NN higher. (For example [10 0 1 1 0] give values even closer to 1 in each case.)
I can at least conclude that the one with the correct starting marking has the most prominent max
value (0.398 versus 0.213) is almost double, whereas the others are only  (0.57 versus 0.53) and
(0.71 vs 0.67) In all three cases, second best is [3 1 0 1 0].

**** (test-markings (get nnns [2 0 1 1 0]))   :fires-on {[2 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0019047821808839684),
 [3 1 0 1 0] (0.5329793128418048),
 [2 0 1 1 0] (0.4557148825447303),
 [1 1 0 1 0] (0.028426845459858803),
 [3 0 1 0 1] (0.2520620080684257),
 [1 0 1 1 0] (0.0824105061449745),
 [0 1 0 0 1] (4.4899449786599065E-4),
 [2 1 0 1 0] (0.3112057574008602),
 [3 0 1 1 0] (0.5690740829317157),   ----- (next best is 0.53, which is :fires-on)
 [1 0 1 0 1] (0.007984861441426688),
 [3 1 0 0 1] (0.33543893173498296),
 [0 0 1 1 0] (0.0017534551604061264),
 [0 0 1 0 1] (0.0010127514448150464),
 [2 0 1 0 1] (0.04765593309469408)}

**** (test-markings (get nnns [3 0 1 1 0]))   :fires-on {[3 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0014487996373689941),
 [3 1 0 1 0] (0.21293141920670883),
 [2 0 1 1 0] (0.15438051750729484),
 [1 1 0 1 0] (0.005105555396279919),
 [3 0 1 0 1] (0.05425027679413153),
 [1 0 1 1 0] (0.017136382643884614),
 [0 1 0 0 1] (4.6382801763844935E-4),
 [2 1 0 1 0] (0.03850346112492955),
 [3 0 1 1 0] (0.39880145491033164), ----- This IS fires-on. (next best is 0.213) 
 [1 0 1 0 1] (0.006230800133017719),
 [3 1 0 0 1] (0.03105553855253639),
 [0 0 1 1 0] (0.002015237400342786),
 [0 0 1 0 1] (0.001066242446042215),
 [2 0 1 0 1] (0.022575588402398115)}

**** (test-markings (get nnns [1 0 1 1 0]))   :fires-on {[1 0 1 1 0] 388}}}
{[0 1 0 1 0] (0.014569799679218615),
 [3 1 0 1 0] (0.6721408448530173),
 [2 0 1 1 0] (0.6688434016370715),
 [1 1 0 1 0] (0.21941460772717947),
 [3 0 1 0 1] (0.6601096030824811),
 [1 0 1 1 0] (0.46608997395936497),
 [0 1 0 0 1] (0.001252201438882003),
 [2 1 0 1 0] (0.5432656472113356),
 [3 0 1 1 0] (0.7113587186344846),  --- (next best is 0.672, which is [3 1 0 1 0]
 [1 0 1 0 1] (0.033295385315624364),
 [3 1 0 0 1] (0.5286157002824883),
 [0 0 1 1 0] (0.04039619976094015),
 [0 0 1 0 1] (0.00328347348876465),
 [2 0 1 0 1] (0.41021721559535307)}




**** Advantage: 
     The correct starting state has fewer false positives. It will do best. 

n**** Problem: 
     The algorithm is just going to focus on the buffer being high/low. This is fine for 
     blocking/starving events but not good for state-but-not-transition situations.

** <2017-10-15 Sun>
*** I ended up with data that blocks 30 times and starves 14 times: 
This was after about 30 experiments, fine tuning the parameters. The problem is that it
is very easy to get very short blocking/starving periods. 
Input:   file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild.clj]]
Output:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj:::status%20nil,][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj]]
Pretty:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj::%5B][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj]]
*** This was achieved with these parameters:
#+BEGIN_SRC clojure
  (map->Model
   {:line 
    {:m1 (map->ExpoMachine {:lambda 0.6 :mu 3.5 :W 1.0}) 
     :b1 (map->Buffer {:N 3})
     :m2 (map->ExpoMachine {:lambda 0.001 :mu 0.99 :W 1.0})}
    :number-of-simulations 1
    :report {:log? true :max-lines 3000}
    :topology [:m1 :b1 :m2]
    :entry-point :m1
    :params {:warm-up-time 2000 :run-to-time 10000}
    :jobmix {:jobType1 (map->JobType {:portion 1.0 :w {:m1 1.0, :m2 1.17}})}})
#+END_SRC
*** The m2-j1-n3 PN 
#+BEGIN_SRC clojure
{:places
 [{:name :buffer, :pid 0, :initial-tokens 0}
  {:name :m1-blocked, :pid 1, :initial-tokens 0}
  {:name :m1-busy, :pid 2, :initial-tokens 1}
  {:name :m2-busy, :pid 3, :initial-tokens 1}
  {:name :m2-starved, :pid 4, :initial-tokens 0}],
 :transitions
 [{:name :m1-complete-job, :tid 6, :type :exponential, :rate 0.9}
  {:name :m1-start-job, :tid 7, :type :immediate, :rate 1.0}
  {:name :m2-complete-job, :tid 8, :type :exponential, :rate 1.0}
  {:name :m2-start-job, :tid 9, :type :immediate, :rate 1.0}],
 :arcs
 [{:aid 10, :source :buffer, :target :m1-start-job, :name :aa-10, :type :inhibitor, :multiplicity 3, :bind {:jtype :blue}, :priority 1}
  {:aid 11, :source :buffer, :target :m2-start-job, :name :aa-11, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 12, :source :m1-blocked, :target :m1-start-job, :name :aa-12, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 13, :source :m1-busy, :target :m1-complete-job, :name :aa-13, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 14, :source :m1-complete-job, :target :m1-blocked, :name :aa-14, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 15, :source :m1-start-job, :target :buffer, :name :aa-15, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 2}
  {:aid 16, :source :m1-start-job, :target :m1-busy, :name :aa-16, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 17, :source :m2-busy, :target :m2-complete-job, :name :aa-17, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 18, :source :m2-complete-job, :target :m2-starved, :name :aa-18, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 19, :source :m2-start-job, :target :m2-busy, :name :aa-19, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 20, :source :m2-starved, :target :m2-start-job, :name :aa-20, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}]}
#+END_SRC 
 
*** Does it make sense to have an entry point with no :fire-ons?  (Yes, but...)
 I get two entry point markings, only one has anything in :fires-on. 
 I search for 50 steps supposedly, but it goes 225 lines, ending on the only exceptional msg, 
 which is {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]}. None of that should matter, we
 aren't looking for exceptional one yet. 
**** Is the problem that it is using the short data?
**** Yeah, ok this is wrong! : 
     (def foo (interpret-scada reach1 (-> (app-info) :problem :scada-log) lili))
     (count foo) ==> 225
     So I have been using the wrong data all the time, or it is stopping early?
     Good! It is stopping after 225 (the other goes 3000). I'm guessing that it gets 
     stuck in a situation it cannot interpret. Verify...
   
     Here is the new "failed-on" information:
     {:failed-prior   {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 224},
      :failed-on-link {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]},
      :failed-on-msg  {:act :m1-complete-job, :bf :b1, :j 1745, :n 0, :clk 2067.08452126566, :line 226, :mjpact :bj, :m :m1}}

     According to the reachability graph, the only thing that can occur after [1 0 1 0 1] is :m2-start-job
     {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0}
     That makes sense because ...
      [:buffer     1
       :m1-blocked 0
       :m1-busy    1
       :m2-busy    0
       :m2-starved 1]
      ... No, it doesn't make sense. [1 1 0 0 1] should also be possible. This is a vanishing transition to :m1-blocked.
***** BUG 
      The reachability graph must be wrong, but before I fix it, I won't build nets where :failed-on-msg is on last. DONE. 
      Something is seriously wrong. I created pnml for the N=3 PN but I don't get the same reachability as I did earlier
      (def reach1 ...) This one is much smaller. 

      Even the N=1 net is wrong. It should have 12 links, not 10:
      [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/m2-n1-no-immediate-reach.jpg]]

      First of all, these PNs have immediate transitions. 
          
      This is bad, there should be two here!    
    
      (next-links pnpn [0 1 0 1 0])
      [{:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0}]
      The problem was that I was not setting all transitions to timed. THIS MAY NEED MORE THOUGHT (to TODO)
*** So now I have larger rgraphs (e.g. 28 vs 18 for N=3) do things still work?
**** DONE write code to generate simple-reach
     CLOSED: [2017-10-15 Sun 20:07]
**** write fitness assessment. 
*** Junk I'll probably never use
#_(defn prev-ordinary
  "Return an ordinary message, at index n or earlier."
  [data n]
  (loop [indx n]
    (cond (ordinary? (nth data indx)) (nth data indx), 
          (== indx 0) nil
          :otherwise (recur (dec indx)))))

(defn big-train
  ([net] (big-train net :m1-blocked 1))
  ([net msg-type cnt]
   (reduce (fn [n _] (train-msg n msg-type))
           net
           (range cnt))))

;;; POD This is for :m2-starved. 
(defn more-exceptional-training
  [net cnt]
  (reduce (fn [n _]
            (nn/train-step net [0.0 0.0 1.0 0.0 1.0] [1.0]))
          net
          (range cnt)))


*** DONE Write code to defobulate/zipmap (and pick best???)
    CLOSED: [2017-10-17 Tue 14:17]
** <2017-10-16 Mon>
 So far there is only one NN per message. 

I cleaned things up so that I get one NN per message. 

I studied Probabilistic Neural Nets briefly. They require one neuron for each training instance
and therefore for my application I think would be equivalent of a lookup table encompasing the whole
training set. I think they make more sense when there are points "between" the elements in the
training set. (Do I have these???) Needs more study, but maybe not so promising.

Let's look at how these things do against the 

** <2017-10-17 Tue>

*** Cortex
Cortex layer types (what I'm seeing [[https://github.com/thinktopic/cortex/commit/4be1c559675b9612249abbb94963d989d70817fe][here]]): convolutional, max-pooling, dropout, relu, linear, softmax.
But *this* matters: [[https://machinelearningmastery.com/confusion-matrix-machine-learning/][Confusion matrix]]: Describes what one is and how to calculate one for the 2-class
classification problem!

[[https://adeshpande3.github.io/adeshpande3.github.io/A-Beginner's-Guide-To-Understanding-Convolutional-Neural-Networks-Part-2/][Nice discussion of use of layers in CNN]].

**** Dropout 
     Seems to be primarily about overfitting and regularization - introducing additional information to solve ill-posed problems
     Regularization is NOT what I want. 

     "The idea of dropout is simplistic in nature. This layer “drops out” a random set of activations in that 
      layer by setting them to zero. Simple as that. Now, what are the benefits of such a simple and seemingly 
      unnecessary and counterintuitive process? Well, in a way, it forces the network to be redundant. 
      By that I mean the network should be able to provide the right classification or output for a specific 
      example even if some of the activations are dropped out"

**** Max-pooling
     Used in convolutional NNs. Use biggest value on a window. [[https://leonardoaraujosantos.gitbooks.io/artificial-inteligence/content/pooling_layer.html][example here]]. The goal is to reduce spatial dimensions (but not depth)
     on a convolutional NN. Not what I want.

**** ReLu [[https://stackoverflow.com/questions/27319931/relu-and-dropout-in-cnn][here]]. (Rectified Linear Unit, Not a layer, the activation function of a single neuron.)
     The rectifier function is an activation function f(x) = Max(0, x) which can be used by neurons just like 
     any other activation function, a node using the rectifier activation function is called a ReLu node. 
     The main reason that it is used is because of how efficiently it can be computed compared to more conventional 
     activation functions like the sigmoid and hyperbolic tangent, without making a significant difference to 
     generalisation accuracy. The rectifier activation function is used instead of a linear activation function to 
     add non linearity to the network, otherwise the network would only ever be able to compute a linear function.

     This part sounds useful "to add non-linearity to the network, otherwise the network would only ever be able to
     compute a linear function." That is the problem I'm experiencing now. 

**** Convolutional 
     They aren't fully connected...

**** Softmax (Not a layer, the activation function of a single neuron.)
     In mathematics, the softmax function, or normalized exponential function is a generalization of the 
     logistic function that "squashes" a K-dimensional vector z of arbitrary real values to a K-dimensional vector 
      {\displaystyle \sigma (\mathbf {z} )} \sigma (\mathbf {z} ) of real values in the range [0, 1] that add up to 1.
     (wikipedia)
     [[https://github.com/Kulbear/deep-learning-nano-foundation/wiki/ReLU-and-Softmax-Activation-Functions][Softmax and ReLU]].

**** Probabilistic Neural Nets
   [[https://web.archive.org/web/20101218121158/http://herselfsai.com/2007/03/probabilistic-neural-networks.html][Start here]].


*** Confusion matrix
"A confusion matrix is a technique for summarizing the performance of a classification algorithm."
Thus if I have one of these, I can use it directly to determine the fitness of the combination of
PN + NNs as an identification of the system. 

Easy enough. Should also look at precision, recall, specificity and sensitivity. 
These are all defined on this [[https://en.wikipedia.org/wiki/Confusion_matrix][wikipedia page]]. I also have a paper by D. M. W. Powers in the ML
section of Mendeley.

*** fitness.clj
I think before I go much further, I have to fix the problem any problems deciding the class. 
I had hoped that it was just a matter of choosing marking > 0.5. Is this the case? 

HELP! No marking hits on any exceptional message. I don't think I have looked at results
since the "dense" exceptional messages of Saturday. 

*** What does the marking used as input to training mean?
    I was hoping that it was the marking just before the message is issued. 
    Messages are issued on complete-job / start-job but MJPdes doesn't 
    order these where they all happen simultaneously. Maybe it should???

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
 {:msg-type :m1-blocked,   [3 0 1 1 0] 30} ... I assume next msg is m1-complete-job
 {:msg-type :m1-unblocked, [2 1 0 1 0] 30} ... 
 {:msg-type :m2-starved,   [0 0 1 0 1] 14} 
 {:msg-type :m2-unstarved, [0 0 1 1 0] 14} 
 
Let's generate the interpretation [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j2-n3-block-mild-interpreted.clj::{:act%20:m1-blocked,%20:prev-act%20:m1-start-job,%20:indx%20710,%20:Mp%20%5B3%200%201%201%200%5D,%20:clk%202206.0879216608246}][AND SAVE IT AS A FILE]]. 

Start link is the same for all 4 message types, yet I interpret the log four times. Nice. 
    
**** Typical output with "data/SCADA-logs/m2-j1-n3-block-mild-out.clj"       
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-blocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.024485036900973763,
 [3 1 0 1 0] 0.008046179155291305,
 [2 0 1 1 0] 0.004074497484690655,
 [1 1 0 1 0] 0.013784127155537253,
 [3 0 1 0 1] 0.004062515347353122,
 [1 0 1 1 0] 0.005371589317720032,
 [0 1 0 0 1] 0.0521152547076084, <-- wrong, and next best is 0.027
 [2 1 0 1 0] 0.009709532322778542,
 [3 0 1 1 0] 0.003524192574949857,
 [1 0 1 0 1] 0.009338700112664192,
 [3 1 0 0 1] 0.010161648095898495,
 [0 0 1 1 0] 0.008800298059058962,
 [1 1 0 0 1] 0.026920570777390792,
 [0 0 1 0 1] 0.01845261113215176,
 [2 1 0 0 1] 0.014811122272394004,
 [2 0 1 0 1] 0.0055072388527700866}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-unblocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.025163102369711258,
 [3 1 0 1 0] 0.016114179019312516,
 [2 0 1 1 0] 0.007977926858371297,
 [1 1 0 1 0] 0.0201854362883496,
 [3 0 1 0 1] 0.014301613606198235,
 [1 0 1 1 0] 0.008978827733614799,
 [0 1 0 0 1] 0.06621052090624126,  <--- wrong, next is 0.036
 [2 1 0 1 0] 0.01751290729163327,
 [3 0 1 1 0] 0.007622303706912641,
 [1 0 1 0 1] 0.018487183654880144,
 [3 1 0 0 1] 0.029438724652992698,
 [0 0 1 1 0] 0.01104428285399589,
 [1 1 0 0 1] 0.04735457640118155,
 [0 0 1 0 1] 0.02363169658896575,
 [2 1 0 0 1] 0.036172647847275446,
 [2 0 1 0 1] 0.01569931368097529}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-starved nnns) %)) markings1)))

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.017027576075899276,
 [3 1 0 1 0] 0.004886266737864184,
 [2 0 1 1 0] 0.006935985604851713,
 [1 1 0 1 0] 0.008132810057098754,
 [3 0 1 0 1] 0.008690333194503956,
 [1 0 1 1 0] 0.011443272037409967,
 [0 1 0 0 1] 0.06431606145668564,
 [2 1 0 1 0] 0.005697633024429593,
 [3 0 1 1 0] 0.005600030048084727,
 [1 0 1 0 1] 0.03823100286076116,
 [3 1 0 0 1] 0.00657718778677882,
 [0 0 1 1 0] 0.029978431187203013,
 [1 1 0 0 1] 0.019941922787321802,
 [0 0 1 0 1] 0.11582262659576607, <-- yes. next is 0.064
 [2 1 0 0 1] 0.00937067227357531,
 [2 0 1 0 1] 0.014909753268535426}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-unstarved nnns) %)) markings1)))
[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.026026209106502097,
 [3 1 0 1 0] 0.0034988958592581513,
 [2 0 1 1 0] 0.00601129014254703,
 [1 1 0 1 0] 0.010186463188839843,
 [3 0 1 0 1] 0.0033239310083816543,
 [1 0 1 1 0] 0.011904922484223533,
 [0 1 0 0 1] 0.016127654355549154,
 [2 1 0 1 0] 0.00529834749317781,
 [3 0 1 1 0] 0.00385956712448291,
 [1 0 1 0 1] 0.008798843571705668,
 [3 1 0 0 1] 0.0029969968812421986,
 [0 0 1 1 0] 0.03188710693160681, <--- I guess...what does the marking mean???
 [1 1 0 0 1] 0.007127766343136932,
 [0 0 1 0 1] 0.020988809038561193,
 [2 1 0 0 1] 0.004186967134676599,
 [2 0 1 0 1] 0.00488250449212974}
nil
gov.nist.sinet.fitness> 


Let's go back to the dense messages and see if we still get good results.



Some bad news (Sort of. Hey, we need an interesting paper!): With more exceptional instances
things work pretty well.

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{:m1-unblocked
 [{:marking [0 1 0 1 0], :value 0.50118328747075}
  {:marking [1 1 0 1 0], :value 0.5228651697897436}
  {:marking [2 1 0 1 0], :value 0.5181440750582226}],
 :m1-blocked 
 [{:marking [3 1 0 1 0], :value 0.546424705570647} 
  {:marking [3 0 1 1 0], :value 0.5841860833305524}]}

...actually the unblocks look goofed up. 

This is not correct (or at least not best):

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]

How did m1-starting a job result in there being another job in the buffer?!?!?!
  {:M [1 1 0 1 0], :fire :m1-start-job, :Mp [2 0 1 1 0], :rate 1.0, :clk 3719.7720757450656, :indx 2984}
  {:act :m1-blocked, :prev-act :m1-start-job, :indx 2985, :Mp [2 0 1 1 0], :clk 3720.7720757450656}

The "out" log: (it shows the buffer being full, m2 pulling one, m1 completing one which would set it back to N=3.

{:act :m2-start-job, :bf :b1, :j 1082, :n 3, :clk 3719.7720757450656, :line 2981, :mjpact :sm, :m :m2}
{:act :m1-complete-job, :bf :b1, :j 1085, :n 2, :clk 3719.7720757450656, :line 2982, :mjpact :bj, :m :m1}
{:act :m1-unblocked, :m :m1, :clk 3719.7720757450656, :line 2983, :mjpact :ub}
{:act :m1-start-job, :j 1086, :jt :jobType1, :ends 3720.7720757450656, :clk 3719.7720757450656, :line 2984, :mjpact :aj, :m :m1}

The above  would be easier to read as this:

{:act :m2-start-job, :bf :b1, :j 1082, :n 3,    :clk 3719.7720757450656, :line 2981, :mjpact :sm, :m :m2}
{:act :m1-unblocked, :m :m1,                    :clk 3719.7720757450656, :line 2983, :mjpact :ub}
{:act :m1-complete-job, :bf :b1, :j 1085, :n 2, :clk 3719.7720757450656, :line 2982, :mjpact :bj, :m :m1} (move job)
{:act :m1-start-job, :j 1086, :jt :jobType1,    :clk 3719.7720757450656, :ends 3720.7720757450656, :line 2984, :mjpact :aj, :m :m1}

FIX MJPdes: 
- MJPdes ought to report things upstream happening first. (sort that way (upstream? x y)
- Everything would be easier to read if :clk was first, then :act. 

** <2017-10-18 Wed>

#_(defn reliable? [m]
    (= ReliableMachine (type m)))

#_(defn machine? [m]
  (let [t (type m)]
    (or (= ExpoMachine t) (= ReliableMachine t) (= Machine t))))

#_(defn buffer? [b]
  (let [t (type b)]
    (or (= Buffer t) (= InfiniteBuffer t) (= DedicatedBuffer t))))

** <2017-10-19 Thu>

I reviewed PNNs and found a nice Python implementation. The notebook is [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j2-n3-block-mild-interpreted.clj::{:act%20:m1-blocked,%20:prev-act%20:m1-start-job,%20:indx%20710,%20:Mp%20%5B3%200%201%201%200%5D,%20:clk%202206.0879216608246}][here]].

** <2017-10-20 Fri>

See discussion on keeping my head straight in Discussion area. 
** <2017-10-21 Sat>

I implement the PNN algorithm from [[http://www.personal.reading.ac.uk/~sis01xh/teaching/CY2D2/Pattern3.pdf][here]].

The key think I'm learning is that you can have the same marking associated with many classes. 
But if a class only has one datapoint, it wins when you hit it. This is good! This 
might be useful for distinguishing the size of buffers with different "best-interpretations."

All of this will be useful when I want to compare to the steady-state behavior using 
a parametric infinitessimal! 

(ppprint (subvec (best-interpretation pnpn (-> (app-info) :problem :scada-log)) 0 300))

Interestingly, starve and unstarve are coming up as both ordinary and exceptional. 
For the time being, this shouldn't matter much given that there is only 1 class in 
these exceptional markings. 

{:m2-unstarved {[0 0 1 1 0] 14},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved {[0 0 1 0 1] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263},
 :m1-blocked {[3 0 1 1 0] 30}}

;;; Results with sigma = 1.0
{[0 1 0 1 0] [:m2-unstarved 0.36787944117144233],
 [2 0 1 1 0] [:m1-blocked 0.6065306597126334],
 [1 1 0 1 0] [:m1-unblocked 0.6065306597126334],
 [3 0 1 0 1] [:m1-blocked 0.3678794411714423],
 [1 0 1 1 0] [:m2-unstarved 0.6065306597126334],
 [0 1 0 0 1] [:m2-starved 0.36787944117144233],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.6065306597126334],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.3312510892460261]}

;;; Results with sigma = 0.2 MAKES PERFECT SENSE!
{[0 1 0 1 0] [:ordinary 0.06971187503880233],
 [2 0 1 1 0] [:ordinary 0.17548168297989752],
 [1 1 0 1 0] [:ordinary 0.09031651123868557],
 [3 0 1 0 1] [:ordinary 0.0851651717421801],
 [1 0 1 1 0] [:ordinary 0.16002840419305475],
 [0 1 0 0 1] [:ordinary 0.0048076923087272344],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:ordinary 0.07451958526421719],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.09031652915550199]}

** <2017-10-22 Sun>

Yesterday I got PNNs working nicely! If only every day were that productive!
This morning (well, until 2:30PM!) I cleaned up MJPdes. 
Today we experiment with the idea of replacing euclid-dist2 with some notion of "pn network distance."

- Places are dimensions, movement can be along one or more dimensions. 
- Transitions are the things that determine movement; only dimensions referenced in the
  transition change between states. 
- Each marking has an associated classification. Markings that are very dissimilar from the
  classified marking should have a large distance measure from it. EUCLIDEAN DISTANCE ENSURES THIS.
  The PDF distributes the classification among each training instance. 

- I was concerned about the proximity of activity over time. That changes according to rates. 
  If one part of the network has high-rate transitions, we'd expect more activity from it. But so what?
- I was thinking about "locality of reference" -- that with each transition, only connected places change. 

--> Maybe then what I'm after is to use the distance between transitions in the measure of 
    distance between states. 
    Q: But what does that mean? 
    A: A transition occurs -- we want to learn the relationship between transition and the emission of 
       exceptional messages. This is a temporal relationship (E.g. How many steps after firing X do
       I see exceptional message M?) This isn't judged by pn-path stuff, it is by reachability graph!

Maybe just do the Euclidean distance between markings times the number of steps. 

- There is nothing preventing 
- Transitions that are far from the 

(defn paths-to
  "Return the paths from FROM to TO (both are names of places or transitions) 
   in exactly STEPS steps (counting places, transitions and arcs)."
  [pn from to nsteps & {:keys [back?]}]

** <2017-10-23 Mon>

Another productive day (without really working too hard!). 
The distance function that I'm using is strictly distance between nodes in the rgraph. 
I use loom to calculate this (20 minutes work). 
I'm moving the parzen-pdf-msg stuff from pnn to fitness. 

*** This stuff isn't going to be used
#_(defn min-pn-steps
  "Return the pn distance from FROM to TO in either direction."
  [pn [from to]]
  (if (= from to)
    0
    (loop [cnt 1]
      (if (> cnt 100) 1000, ; POD 1000, it is probably down stream
          (if-let [path (or (not-empty (pnu/paths-to pn from to cnt))
                            (not-empty (pnu/paths-to pn to from cnt)))]
            (/ (-> path first count) 4) ; counts arcs, transitions; I want place to place.
            (recur (inc cnt)))))))

#_(defn pn-distance-table
  "Return a table of all pn distances"
  [pn]
  (let [places (map :name (:places pn))
        keys (for [from places
                   to   places]
               [from to])]
    (zipmap keys
            (map #(min-pn-steps pn %) keys))))


*** This stuff could go in project just of simple neural nets
;;; :marking-key [:buffer :m1-blocked :m1-busy :m2-busy :m2-starved],
;;; It blocks after [2 0 1 1 0]

;;; POD NYI
#_(defn pick-net 
  "Given a list of NN, choose the most accurate one for its message."
  [nets]
  (let [result (filter nn/net? nets)]
    (when (> (count result) 1)
      (println "Multiple nets. Pick NYI."))
    (first nets)))
  
#_(defn train-msg
  "Train the net for the msg-type using the log interpretation."
  [net interp msg-type]
  (let [train-data (:interpreted-log interp)
        last-indx (-> train-data last :indx)
        fires-on (atom {:msg-type msg-type})]
    (loop [net net
           indx 0]
      (if (>= indx last-indx) ; terminate
        (-> net
            (assoc :fires-on @fires-on)
            (assoc :msg-type msg-type)
            (assoc :start-link (:start-link interp)))
        (let [msg (nth train-data indx)
              label (if (= (:act msg) msg-type) 1 0)           ; (rand-int 2)
              inputs (cond (== label 1)             (:Mp msg), ; (noise) 
                           (contains? msg :fire)    (:M  msg), ; (noise) 
                           :otherwise :skip)] ; an exceptional message but not the one I'm learning. 
          (when (== label 1) ; track markings it is firing on
            ;;(println msg)
            (if (contains? @fires-on (:Mp msg))
              (swap! fires-on #(update % (:Mp msg) inc))
              (swap! fires-on #(assoc  % (:Mp msg) 1))))
          (recur
           (if (= inputs :skip)
             net
             (nn/train-step net
                            (vec (map double inputs))
                            (vector (double label))))
           (inc indx)))))))

#_(defn train-all
  "Given a SCADA log interpretation, return a map providing the best NN for each message."
  [interp]
  (let [size   (-> interp :marking-key count)
        msgs   (-> (app-info) :problem :exceptional-msgs)]
    (zipmap msgs
            (map #(train-msg (nn/make-net size 1 size) interp %) msgs))))

#_(defn exceptional-markings
  "Return a vector of {:marking x :value y} indicating that the 
   marking associates with the exceptional class of the neural net."
  [net markings]
  (let [results (zipmap markings
                         (map #(first (nn/eval-net net %)) markings))]
    (reduce (fn [success [mark class-val]]
              (if (> class-val 0.5)
                (conj success {:marking mark :value class-val})
                success))
            []
            results)))

;;; (tryme pnpn (-> (app-info) :problem :scada-log))
#_(defn tryme [pn scada-log]
  (let [interp (best-interpretation pn scada-log) ; POD stop after have all markings. 
        nets (train-all interp)
        markings (distinct (map :M (:rgraph interp)))]
    (reduce (fn [res [msg net]]
              (assoc res msg (exceptional-markings net markings)))
            {}
            nets)))

#_(defn noise []
  (vec (repeatedly 5 #(rand-int 2))))

*** This stuff is what I used prior to recognizing that I need occurrence counts for the parzen-fn
It has been replaced by compute-msg-table.
(defn compute-pnn-data
  "Return a map indicating what markings are associated with what message types, 
   where message types are either ':ordinary' or some exceptional message type."
  [pn scada-log]
  (let [interp (best-interpretation pn scada-log)
        markings (-> (map :M (:rgraph interp)) set)
        excepts (->> (filter #(contains? % :act) (:interpreted-log interp))
                     (map #(dissoc % :clk))
                     (map #(dissoc % :indx))
                     distinct)
        classes (conj (distinct (map :act excepts)) :ordinary)
        emarks (set (map :Mp excepts))
        data (reduce
              (fn [data mark]
                (if (contains? emarks mark)
                  (update-in data
                             [(some #(when (= (:Mp %) mark) (:act %)) excepts)]
                             #(conj % mark))
                  (update-in data [:ordinary] #(conj % mark))))
              (zipmap classes (repeat (count classes) []))
              markings)]
    data))


        
*** This stuff was my first pass at interpretation???
#_(defn best-nav
  "Picking various starting points in the SCADA log, return the 
   longest path of it that can be walked using the QPN." 
  [inv]
  (let [rgraph (pnr/simple-reach (:pn inv))
        exceptional (set/difference scada-msg-types (set (map :fire rgraph)))
        msg1 (first scada-msgs)
        start-marks (map :Mp (filter #(= (:fire %) (:name msg1)) rgraph))]
    (map #(navigate-qpn (:pn inv) rgraph exceptional % 0 (dec (count scada-msgs))) start-marks)))

;;; The set of exceptional message types is decided on a per-QPN basis.
;;; Whatever is in the SCADA log but not a QPN event is exceptional for that QPN. 

;;; POD I think it is enough to always start at position 0 in the SCADA log because
;;;     exceptional situations are the only thing in the way. 
;;;     But is this still sensitive to to the initial marking???
(defn navigate-qpn
  "Using the QPN, try to walk the SCADA log from the argument marking and associated 
   starting position in the log to the argument stop position.
   Return a map describing how far it was possible to navigate and what markings were
   associated with the exceptional messages encountered."
  [pn rgraph excepts mark start stop]
  (let [pn (pnr/renumber-pids pn)]
    (loop [result {:start start :ix (+ start 1) :mark mark :path [] :excepts {}}]
      (let [links (filter #(= (:M %) (:mark result)) rgraph)
            event (:name (nth scada-msgs (:ix result)))
            link  (some #(when (= event (:fire %)) %) links)]
        (if (or (and (not link)
                     (not (some #(= event %) excepts)))
                (>= (inc (:ix result)) stop))
          result 
          (recur (if link
                   (-> result
                       (update :ix inc)
                       (assoc :mark (:Mp link)))
                   (-> result
                       (update :ix inc)
                       (update-in [:excepts event] #(distinct (conj %1 %2)) mark)))))))))


As is apparent from the four subtopics above, I cut out a lot of code today!

Refactors stuff has not yet been tested. 
** <2017-10-24 Tue>

I've got a bug in starting-links. 
next-paths works depth first thus I don't think this code makes sense:
      (when-let [goods (filter #(> (count %) 50) paths)]
        (swap! winners #(into % (vec (map first goods)))))


paths= [[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0}
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 1}
        {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 2}
        {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0, :indx 3}
        {:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 4} 
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 5} 
        {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 6} 
        {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0, :indx 7} 
        {:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 8} 
        {:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0, :indx 9}] 

[{:M [1 0 1 0 1], :fire :m1-complete-job, :Mp [1 1 0 0 1], :rate 0.9, :indx 0}] 
[{:M [0 0 1 0 1], :fire :m1-complete-job, :Mp [0 1 0 0 1], :rate 0.9, :indx 0}] 
[{:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0}]]
indx = 10
good-steps= ()

Ugh! The problem is I'm using the wrong data. Anyway, if there are no good starting-links... 

{:act :m2-complete-job, :m :m2, :j 1744, :ent 2062.4506743555485, :clk 2066.1692850612535, :line 224, :mjpact :ej}
{:act :m2-starved, :m :m2, :clk 2066.1692850612535, :line 225, :mjpact :st}

I have been chasing my tail for hours! It works here, doesn't work, works....



At sigma = 1.0 mine works better:

Euclidean:
         {[0 1 0 1 0] [:m2-unstarved 0.36787944117144233],
          [2 0 1 1 0] [:m1-blocked 0.6065306597126334],
          [1 1 0 1 0] [:m1-unblocked 0.6065306597126334],
          [3 0 1 0 1] [:m1-blocked 0.3678794411714423],
          [1 0 1 1 0] [:m2-unstarved 0.6065306597126334],
          [0 1 0 0 1] [:m2-starved 0.36787944117144233],
          [2 1 0 1 0] [:m1-unblocked 1.0],
          [3 0 1 1 0] [:m1-blocked 1.0],
          [1 0 1 0 1] [:m2-starved 0.6065306597126334],
          [0 0 1 1 0] [:m2-unstarved 1.0],
          [0 0 1 0 1] [:m2-starved 1.0],
          [2 0 1 0 1] [:ordinary 0.3312510892460261]}))

Euclidean + graph distance
         {[0 1 0 1 0] [:m2-unstarved 0.1353352832366127],   <------- Even these
	 [2 0 1 1 0] [:ordinary 0.24215429146359604],       <----------------
	 [1 1 0 1 0] [:m1-unblocked 0.22313016014842982],
	 [3 0 1 0 1] [:m1-blocked 0.1353352832366127],
	 [1 0 1 1 0] [:ordinary 0.22681188379228487],       <----------------
	 [0 1 0 0 1] [:m2-starved 0.1353352832366127],
	 [2 1 0 1 0] [:m1-unblocked 1.0],
	 [3 0 1 1 0] [:m1-blocked 1.0],
	 [1 0 1 0 1] [:m2-starved 0.2231301601484298],
	 [0 0 1 1 0] [:m2-unstarved 1.0],
	 [0 0 1 0 1] [:m2-starved 1.0],
	 [2 0 1 0 1] [:ordinary 0.1503568437398036]}


At sigma=0.2 very little difference (but this is very tight range on trained values). 
Euclidean
         (fit/choose-winners (assoc pn-test :sigma 0.2))
         {[0 1 0 1 0] [:ordinary 0.06971187503880233],
          [2 0 1 1 0] [:ordinary 0.17548168297989752],
          [1 1 0 1 0] [:ordinary 0.09031651123868557],
          [3 0 1 0 1] [:ordinary 0.0851651717421801],
          [1 0 1 1 0] [:ordinary 0.16002840419305475],
          [0 1 0 0 1] [:ordinary 0.0048076923087272344],
          [2 1 0 1 0] [:m1-unblocked 1.0],
          [3 0 1 1 0] [:m1-blocked 1.0],
          [1 0 1 0 1] [:ordinary 0.07451958526421719],
          [0 0 1 1 0] [:m2-unstarved 1.0],
          [0 0 1 0 1] [:m2-starved 1.0],
          [2 0 1 0 1] [:ordinary 0.09031652915550199]}))))

Mine
         {[0 1 0 1 0] [:ordinary 0.06971153846153845],
	 [2 0 1 1 0] [:ordinary 0.17548076923076922],
	 [1 1 0 1 0] [:ordinary 0.09031593406593406],
	 [3 0 1 0 1] [:ordinary 0.08516483516483515],
	 [1 0 1 1 0] [:ordinary 0.16002747252747251],
	 [0 1 0 0 1] [:ordinary 0.004807692307692307],
	 [2 1 0 1 0] [:m1-unblocked 1.0],
	 [3 0 1 1 0] [:m1-blocked 1.0],
	 [1 0 1 0 1] [:ordinary 0.07451923076923077],
	 [0 0 1 1 0] [:m2-unstarved 1.0],
	 [0 0 1 0 1] [:m2-starved 1.0],
	 [2 0 1 0 1] [:ordinary 0.09031593406593406]}

At sigma = 0.8 mine is almost perfect, traditional is way off. 
(ppprint (tryme 0.8))
{[0 1 0 1 0] [:ordinary 0.08167651755114105],
 [2 0 1 1 0] [:ordinary 0.20096611102341413],
 [1 1 0 1 0] [:ordinary 0.11223204044436556],
 [3 0 1 0 1] [:ordinary 0.09758966328235849],
 [1 0 1 1 0] [:ordinary 0.1858113376895019],
 [0 1 0 0 1] [:m2-starved 0.04393693362340743],  
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.09596708604499851], <--- wrong
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.11337198216661176]}
nil
gov.nist.sinet.fitness> (ppprint (tryme2 0.8))
{[0 1 0 1 0] [:m2-unstarved 0.20961138715109787],
 [2 0 1 1 0] [:m1-blocked 0.4578333617716143],
 [1 1 0 1 0] [:m1-unblocked 0.4578333617716143],
 [3 0 1 0 1] [:m1-blocked 0.20961138715109784],
 [1 0 1 1 0] [:m2-unstarved 0.45783336177161427],
 [0 1 0 0 1] [:m2-starved 0.20961138715109787],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.45783336177161427],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.23037282986699076]}

;;; At sigma = 0.75 mine is good, theirs is still crap.


gov.nist.sinet.fitness> (pprint (tryme 0.75))
{[0 1 0 1 0] [:ordinary 0.07812345592321546],
 [2 0 1 1 0] [:ordinary 0.19350798937548197],
 [1 1 0 1 0] [:ordinary 0.10565451941946981],
 [3 0 1 0 1] [:ordinary 0.09387730377891051],
 [1 0 1 1 0] [:ordinary 0.1783054552497219],
 [0 1 0 0 1] [:m2-starved 0.028565500784550373],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:ordinary 0.08572916833008677],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.10642989332503937]}
nil
gov.nist.sinet.fitness> (pprint (tryme2 0.75))
{[0 1 0 1 0] [:m2-unstarved 0.1690133154060661],
 [2 0 1 1 0] [:m1-blocked 0.41111229050718745],
 [1 1 0 1 0] [:m1-unblocked 0.41111229050718745],
 [3 0 1 0 1] [:m1-blocked 0.1690133154060661],
 [1 0 1 1 0] [:m2-unstarved 0.41111229050718745],
 [0 1 0 0 1] [:m2-starved 0.1690133154060661],
 [2 1 0 1 0] [:m1-unblocked 1.0],
 [3 0 1 1 0] [:m1-blocked 1.0],
 [1 0 1 0 1] [:m2-starved 0.41111229050718745],
 [0 0 1 1 0] [:m2-unstarved 1.0],
 [0 0 1 0 1] [:m2-starved 1.0],
 [2 0 1 0 1] [:ordinary 0.20673002778168464]}



{:m2-unstarved {[0 0 1 1 0] 14},
 :m1-unblocked {[2 1 0 1 0] 30},
 :m2-starved {[0 0 1 0 1] 14},
 :ordinary
 {[0 1 0 1 0] 203,
  [2 0 1 1 0] 511,
  [1 1 0 1 0] 263,
  [3 0 1 0 1] 248,
  [1 0 1 1 0] 466,
  [0 1 0 0 1] 14,
  [2 1 0 1 0] 248,
  [3 0 1 1 0] 248,
  [1 0 1 0 1] 217,
  [0 0 1 1 0] 217,
  [0 0 1 0 1] 14,
  [2 0 1 0 1] 263},
** <2017-10-25 Wed>

I should be having a telecon with Charles today, but...

*** Tryme functions for Euclidean and graph-distance * Euclidean
(defn tryme [sigma]
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        pn (as-> "data/PNs/m2-inhib-n3.xml" ?pn
             (pnml/read-pnml ?pn)
             (pnr/renumber-pids ?pn)
             (assoc ?pn :rgraph (pnr/simple-reach ?pn))
             (assoc ?pn :starting-links (starting-links ?pn log 0))
             (assoc ?pn :msg-table (compute-msg-table ?pn log))
             (assoc ?pn :sigma sigma)
             (assoc ?pn :distance-fn (graph-distance-fn ?pn))
             (assoc ?pn :pdf-fns
                    (zipmap (-> ?pn :msg-table keys)
                            (map #(parzen-pdf-msg ?pn %)
                                 (-> ?pn :msg-table keys)))))]
    (reset! diag pn)
    (choose-winners pn)))

(defn tryme2 [sigma]
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")
        pn (as-> "data/PNs/m2-inhib-n3.xml" ?pn
             (pnml/read-pnml ?pn)
             (pnr/renumber-pids ?pn)
             (assoc ?pn :rgraph (pnr/simple-reach ?pn))
             (assoc ?pn :starting-links (starting-links ?pn log 0))
             (assoc ?pn :msg-table (compute-msg-table ?pn log))
             (assoc ?pn :sigma sigma)
             (assoc ?pn :distance-fn pnn/euclid-dist2)
             (assoc ?pn :pdf-fns
                    (zipmap (-> ?pn :msg-table keys)
                            (map #(parzen-pdf-msg ?pn %)
                                 (-> ?pn :msg-table keys)))))]
    (choose-winners pn)))
See Agenda. Today I'm integrating the exceptional messages, and inhibitors.
First, however, is to look into the possibly erroneous marking state found yesterday:

[0 1 0 0 1] [:m2-starved 0.1690133154060661], ; <---- Needs investigation. Should not be in rgraph!

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
Means that m1 is blocked, yet there is nothing in the buffer. How does this come about?
It is a vanishing state from m1-complete-job to m1-start-job. 
So it is okay. 

The problem I'm having with init-pop seems to be that plans don't have names. 
This was probably erroneously removed when MJPdes was prettified. 

*** More unnecessary code:
#_(defn mjpdes2pn-trace
  "Translate all the SCADA message maps with maps with 'nice pn names."
  [job-trace]
  (distinct (map scada/mjpdes2pn job-trace)))

;;; POD Will need to generalize this idea of 'what a message means' I'm giving nice "pn names" to MJPdes output. 
;;; (mjpdes2pn (first (scada/random-job-trace))) ==>  {:name :m1-start-job, :act :aj, :m :m1}

#_(defn mjpdes2pn
  "Interpret/translate the SCADA log. (Give pretty-fied pn names to MJPdes output.)" 
  [msg]
  (let [m (implies-machine msg)]
    (-> msg
        (assoc :mjpact (:act msg))
        (assoc :m m)
        (assoc :act (scada2pn-name msg)))))
;;; POD Someday you might want to call this with multiple job traces.
;;; POD This interprets/translates the SCADA log. We'll need to generalize it someday.
(defn scada2pn-name
  "Return a transition name for a given SCADA msg (bl/ub/st/us probably wont' be used.)"
  [msg]
  (let [m (implies-machine msg)]
    (cond (= :aj (:act msg)) (read-string (cl-format nil "~A-start-job"    m)),
          (= :ej (:act msg)) (read-string (cl-format nil "~A-complete-job" m)),
          (= :sm (:act msg)) (read-string (cl-format nil "~A-start-job"    m)),
          (= :bj (:act msg)) (read-string (cl-format nil "~A-complete-job" m)),
          (= :bl (:act msg)) (read-string (cl-format nil "~A-blocked"      m)),
          (= :ub (:act msg)) (read-string (cl-format nil "~A-unblocked"    m)),
          (= :st (:act msg)) (read-string (cl-format nil "~A-starved"      m)),
          (= :us (:act msg)) (read-string (cl-format nil "~A-unstarved"    m)))))

(defn implies-machine
  "Returns machine referenced/implied in message. 
   If a buffer n is references, machine n+1 is pulling from it.
   Returns nil if msg contains neither :bf or :m"
  [msg]
  (let [act (:act msg)]
    (cond (= act :aj) :m1
          (= act :bj) (keyword (format "m%d"      (read-string (subs (str (:bf msg)) 2)))),
          (= act :sm) (keyword (format "m%d" (inc (read-string (subs (str (:bf msg)) 2))))),
          (contains? msg :m) (:m msg))))


OK, first interesting thing is that I've been using a N=3 example, but now, of course, 
all the instances start as N=1. I guess that was expected, but it is making it harder
to sync-up in "starting-links" 


Arcs are all messed up: 
 :arcs
 [{:aid 1, :source :place-1, :target nil, :name :aa-1, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 2, :source nil, :target :place-2, :name :aa-2, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 3, :source :place-2, :target nil, :name :aa-3, :type :normal, :multiplicity 1, :bind {:jtype :blue}}

Maybe fix this with clojure.spec? 
** <2017-10-26 Thu>

*** More junk?
#_(defn diag-run
  "Run the GP in diagnostic mode from the REPL. A very useful function!"
  []
  (binding [*debugging* false] ;<===== Whether or not to save every individual
    (reset! diag-all-inv {})
    (let [p (promise)]
      (as-> (evolve-init) ?w
        (evolve-continue ?w p (rep/evolve-chan))))))
*** NEXT: Write clojure.spec for world. 
** <2017-10-27 Fri>

Writing clojure spec for world. Find a way to pause and keep world. 

Once again (it was happening Oct 7, among other times) I'm getting a error
No implementation of method: :sch-send! of protocol: #'taoensso.sente.interfaces/IServerChan found for 
class: org.httpkit.server.AsyncChannel
==> I started a new client (close tab, open another to localhost:8080) and it seems to work.

This makes no sense. big-reset does not fix it. 

==> Timeout requesting individual...Needed to provide a clean PN (no functions). DONE.

  < See Discussion>


==> Something screwy is going on. It is no faster. Gets stuck sometimes after 1 iteration. 

--> I remove exceptional processing. No help! Still slow! WTF is it doing???

Is it that the agent is forcing things into one process??? Need to watch process meter!!
** <2017-10-28 Sat>

*** Slow Runtime investigation

Yesterday: Is it that the agent is forcing things into one process??? Need to watch process meter!!
I think that it is that I don't have an ABORT that actually leaves the loop, and that
I don't have a record (defonce atom) ? of old evolve-chan. OTOH, these are suppose to park.

[[http://www.bradcypert.com/clojure-async/][Brad Cypert on Core.Async]] 

**** Before I started, there were two processes called main. 
    MJPdes (started with lein repl) gets two processes called main too.  
    Also get two with C-c M-j on MJPdes.
    Starting fresh I get one. (fan starts/stops) Now two again 869 and 784
    Killing 684 kills both.
    ====> One starts just as the REPL server starts. --> One for program, one for repl (nREPL). 
**** Pipe taking 30% of a CPU. Killed it. 
**** Code suggests that nothing starts just by loading. 
**** Oh so well behaved today!
    Got more than 500% CPU and CPU dropped to 0.1% when done. 
**** Big-reset didn't save on old-channel. (Reload doesn't obey defonce ???)
    Also, no message that would suggest that ABORT happened. 
*** Resolved runtime, but exceptional is slow!

It is not just slow, it is stuck, I think. Aborting doesn't abort. Some of those 
pmapped things are probably still running -- hung: 
**** Need timeouts on pmapped processes???

*** This was first attempt at pmap-timeout (though I didn't know it at the time!)
(def running "Vector of futures" (atom []))
(def promises "Promises of running individuals." (atom []))

(def sched-chan ; POD defonce
  "A channel with a buffer equal to the number of cpu/hyperthreads."
  (async/chan (-> (app-info) :gp-system :use-cpus)))


(defn schedule-work
  "Schedule an individual to run; return a promise."
  [inv work]
  (>!! sched-chan (:id inv)) ; block if full
    (future (deliver p (work inv))
            (<!! sched-chan)) ; make room for more
    p))

(defn finished-work
  "Deref a promise (with timeout) and pull from channel to free up a spot."
  [p]
  (let [result (deref p 10000 :timeout)]
    (cl-format *out* "~%~A finished with ~A" (<!! sched-chan) result)
    result))


***    13:45 - pmap-timeout working....
    ... but I'm back to having 700% CPU when nothing (useful) is running.  
   
    Agents allow shared access to mutable state. 
    (send-off @the-agent evolve-continue @the-promise evolve-chan)

    So I'm asking the agent to run evolve-continue, as opposed to just running evolve-continue
    in a thread with future. 

    I am not able to use (shutdown-agents) (nREPL uses agents). So maybe I try this 
    with a future? 

    The nice thing about agents is the error handler....
    No difference. So SLOWWWW

    Let's see if the pmap-timeout is implicated. 
    A: No, not really. It gets stuck on 100% rather than 800% so we can at least debug it. 

>>>>>    the-promise never gets delivered. 
>>>>>    Delivering it by hand doesn't help.

Temporarily, I'm not reset! the-future to nil. When I print it out:
         (try @@the-future (catch Exception e (str e)))
            "java.util.concurrent.CancellationException"


This 700% problem is really weird. 
(clojure.core.async/thread) shows one thread. 

I *think* I now know why it would hang in the map case (as opposed to my pmap-timeout case):
 It gets stuck on simple-reach. Next time I'll get the PN!!!

For the 700% case, it is probably true that future-cancel isn't doing what I hoped (terminating the thread)

Some thoughts on interrupt by [[http://puredanger.github.io/tech.puredanger.com/2009/06/08/interrupt-handling/][puredanger]].

** <2017-10-29 Sun>

*** Yesterday's impressive waste of time (NOT?):
#_(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many futures in parallel as possible for the hardware. Returns a vector of results."
  ([func members timeout]
   (pmap-timeout func members timeout (+ 2 (.. Runtime getRuntime availableProcessors))))
  ([func members timeout nproc]
   (let [to-run      (atom (vec members))
         results     (atom [])
         running-cnt (atom 0)
         nprocessors nproc
         update-fn (fn [mp] ; return a (possibly new) value for the results vector member.
                     (cond (not (:fut mp)) ;(not= #{:fut :start :mem :prom} (-> mp keys set))
                           mp,
                           (future-done? (:fut mp))
                           (do (swap! running-cnt dec)
                               (deref (:fut mp))),
                           (> (System/currentTimeMillis)
                              (+ (:start mp) timeout))
                           (do (swap! running-cnt dec)
                               (.interrupt @(:prom mp))
                               (.stop @(:prom mp))
                               ;; POD deref timeout here should not be necessary, but...
                               (deref (:fut mp) 10 {:timeout (:mem mp)}))
                           :else mp))]
     (while (not-empty @to-run)
       (when (< @running-cnt nprocessors)
         (let [mem (first @to-run)
               p   (promise)]
           (swap! running-cnt inc)
           (swap! to-run #(vec (rest %)))
           (swap! results conj {:fut (future
                                       (try (let [t (Thread/currentThread)]
                                              (deliver p t)
                                              (func mem))
                                            (catch InterruptedException e
                                              {:timeout mem})))
                                :prom p
                                :mem mem
                                :start (System/currentTimeMillis)})))
       (swap! results #(vec (map update-fn %))))
     ;; Wait for everyone to finish/timeout. 
     (while (some #(:fut %) @results)
       (swap! results #(vec (map update-fn %))))
     (reset! diag @results)
     @results)))

*** I'm still at it. This morning I read about timeout on alts!! in Clojure for the Brave and True. 

**** First try
(pmap-timeout (fn [n] (Thread/sleep n) :done) (repeatedly 8 #(+ 1000 (* 1000 (rand-int 5)))) 5000)
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  [func members maxtime]
  (map (fn [mem]
         (let [c (async/chan)]
           (go (>! c {::val (func mem)}))
           (let [[v _] (alts!! [c (timeout maxtime)])]
             (if (contains? v ::val)
               (::val v)
               {:timeout mem}))))
       members))

***** Huh?
Okay, I expected some trouble, but not this. The map here is not blocking!
Furthermore, it takes maxtime rather than the actual execution time!
I see one problem in that the system might not really start the process when I do go.
I can fix that with a promise that delivers the time and channel. Let's try that first,
THOUGH THINGS ARE ALREADY CONFUSED BY NOT BLOCKING!!! <---- doall on map!

***** Naive; no promise, no doall
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  [func members maxtime]
  (let [channels (map #(let [c (async/chan)]
                         (go (>! c {::val (func %)}))
                         c)
                      members)
        launched (System/currentTimeMillis)]
    ;; This isn't perfect, but it gets around futures, which I can't get to .stop.
    (map (fn [mem c]
           (let [remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                 [v _] (alts!! [c (timeout remaining)])]
             (if (contains? v ::val)
               (::val v)
               {:timeout mem})))
         members
         channels)))








***** This one "gathers" cpus with each iteration, keeps them!
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  ([func members maxtime] (pmap-timeout func members maxtime :timeout))
  ([func members maxtime timeout-key]
   (let [chan&prom (map #(let [c (chan)
                               p (promise)]
                           (go (deliver p (System/currentTimeMillis))
                               (>! c {::val (func %)}))
                           [c p])
                        members)]
     ;; This was designed to gets around futures not .stop-ing. No help.
     (doall
      (map (fn [mem [c p]]
             (let [launched (deref p)
                   remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                   [v _] (alts!! [c (timeout remaining)])]
               (if (contains? v ::val)
                 (::val v)
                 {timeout-key mem})))
           members
           chan&prom)))))

;;; Apparently, it doesn't even run them in parallel!:



(time (let [times (pmap-timeout (fn [n] (Thread/sleep n) n) (repeatedly 8 #(+ 1000 (* 1000 (rand-int 5)))) 5000)]
        (println (str "times = " times))
        (apply + (map #(if (number? %) % (:timeout %)) times)))
"Elapsed time: 19029.34562 msecs"
19000

I GIVE UP!!!!
times = clojure.lang.LazySeq@b6bc10ca
"Elapsed time: 30032.256013 msecs"


Yesterday's was better! It didn't stop either, but it used all the processors:
times = [3000 {:timeout 5000} {:timeout 5000} {:timeout 5000} {:timeout 5000} 1000 3000 2000]
"Elapsed time: 5007.784076 msecs"
29000

I'll update yesterday's to send the actual launch time in the promise, then I'm calling it quits.

I REALLY NEED TO GIVE UP! However, when it does get stuck, it gets stuck while starting the 
first eight. For example, the running-cnt stops at 2 or 3. 

Too bad [[https://www.amazon.com/Clojure-High-Performance-JVM-Programming/dp/1787129594][this]] (high-performance clojure/jvm) is published by Packt!

*** I'm going with my 'sophisticated' futures one; this is the last one with core.async

This [[https://books.google.com/books?id=wU8oDwAAQBAJ&pg=PA231&lpg=PA231&dq=clojure+realized?+versus+future-done?&source=bl&ots=jp-WamYmFj&sig=EVCmaMEv1SyUiGteYzTWgJOGNRw&hl=en&sa=X&ved=0ahUKEwi73vy0oJbXAhUJ6iYKHWwWDTcQ6AEIWjAH#v=onepage&q=clojure%20realized%3F%20versus%20future-done%3F&f=false][page]] about future-done? in hi-performance jvm ... is good.
(defn pmap-timeout
  "Like (pmap func coll) except that it returns {:timeout <member>} for those members of coll
   for which func does not complete in timeout milliseconds after that member is started.
   Runs as many instances in parallel as possible for the hardware."
  ([func members maxtime] (pmap-timeout func members maxtime :timeout))
  ([func members maxtime timeout-key]
   (let [chan&prom (map #(let [c (chan)
                               p (promise)]
                           (go (deliver p (System/currentTimeMillis))
                               (>! c {::val (func %)}))
                           [c p])
                        members)]
     ;; They won't start until I dereference??? Back to the future!
     (map (fn [[_ p]] (future (deref p))) chan&prom)
     ;; This was designed to gets around futures not .stop-ing. Still doesn't stop.
     (doall
      (map (fn [mem [c p]]
             (let [launched (deref p)
                   remaining (max (- maxtime (- (System/currentTimeMillis) launched)) 1)
                   [v _] (alts!! [c (timeout remaining)])]
               (if (contains? v ::val)
                 (::val v)
                 {timeout-key mem})))
           members
           chan&prom)))))



*** I gave up!
*** Here is an offending pn, it is not k-bounded
**** Code
(def pnpn
{:initial-marking [1 0 0 0],
 :transitions
 [{:name :m1-start-job,
   :tid 2,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-start-job, :j 2001, :jt :jobType1, :ends 2368.3676866897163, :clk 2367.3676866897163, :line 1275, :mjpact :aj, :m :m1},
   :visible? true}
  {:name :m1-complete-job,
   :tid 3,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-complete-job, :bf :b1, :j 2001, :n 1, :clk 2368.3676866897163, :line 1278, :mjpact :bj, :m :m1},
   :visible? true}
  {:name :m2-start-job,
   :tid 4,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-start-job, :bf :b1, :j 2001, :n 3, :clk 2370.6070474961243, :line 1287, :mjpact :sm, :m :m2},
   :visible? true}
  {:name :m2-complete-job,
   :tid 5,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-complete-job, :m :m2, :j 2001, :ent 2367.3676866897163, :clk 2371.7770474961244, :line 1290, :mjpact :ej},
   :visible? true}],
 :sigma 0.75,
 :winners {},
 :arcs
 [{:aid 2, :source :place-1, :target :m1-start-job, :name :aa-2, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 3, :source :m1-start-job, :target :place-2, :name :aa-3, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 4, :source :place-2, :target :m1-complete-job, :name :aa-4, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 5, :source :m1-complete-job, :target :place-3, :name :aa-5, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 6, :source :place-3, :target :m2-start-job, :name :aa-6, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 7, :source :m2-start-job, :target :place-4, :name :aa-7, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 8, :source :place-4, :target :m2-complete-job, :name :aa-8, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 9, :source :m2-complete-job, :target :place-1, :name :aa-9, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 210, :source :m1-start-job, :target :place-4, :name :aa-210, :type :normal, :multiplicity 1, :priority 2}],
 :rgraph
 ({:M [1 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0], :rate 1.0}
  {:M [0 1 0 0], :fire :m1-complete-job, :Mp [0 0 1 0], :rate 1.0}
  {:M [0 0 1 0], :fire :m2-start-job, :Mp [0 0 0 1], :rate 1.0}
  {:M [0 0 0 1], :fire :m2-complete-job, :Mp [1 0 0 0], :rate 1.0}),
 :msg-table {:m2-unstarved {}, :m1-unblocked {}, :m2-starved {}, :ordinary {}, :m1-blocked {}},
 :marking-key [:place-1 :place-2 :place-3 :place-4],
 :starting-links (),
 :places
 [{:name :place-1, :pid 0, :initial-tokens 1, :visible? true}
  {:name :place-2, :pid 1, :initial-tokens 0, :visible? true}
  {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
  {:name :place-4, :pid 3, :initial-tokens 0, :visible? true}]})

**** I'm now using "k-bounding" to truncate rgraphs in reach.clj.
**** 30 iterations and nothing useful found
**** No implementation of method: :sch-send!
Once again (it was happening Oct 7, and Friday, among other times) I'm getting a error
No implementation of method: :sch-send! of protocol: #'taoensso.sente.interfaces/IServerChan found for 
class: org.httpkit.server.AsyncChannel

Unlike Friday's episode, restarting the client is not helping. 
However, restarting completely -- lein restart-repl -- did the trick. 
Could it be that running -- diag-run -- before having the client up messes up the client? 

*** Hopeful-pn
{:initial-marking [1 0 0 0 0],
 :transitions
 [{:name :m1-start-job,
   :tid 38,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-start-job, :j 1991, :jt :jobType1, :ends 2356.5705647971827, :clk 2355.3103128463604, :line 1233, :mjpact :aj, :m :m1},
   :visible? true}
  {:name :m1-complete-job,
   :tid 39,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m1-complete-job, :bf :b1, :j 1991, :n 1, :clk 2356.5705647971827, :line 1238, :mjpact :bj, :m :m1},
   :visible? true}
  {:name :m2-start-job,
   :tid 40,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-start-job, :bf :b1, :j 1991, :n 3, :clk 2358.9070474961236, :line 1247, :mjpact :sm, :m :m2},
   :visible? true}
  {:name :m2-complete-job,
   :tid 41,
   :type :exponential,
   :rate 1.0,
   :rep {:act :m2-complete-job, :m :m2, :j 1991, :ent 2355.3103128463604, :clk 2360.0770474961237, :line 1248, :mjpact :ej},
   :visible? true}],
 :sigma 0.75,
 :winners {},
 :arcs
 [{:aid 74, :source :place-1, :target :m2-start-job, :EDITED true :name :aa-74, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 75, :source :m1-start-job, :target :place-2, :name :aa-75, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 76, :source :place-2, :target :m1-complete-job, :name :aa-76, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 77, :source :m1-complete-job, :target :place-3, :name :aa-77, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 78, :source :place-3, :target :m1-start-job, :EDITED true :name :aa-78, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 79, :source :m2-start-job, :target :place-4, :name :aa-79, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 80, :source :place-4, :target :m2-complete-job, :name :aa-80, :type :normal, :multiplicity 1, :bind {:jtype :blue}}
  {:aid 81, :source :m2-complete-job, :target :place-1, :name :aa-81, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 205, :source :m1-start-job, :target :Place-103, :name :aa-205, :type :normal, :multiplicity 1, :priority 2}
  {:aid 206, :source :Place-103, :target :m2-start-job, :name :aa-206, :type :normal, :multiplicity 1}],
 :rgraph
 {:rgraph
  [{:M [1 0 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0 1], :rate 1.0}
   {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
   {:M [0 0 1 0 1], :fire :m2-start-job, :Mp [0 0 0 1 0], :rate 1.0}
   {:M [0 0 0 1 0], :fire :m2-complete-job, :Mp [1 0 0 0 0], :rate 1.0}],
  :k-limited? false},
 :msg-table {:m2-unstarved {}, :m1-unblocked {}, :m2-starved {}, :ordinary {}, :m1-blocked {}},
 :k-limited? false,
 :marking-key [:place-1 :place-2 :place-3 :place-4 :Place-103],
 :starting-links (),
 :places
 [{:name :place-1, :pid 0, :initial-tokens 1, :visible? true}
  {:name :place-2, :pid 1, :initial-tokens 0, :visible? true}
  {:name :place-3, :pid 2, :initial-tokens 0, :visible? true}
  {:name :place-4, :pid 3, :initial-tokens 0, :visible? true}
  {:name :Place-103, :pid 4, :initial-tokens 0}]}

** <2017-10-30 Mon>

The hopeful PN produces this rgraph, which apparently is not sufficient to parse the log. 

 {:rgraph
  [{:M [1 0 0 0 0], :fire :m1-start-job, :Mp [0 1 0 0 1], :rate 1.0}
   {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
   {:M [0 0 1 0 1], :fire :m2-start-job, :Mp [0 0 0 1 0], :rate 1.0}
   {:M [0 0 0 1 0], :fire :m2-complete-job, :Mp [1 0 0 0 0], :rate 1.0}],

The log looks like this:

[{:act :m1-complete-job, :bf :b1, :j 1689, :n 0, :clk 1999.9234365080201, :line 0, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1690, :jt :jobType1, :ends 2000.9234365080201, :clk 1999.9234365080201, :line 1, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1688, :ent 1996.9156570964649, :clk 2000.6492850612497, :line 2, :mjpact :ej}
 {:act :m2-start-job, :bf :b1, :j 1689, :n 1, :clk 2000.6492850612497, :line 3, :mjpact :sm, :m :m2}
 {:act :m1-complete-job, :bf :b1, :j 1690, :n 0, :clk 2000.9234365080201, :line 4, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1691, :jt :jobType1, :ends 2001.9234365080201, :clk 2000.9234365080201, :line 5, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1689, :ent 1998.198793731718, :clk 2001.8192850612497, :line 6, :mjpact :ej}
 {:act :m2-start-job, :bf :b1, :j 1690, :n 1, :clk 2001.8192850612497, :line 7, :mjpact :sm, :m :m2}
 {:act :m1-complete-job, :bf :b1, :j 1691, :n 0, :clk 2001.9234365080201, :line 8, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1692, :jt :jobType1, :ends 2002.9234365080201, :clk 2001.9234365080201, :line 9, :mjpact :aj, :m :m1}
 {:act :m1-complete-job, :bf :b1, :j 1692, :n 1, :clk 2002.9234365080201, :line 10, :mjpact :bj, :m :m1}
 {:act :m1-start-job, :j 1693, :jt :jobType1, :ends 2003.9234365080201, :clk 2002.9234365080201, :line 11, :mjpact :aj, :m :m1}
 {:act :m2-complete-job, :m :m2, :j 1690, :ent 1999.9234365080201, :clk 2002.9892850612498, :line 12, :mjpact :ej}]

The reason that it can't model the log is that it isn't looking at job-ids. 
If instead of what I'm doing, I started with (like the log shows) m1-complete-job j 1689 on line 0,
then I can jump down to :m2-start-job j 1689 on line 3. THIS is parsing the log!

TUESDAY CLARIFICATION: Parsing the log must still means doing things in the order
specified by the reachability graph! The problem MIGHT be different from what 
I describe above. The reason it can't parse the log is that the argument PN has a buffer 
of only 1, so it can't express the level of asynchronicity in the log??? (FALSE?).

WHATEVER! First fix regression testing, then see what good the job assignments might provide.

What I need is indeed, "next-ordinary-message-on-job" and I need to count what messages
I parsed and remove them / associate them with the job. 
When I'm done, I count what content I accounted for by each. 
EASY PEASY. 

<2017-10-31 Tue>

Well, maybe not so easy. First, there is the matter that we need to keep moving ahead with
new jobs in order to parse the entire log. Secondly, there is the technical problem of 
where (in what object) do we keep notice of consumption of a message. 

I'll try to create a map with the messages and other data and validate with the 
N=3 pn... 
  -rw-r--r--   1 pdenno  pdenno  334035 Oct 15 12:03 m2-j1-n3-block-mild-out.clj
So I'll just attach the 334k log to every PN. Let's see how good the GC is!

C-c C-t n has apparently been lying to me!
** <2017-10-31 Tue>

On the way to exploring the "more flexible" interpretation of the log, I found and
fixed a bug in starting-links (the "distinct" thing). This might not have an effect
on functionality. 

I now pass in most information *including the log* through pn. The idea is to track
which job is consuming which message, a relaxation of the log interpretation to account
for a lack of (or insufficient) buffer. 
** <2017-11-01 Wed>

==> I believe that today's algorithm subsumes functionality of disorder-fitness. 


(defn next-ordinary-on-job
  "Return the next ordinary message, at index n or later."
  [pn n jid]
  (let [data (:log pn)
        last-ix (:last-line pn)] ; POD put on pn
    (loop [indx n]
      (if (> indx last-ix)
        nil
        (if-let [msg (and (ordinary? (nth data indx))
                          (== (:j (nth data indx)) jid))]
          msg
          (recur (inc indx)))))))

[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0, :job 1689}
 {:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0, :job 1689}]

First one failed on 
{:msg
 {:act :m1-complete-job,
  :bf :b1,
  :j 1692,
  :n 1,
  :clk 2002.9234365080201,
  :line 10,
  :mjpact :bj,
  :m :m1},
 :interp-last
 {:M [3 1 0 0 1],
  :fire :m2-start-job,
  :Mp [2 1 0 1 0],
  :rate 1.0,
  :job 1692,
  :clk 2001.9234365080201,
  :indx 9,
  :relax? :add-job}}

Even if second one succeeds, it is doing so only on buffer size, thus something needs adjustment. 
Hmmm, maybe not; at :Mp buffer is 2. 

{:msg
 {:act :m2-complete-job,
  :m :m2,
  :j 1720,
  :ent 2034.2910787732983,
  :clk 2038.089285061252,
  :line 130,
  :mjpact :ej},
 :interp-last
 {:M [3 0 1 1 0],
  :fire :m2-complete-job,
  :Mp [3 0 1 0 1],
  :rate 1.0,
  :job 1720,
  :clk 2036.919285061252,
  :indx 129,              <------ Looks like this should be line 128
  :relax? :active}}

Second is really messed up! :m2-complete-job at 129, then it chooses :m2-complete-job ???

Log looks like this:
{:act :m2-complete-job, :m :m2, :j 1719, :ent 2033.0614667964674, :clk 2036.919285061252, :line 128, :mjpact :ej}
{:act :m2-start-job, :bf :b1, :j 1720, :n 2, :clk 2036.919285061252, :line 129, :mjpact :sm, :m :m2}
{:act :m2-complete-job, :m :m2, :j 1720, :ent 2034.2910787732983, :clk 2038.089285061252, :line 130, :mjpact :ej}

So how did the last action become :indx 129 :m2-complete-job ???

Should I update :graph-link on an :active ? I think so. I did. 
Need to see the whole interp. Where is 128? 
  {:M [2 1 0 1 0],
   :fire :m1-start-job,
   :Mp [3 0 1 1 0],
   :rate 1.0,
   :job 1719,
   :clk 2036.919285061252,
   :indx 128,                      <--------------------- 128 is :m2-complete-job
   :relax? :active}
  {:M [3 0 1 1 0],
   :fire :m2-complete-job,
   :Mp [3 0 1 0 1],
   :rate 1.0,
   :job 1720,
   :clk 2036.919285061252,
   :indx 129,
   :relax? :active}]}

(filter #(= (:Mp glink) (:M %)) (:rgraph pn))]

Needs :fire like for normal messages. 
Something is wrong with the way I'm thinking about this, because when I add the 
extra condition, things stop after just a few lines.

There is no question that the message condition has to be there -- that's the message!
So it must be that I'm screwing up on :M / :Mp YEAH -- THOSE shouldn't be in the condition!

8 seconds!!!

(def pnpn (tryme)) ;; Then uncomment...
(def lll (-> (app-info) :problem :scada-log))
(time (def foo (interpret-scada pnpn lll (-> pnpn :starting-links first))))

If still slow, try shorting out the call to the Djikstra thing.

Something changed, because now it takes 1200 milliseconds. Acceptable, barely.

Yeah, without Djikstra it finishes in 50 milliseconds and still goes all the way.
What gives? 

Without checking first: 2796.
        Checking first: 2796

*** This version of link-match  should not be necessary.
(defn link-match [pn action llink msg]
  (let [glink (:graph-link pn)]
    (if-let [link (some #(when (and (= (:Mp llink) (:M %)) 
                                    (= (:fire %) (:act msg)))
                           %)
                        (:rgraph pn))]
      (link+msg link msg)
      ;; This relaxes conformance to rgraph
      ;; Use :graph-link to find which of the candidate states is nearest. 
      (when-let [links (filter #(and (= (:fire %) (:act msg)))
                               (:rgraph pn))]
        (let [graph (:loom-graph pn)
              from (:Mp glink)
              dists (map
                     (fn [l] {:link l
                              :dist (count (alg/dijkstra-path
                                            graph
                                            from
                                            (:M l)))})
                     links)
              best (-> (sort #(< (:dist %1) (:dist %2)) dists) first :link)]
          (cl-format *out* "~%counts = ~{~A ~}" (map :dist dists))
          (when best
            (as-> (link+msg best msg) ?link
              (if (= action :aj)
                (assoc ?link :relax? :add-job)
                (assoc ?link :relax? :active)))))))))
*** Cleaning upt some PQN stuff
;;; This is only called when there aren't many jobs. Typically, just one. 
#_(defn qpn-typical-job-id
  "Return log entry from (statistically) most typical jobs (a statistical analysis)."
  [pn]
  ;; Check variance across qpn-c-t-t; use it (and process pattern) to determine job types.
  ;(NYI)
  ;; Of the types, choose one (a safe one).
  (let [tkn-id (max (Math/round (/ (-> pn :sim :max-tkn) 2.0)) 1)]
    (vector ; POD current assume just one job type. 
     (loop [log (qpn-gather-tkn (-> pn :sim :log) tkn-id) ; this collects just :acts
            trace []]
       (let [msg (first log)]
         (cond (empty? log) trace, 
               (some #(= (:act %) (:act msg)) trace) trace,
               :else (recur (next log) (conj trace msg))))))))
            

*** Tomorrow
So it only hits "ordinary" about 200 times!
Why isn't new job ordinary? Why does that create a disconnect; it didn't 
before I wrote this!
(In fact, EVERYTHING worked without Djikstra on this test case!)
** <2017-11-02 Thu>

Force everything in this test case through the old method.
If can't get it down to 100 msec, consider using FIRST interpretation. 
Don't commit until this is figured out. 

Get's through 565. Very odd. 
Aha! Gets throug 565 for the *second* start link. Gets through all 3000 for the *first*!

43 milliseconds!

[{:M [0 0 1 1 0], :fire :m1-complete-job, :Mp [0 1 0 1 0], :rate 0.9, :indx 0, :job 1689}
 {:M [1 0 1 1 0], :fire :m1-complete-job, :Mp [1 1 0 1 0], :rate 0.9, :indx 0, :job 1689}]

The system is, in fact, in the situation of the first!
{:act :m1-complete-job, :bf :b1, :j 1689, :n 0, :clk 1999.9234365080201, :line 0, :mjpact :bj, :m :m1}

OK, now we have lax-reach which on hopeful-pn is k-limited. It has this rgraph:
 :rgraph
 ({:M [0 1 0 0 0], :fire :m1-complete-job, :Mp [0 0 1 0 0], :rate 1.0}
  {:M [0 0 1 0 0], :fire :m1-start-job,    :Mp [0 1 0 0 1], :rate 1.0}
  {:M [0 1 0 0 1], :fire :m1-complete-job, :Mp [0 0 1 0 1], :rate 1.0}
  {:M [0 0 1 0 1], :fire :m1-start-job,    :Mp [0 1 0 0 2], :rate 1.0}
  {:M [0 1 0 0 2], :fire :m1-complete-job, :Mp [0 0 1 0 2], :rate 1.0}),

place-103 is indeed what I intend to be a buffer.

:marking-key [:place-1 :place-2 :place-3 :place-4 :Place-103],
Note that there is no transition out of [0 0 1 0 2]. Can this be fixed? 

Things are not going well with the repair. The lax idea is okay, but instead of
one token on :m1, I should have 1 token on each machine. Exception will work 
to specify the buffer sizes. 


*** Old lax-reach
(defn lax-reach
  "Return a rgraph where possibly it is necessary to experiment with 
   initial markings to make things go."
  ([pn] (lax-reach pn 2))
  ([pn max-k]
   (if-let [rgraph (:rgraph (pnr/simple-reach pn max-k))]
     rgraph  ; POD :m1 is entry machine??? (MJPdes notion)
     (let [m1-starters (map :name (filter #(= :m1 (-> % :rep :m)) (:transitions pn)))
           m1-places   (distinct
                        (into (mapv :target (filter (fn [a] (some #(= % (:source a)) m1-starters)) (:arcs pn)))
                              (mapv :source (filter (fn [a] (some #(= % (:target a)) m1-starters)) (:arcs pn)))))
           mkey (:marking-key pn)
           ;; Try markings that put tokens into :m1
           imarks (mapv (fn [pname]
                          (reduce (fn [mark ix]
                                    (conj mark (if (= pname (nth mkey ix)) 1 0)))
                                  []
                                  (-> mkey count range)))
                        m1-places)]
       (some #(let [pn (pnu/set-marking pn %)
                    reach (pnr/simple-reach pn max-k)]
                (when (:rgraph reach)
                  (-> pn
                      (assoc :rgraph (:rgraph reach))
                      (assoc :k-limited? (:k-limited? reach)))))
             imarks)))))


*** Look at all this shrapnel!
                                           
  (let [aset (get m-arcs m)]
     (and (contains? aset (:source %))
     (contains? aset (:target %))))
      (:places pn)))))

     {:machines machines
      :m-t m-trans
      :m-a m-arcs})))

   m1-starters (map :name (filter #(= :m1 (-> % :rep :m)) (:transitions pn)))
   m1-places   (filter (fn [p] (and (some #(= p (:source )) m1-starters)) (:places pn)))
   (distinct
      (into (mapv :target (filter (fn [a] (some #(= % (:source a)) m1-starters)) (:arcs pn)))
            (mapv :source (filter (fn [a] (some #(= % (:target a)) m1-starters)) (:arcs pn)))))
           mkey (:marking-key pn)
           ;; Try markings that put tokens into :m1
           imarks (mapv (fn [pname]
                          (reduce (fn [mark ix]
                                    (conj mark (if (= pname (nth mkey ix)) 1 0)))
                                  []
                                  (-> mkey count range)))
                        m1-places)]
       (some #(let [pn (pnu/set-marking pn %)
                    reach (pnr/simple-reach pn max-k)]
                (when (:rgraph reach)
                  (-> pn
                      (assoc :rgraph (:rgraph reach))
                      (assoc :k-limited? (:k-limited? reach)))))
             imarks)))))

** <2017-11-03 Fri>

*** I start with this version of lax-reach(defn lax-reach
  "Return a rgraph where possibly it is necessary to experiment with 
   initial markings to make things go."
  ([pn] (lax-reach pn 2))
  ([pn max-k]
   ;(if-let [rgraph (:rgraph (pnr/simple-reach pn max-k))]  rgraph  :foo); POD :m1 is entry machine??? (MJPdes notion)
   (let [machines (distinct (mapv #(-> % :rep :m)
                                  (filter #(contains? % :rep) (:transitions pn))))
         ;; map of transitions associated with a machine. Transition associate with messages, which associate to machines.
         m-trans (zipmap machines
                         (map (fn [m]
                                (set (map :name (filter #(= m (-> % :rep :m))
                                                        (:transitions pn)))))
                              machines))
         ;; map of arcs associated with a machine. Must have both ends on a transition related to the machine. 
         m-arcs (zipmap machines
                        (map (fn [m]
                               (let [tset (get m-trans m)]
                                 (set (map :name
                                           (filter #(and (contains? tset (:source %))  ; <--- Not bipartite!
                                                         (contains? tset (:target %)))
                                                   (:arcs pn))))))
                             machines))
         ;; map of places associated with a machine. Must be between trans of the same machine. 
         m-places (zipmap machines ; there is an arc that has this place as source and a m-trans machine as target
                          (map (fn [m]  ; and an arc that has this place as target and a m-trans machine as source
                                 (let [mset (get m-trans m)]
                                   (set (map :name
                                             (filter (fn [p] 
                                                       (some #(or (and (contains? mset (:source %))
                                                                       (= (:target %) (:name p)))
                                                                  (and (contains? mset (:target %))
                                                                       (= (:source %) (:name p))))
                                                             (:arcs pn))) ; (get m-arcs m))) <---- When the above is fixed.
                                                     (:places pn))))))
                               machines))]
          {:machines machines
           :m-t m-trans
           :m-a m-arcs
           :starters m-places})))
** <2017-11-04 Sat>

I did paper until 4PM. I learned about Mahoney's approach finding a separate sigma for each measurement dimension. 
Will I have time for all of this???

*** Old tryme
(defn tryme []
  (let [log (scada/load-scada "data/SCADA-logs/m2-j1-n3-block-mild-out.clj")]
    (as-> hopeful-pn ?pn
      (assoc ?pn :last-line (-> log last :line))
      (assoc ?pn :rgraph (pnr/simple-reach ?pn)) ; returns a map {:rgraph ... :k-limited...}
      (assoc ?pn :k-limited? (-> ?pn :rgraph :k-limited?))
      (assoc ?pn :rgraph (-> ?pn :rgraph :rgraph vec))
      (assoc ?pn :loom-graph (rgraph2loom-graph (-> ?pn :rgraph)))
      (assoc ?pn :starting-links (fit/starting-links ?pn log 0))
      (assoc ?pn :msg-table (fit/compute-msg-table ?pn log))
      (assoc ?pn :distance-fn pnn/euclid-dist2))))

*** repair-reach; probably not going to use it
;;; (def pnpn (lax-reach hopeful-pn))
;;; [:place-1 :place-2 :place-3 :place-4 :Place-103]
;;; m-mp : #{[0 1 0 0 0]} -- True, you'll never see this after starting with it. 
;;; mp-m : #{[0 0 1 0 2]}
(defn repair-reach
  "If present, try to remove traps from a k-limited graph."
  ([pn] (repair-reach pn 2))
  ([pn max-k]
   (let [m  (set (distinct (map #(:M %)  (:rgraph pn))))
         mp (set (distinct (map #(:Mp %) (:rgraph pn))))
         m-mp (clojure.set/difference m mp)
         mp-m (clojure.set/difference mp m)
         trans (map :name (:transitions pn))]
     ;; m-mp: try to find a transition from any existing :M that yields Mp.
     (let [seek-mp [0 1 0 0 0]
           m-mp-fix (reduce (fn [answ1 trans]
                              (into answ1
                                    (vec (reduce (fn [answ2 mark]
                                                   (into answ2
                                                         (filterv #(= seek-mp (:Mp %))
                                                                  (pnr/next-marks pn mark))))
                                                 []
                                                 m))))
                            []
                            trans)]
       (if (empty? m-mp-fix)
         (let [test-one (first m-mp)]
           (filterv #(not= test-one (:M %)) (:rgraph pn)))
         m-mp-fix)))))


*** hopeful-pn (pnpn) fizzles out at line 594:

{:M [0 1 0 1 0], :fire :m2-complete-job, :Mp [1 1 0 0 0], :rate 1.0, :job 1834, :clk 2173.361361140053, :indx 594}]

{:act :m2-complete-job, :m :m2, :j 1834, :ent 2169.2631314350665, :clk 2173.361361140053, :line 594, :mjpact :ej}
{:act :m2-start-job, :bf :b1, :j 1835, :n 1, :clk 2173.361361140053, :line 595, :mjpact :sm, :m :m2}
{:act :m1-complete-job, :bf :b1, :j 1836, :n 0, :clk 2173.4862364331248, :line 596, :mjpact :bj, :m :m1}


Let's see if the problem is that N=3 and lax is set to two. Maybe first I'll try lax set to 3. 
YUP! That's an easy test! 

*** Reasoning about how interpretation should really work:
So I think I need the converse of lax-reach: lax-interp which will:
  1) Allow "pushing to full buffers"  when no other transition (but only up to "max-buffer" = 10 to terminate early) 
  2) Allow "pulling from  empty buffers" when no other transition. 

To do this:
 a) Must determine what places are buffers.
 b) Must be able to determine which place is the problem, and whether it is 
 c) There are two "when no other transition" conditions" -- I guess that isn't a problem though (zero or two tells you).

Hmmm... Maybe the easiest way to implement this isn't to extend into a larger reachability set, but
        rather just make jobs magically appear and disappear... UNFORTUNATELY, that will screw up 
        job tracking. 

**** Three alternatives then:
 (1): Extend the k-max bound on-the-fly as you get into failure situations.
 (2): Add jobs to deal with not having false starvation, remove jobs to deal with false blocking.
 (3): Do what I just did: Run lax-reach again with a higher number. 

(3) is by far the easiest, and I don't think it is computationally expensive either. 
    I'm going to try (3)!!!

This needs to wrap lax-reach and interp in a loop. Refactoring!


* Org Mode Tasks
** DONE Start using org for programming notes.
   CLOSED: [2017-10-14 Sat 18:06]
** DONE Learn how to 'open' and edit a link. Right now the org manual link is just the URL. 
   CLOSED: [2017-10-15 Sun 12:25]
** TODO Find out what good the source code marking is. I see that you can edit it with C-c ' but so what?

* Notes on org mode
** Useful Links
*** The tutorial 
 [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][The tutorial]]
 http://orgmode.org/manual/index.html
    
** Key bindings 
*** Opening and closing
**** Shift-tab open/close whole document (circular)
**** Shift-cntl open/close current
*** Linking
**** C-c l (store link)
**** C-c C-l bring the link here
**** C-c C-l also to edit a link (when point is on the link)
**** Links look like this: [[link][description] ...] 
  Here I inserted elipsis to stop that from turning into a link. An actual 
  link to a web page would appear like this: [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][the tutorial]]. 
**** C-c C-o (open) open a link without the mouse.   
    This is especially sweet for local links. It splits showing two buffers. 

*** TODO Operations
**** M-Shift-Ret open a TODO.

**** C-c C-t (terminate?) marks a TODO as done.
*** Miscellaneous
**** Timestamps C-c . (C-c ! is similar but 'without creating an agenda entry' whatever that means.)

**** Source Code C-c ' (open and close) #+BEGIN_SRC clojure ... #+END_SRC


* Sinet TODOs
** TODO Try a more mild blocking situation.
** DONE Fix bug in pnr/simple-reach. See bug <2017-10-15 Sun>
   CLOSED: [2017-10-15 Sun 18:13]
** TODO Consider the possibility/advantages of an 'abbreviated' reachability graph. 
** TODO Decide whether setting all transitions to timed makes sense for simple-reach. See discussion <2017-10-15 Sun>
** TODO Investigate possible bugs with MJPdes 'coordination' and create more 'deterministic' test cases.
** TODO Conceive of a strategy for using exceptional fitness
 [I think I missed the whole point in the stuff below, but just to be sure: There are messages that
  are not associated with transitions. They are associated with STATES. I may have a place in the network
  that is essentially "M1-BLOCKED" but it won't be labelled as such! A nice thing about this is that 
  I DON'T WANT to get a M1-BLOCKED message every (vanishing) time that there is a token in that place.
  I only want these when the buffer is filled (a state where the buffer place looms large). That's what 
  will happen, and we don't have to worry about labeling the "m1-blocked" place!]

 In some cases like blocking/starving it seem that having a place represent the state is appropriate. 
 But is that generally the case? This ToDo is closely related to the next about vanishing transitions,
 but I don't think it is the same issue. I think I need to see the result of the "mild blocking" 
 situation before I can sort this out. Remember that the goal is to get rates out of these things. 

 (More on this): I think there might be quirk to what I'm trying to do: I'd like to allow the PN to handle 
 exceptional messages just as some do for block/starve, but block/starve are places, not transitions, and 
 they won't have meaningful names. I think I'll just wait to explore this after getting the exceptional 
 fitness hooked in. 

** TODO Deal with vanishing transitions. 
 I need to generate blocking/starving messages ONLY when the net sojourns at blocking/starving. 
 So simulation has to be better and I need to distinguish these immediate transitions some how. 

** TODO Find out a way to find the pathname "to a namespace" so I can run tests on dependent packages. 
*** IDEA: Maybe award fitness to PNs that represent it. 
***       Award a little less to those who can at least cope with it with a NN. 

* Sinet Log *
** <2017-10-14 Sat>
*** I started with this log file: [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-out.clj::%5B][m2-j1-n3-block-out.clj]] which blocks like crazy. 
*** I switched from returning 'the first' good starting marking to all markings.
*** I then compared the results from all three:

I am indexing the nets by the starting state. Each will associate a different marking with the
exceptional msg (defined as :fires-on). They all map [3 0 1 1 0] to the highest value of the NN.
Yet only the second one was trained for that outcome! The problem is that higher values are
going to drive the NN higher. (For example [10 0 1 1 0] give values even closer to 1 in each case.)
I can at least conclude that the one with the correct starting marking has the most prominent max
value (0.398 versus 0.213) is almost double, whereas the others are only  (0.57 versus 0.53) and
(0.71 vs 0.67) In all three cases, second best is [3 1 0 1 0].

**** (test-markings (get nnns [2 0 1 1 0]))   :fires-on {[2 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0019047821808839684),
 [3 1 0 1 0] (0.5329793128418048),
 [2 0 1 1 0] (0.4557148825447303),
 [1 1 0 1 0] (0.028426845459858803),
 [3 0 1 0 1] (0.2520620080684257),
 [1 0 1 1 0] (0.0824105061449745),
 [0 1 0 0 1] (4.4899449786599065E-4),
 [2 1 0 1 0] (0.3112057574008602),
 [3 0 1 1 0] (0.5690740829317157),   ----- (next best is 0.53, which is :fires-on)
 [1 0 1 0 1] (0.007984861441426688),
 [3 1 0 0 1] (0.33543893173498296),
 [0 0 1 1 0] (0.0017534551604061264),
 [0 0 1 0 1] (0.0010127514448150464),
 [2 0 1 0 1] (0.04765593309469408)}

**** (test-markings (get nnns [3 0 1 1 0]))   :fires-on {[3 0 1 1 0] 491}},
{[0 1 0 1 0] (0.0014487996373689941),
 [3 1 0 1 0] (0.21293141920670883),
 [2 0 1 1 0] (0.15438051750729484),
 [1 1 0 1 0] (0.005105555396279919),
 [3 0 1 0 1] (0.05425027679413153),
 [1 0 1 1 0] (0.017136382643884614),
 [0 1 0 0 1] (4.6382801763844935E-4),
 [2 1 0 1 0] (0.03850346112492955),
 [3 0 1 1 0] (0.39880145491033164), ----- This IS fires-on. (next best is 0.213) 
 [1 0 1 0 1] (0.006230800133017719),
 [3 1 0 0 1] (0.03105553855253639),
 [0 0 1 1 0] (0.002015237400342786),
 [0 0 1 0 1] (0.001066242446042215),
 [2 0 1 0 1] (0.022575588402398115)}

**** (test-markings (get nnns [1 0 1 1 0]))   :fires-on {[1 0 1 1 0] 388}}}
{[0 1 0 1 0] (0.014569799679218615),
 [3 1 0 1 0] (0.6721408448530173),
 [2 0 1 1 0] (0.6688434016370715),
 [1 1 0 1 0] (0.21941460772717947),
 [3 0 1 0 1] (0.6601096030824811),
 [1 0 1 1 0] (0.46608997395936497),
 [0 1 0 0 1] (0.001252201438882003),
 [2 1 0 1 0] (0.5432656472113356),
 [3 0 1 1 0] (0.7113587186344846),  --- (next best is 0.672, which is [3 1 0 1 0]
 [1 0 1 0 1] (0.033295385315624364),
 [3 1 0 0 1] (0.5286157002824883),
 [0 0 1 1 0] (0.04039619976094015),
 [0 0 1 0 1] (0.00328347348876465),
 [2 0 1 0 1] (0.41021721559535307)}




**** Advantage: 
     The correct starting state has fewer false positives. It will do best. 

n**** Problem: 
     The algorithm is just going to focus on the buffer being high/low. This is fine for 
     blocking/starving events but not good for state-but-not-transition situations.

** <2017-10-15 Sun>
*** I ended up with data that blocks 30 times and starves 14 times: 
This was after about 30 experiments, fine tuning the parameters. The problem is that it
is very easy to get very short blocking/starving periods. 
Input:   file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild.clj]]
Output:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj:::status%20nil,][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-b30-s14.clj]]
Pretty:  [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj::%5B][file:~/Documents/git/sinet/data/SCADA-logs/m2-j1-n3-block-mild-out.clj]]
*** This was achieved with these parameters:
#+BEGIN_SRC clojure
  (map->Model
   {:line 
    {:m1 (map->ExpoMachine {:lambda 0.6 :mu 3.5 :W 1.0}) 
     :b1 (map->Buffer {:N 3})
     :m2 (map->ExpoMachine {:lambda 0.001 :mu 0.99 :W 1.0})}
    :number-of-simulations 1
    :report {:log? true :max-lines 3000}
    :topology [:m1 :b1 :m2]
    :entry-point :m1
    :params {:warm-up-time 2000 :run-to-time 10000}
    :jobmix {:jobType1 (map->JobType {:portion 1.0 :w {:m1 1.0, :m2 1.17}})}})
#+END_SRC
*** The m2-j1-n3 PN 
#+BEGIN_SRC clojure
{:places
 [{:name :buffer, :pid 0, :initial-tokens 0}
  {:name :m1-blocked, :pid 1, :initial-tokens 0}
  {:name :m1-busy, :pid 2, :initial-tokens 1}
  {:name :m2-busy, :pid 3, :initial-tokens 1}
  {:name :m2-starved, :pid 4, :initial-tokens 0}],
 :transitions
 [{:name :m1-complete-job, :tid 6, :type :exponential, :rate 0.9}
  {:name :m1-start-job, :tid 7, :type :immediate, :rate 1.0}
  {:name :m2-complete-job, :tid 8, :type :exponential, :rate 1.0}
  {:name :m2-start-job, :tid 9, :type :immediate, :rate 1.0}],
 :arcs
 [{:aid 10, :source :buffer, :target :m1-start-job, :name :aa-10, :type :inhibitor, :multiplicity 3, :bind {:jtype :blue}, :priority 1}
  {:aid 11, :source :buffer, :target :m2-start-job, :name :aa-11, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 12, :source :m1-blocked, :target :m1-start-job, :name :aa-12, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 13, :source :m1-busy, :target :m1-complete-job, :name :aa-13, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 14, :source :m1-complete-job, :target :m1-blocked, :name :aa-14, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 15, :source :m1-start-job, :target :buffer, :name :aa-15, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 2}
  {:aid 16, :source :m1-start-job, :target :m1-busy, :name :aa-16, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 17, :source :m2-busy, :target :m2-complete-job, :name :aa-17, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 18, :source :m2-complete-job, :target :m2-starved, :name :aa-18, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 19, :source :m2-start-job, :target :m2-busy, :name :aa-19, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}
  {:aid 20, :source :m2-starved, :target :m2-start-job, :name :aa-20, :type :normal, :multiplicity 1, :bind {:jtype :blue}, :priority 1}]}
#+END_SRC 
 
*** Does it make sense to have an entry point with no :fire-ons?  (Yes, but...)
 I get two entry point markings, only one has anything in :fires-on. 
 I search for 50 steps supposedly, but it goes 225 lines, ending on the only exceptional msg, 
 which is {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]}. None of that should matter, we
 aren't looking for exceptional one yet. 
**** Is the problem that it is using the short data?
**** Yeah, ok this is wrong! : 
     (def foo (interpret-scada reach1 (-> (app-info) :problem :scada-log) lili))
     (count foo) ==> 225
     So I have been using the wrong data all the time, or it is stopping early?
     Good! It is stopping after 225 (the other goes 3000). I'm guessing that it gets 
     stuck in a situation it cannot interpret. Verify...
   
     Here is the new "failed-on" information:
     {:failed-prior   {:M [1 0 1 1 0], :fire :m2-complete-job, :Mp [1 0 1 0 1], :rate 1.0, :indx 224},
      :failed-on-link {:act :m2-starved, :indx 225, :Mp [1 0 1 0 1]},
      :failed-on-msg  {:act :m1-complete-job, :bf :b1, :j 1745, :n 0, :clk 2067.08452126566, :line 226, :mjpact :bj, :m :m1}}

     According to the reachability graph, the only thing that can occur after [1 0 1 0 1] is :m2-start-job
     {:M [1 0 1 0 1], :fire :m2-start-job, :Mp [0 0 1 1 0], :rate 1.0}
     That makes sense because ...
      [:buffer     1
       :m1-blocked 0
       :m1-busy    1
       :m2-busy    0
       :m2-starved 1]
      ... No, it doesn't make sense. [1 1 0 0 1] should also be possible. This is a vanishing transition to :m1-blocked.
***** BUG 
      The reachability graph must be wrong, but before I fix it, I won't build nets where :failed-on-msg is on last. DONE. 
      Something is seriously wrong. I created pnml for the N=3 PN but I don't get the same reachability as I did earlier
      (def reach1 ...) This one is much smaller. 

      Even the N=1 net is wrong. It should have 12 links, not 10:
      [[file:~/TwoDrive/OneDrive/Repo/mindmaps/images/m2-n1-no-immediate-reach.jpg]]

      First of all, these PNs have immediate transitions. 
          
      This is bad, there should be two here!    
    
      (next-links pnpn [0 1 0 1 0])
      [{:M [0 1 0 1 0], :fire :m1-start-job, :Mp [1 0 1 1 0], :rate 1.0}]
      The problem was that I was not setting all transitions to timed. THIS MAY NEED MORE THOUGHT (to TODO)
*** So now I have larger rgraphs (e.g. 28 vs 18 for N=3) do things still work?
**** DONE write code to generate simple-reach
     CLOSED: [2017-10-15 Sun 20:07]
**** write fitness assessment. 
*** Junk I'll probably never use
#_(defn prev-ordinary
  "Return an ordinary message, at index n or earlier."
  [data n]
  (loop [indx n]
    (cond (ordinary? (nth data indx)) (nth data indx), 
          (== indx 0) nil
          :otherwise (recur (dec indx)))))

(defn big-train
  ([net] (big-train net :m1-blocked 1))
  ([net msg-type cnt]
   (reduce (fn [n _] (train-msg n msg-type))
           net
           (range cnt))))

;;; POD This is for :m2-starved. 
(defn more-exceptional-training
  [net cnt]
  (reduce (fn [n _]
            (nn/train-step net [0.0 0.0 1.0 0.0 1.0] [1.0]))
          net
          (range cnt)))


*** DONE Write code to defobulate/zipmap (and pick best???)
    CLOSED: [2017-10-17 Tue 14:17]
** <2017-10-16 Mon>
 So far there is only one NN per message. 

I cleaned things up so that I get one NN per message. 

I studied Probabilistic Neural Nets briefly. They require one neuron for each training instance
and therefore for my application I think would be equivalent of a lookup table encompasing the whole
training set. I think they make more sense when there are points "between" the elements in the
training set. (Do I have these???) Needs more study, but maybe not so promising.

Let's look at how these things do against the 

** <2017-10-17 Tue>

*** Cortex
Cortex layer types (what I'm seeing [[https://github.com/thinktopic/cortex/commit/4be1c559675b9612249abbb94963d989d70817fe][here]]): convolutional, max-pooling, dropout, relu, linear, softmax.
But *this* matters: [[https://machinelearningmastery.com/confusion-matrix-machine-learning/][Confusion matrix]]: Describes what one is and how to calculate one for the 2-class
classification problem!

*** Confusion matrix
"A confusion matrix is a technique for summarizing the performance of a classification algorithm."
Thus if I have one of these, I can use it directly to determine the fitness of the combination of
PN + NNs as an identification of the system. 

Easy enough. Should also look at precision, recall, specificity and sensitivity. 
These are all defined on this [[https://en.wikipedia.org/wiki/Confusion_matrix][wikipedia page]]. I also have a paper by D. M. W. Powers in the ML
section of Mendeley.

*** fitness.clj
I think before I go much further, I have to fix the problem any problems deciding the class. 
I had hoped that it was just a matter of choosing marking > 0.5. Is this the case? 

HELP! No marking hits on any exceptional message. I don't think I have looked at results
since the "dense" exceptional messages of Saturday. 

*** What does the marking used as input to training mean?
    I was hoping that it was the marking just before the message is issued. 
    Messages are issued on complete-job / start-job but MJPdes doesn't 
    order these where they all happen simultaneously. Maybe it should???

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
 {:msg-type :m1-blocked,   [3 0 1 1 0] 30} ... I assume next msg is m1-complete-job
 {:msg-type :m1-unblocked, [2 1 0 1 0] 30} ... 
 {:msg-type :m2-starved,   [0 0 1 0 1] 14} 
 {:msg-type :m2-unstarved, [0 0 1 1 0] 14} 
 
Let's generate the interpretation [[file:~/Documents/git/sinet/data/SCADA-logs/m2-j2-n3-block-mild-interpreted.clj::{:act%20:m1-blocked,%20:prev-act%20:m1-start-job,%20:indx%20710,%20:Mp%20%5B3%200%201%201%200%5D,%20:clk%202206.0879216608246}][AND SAVE IT AS A FILE]]. 

Start link is the same for all 4 message types, yet I interpret the log four times. Nice. 
    
**** Typical output with "data/SCADA-logs/m2-j1-n3-block-mild-out.clj"       
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-blocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.024485036900973763,
 [3 1 0 1 0] 0.008046179155291305,
 [2 0 1 1 0] 0.004074497484690655,
 [1 1 0 1 0] 0.013784127155537253,
 [3 0 1 0 1] 0.004062515347353122,
 [1 0 1 1 0] 0.005371589317720032,
 [0 1 0 0 1] 0.0521152547076084, <-- wrong, and next best is 0.027
 [2 1 0 1 0] 0.009709532322778542,
 [3 0 1 1 0] 0.003524192574949857,
 [1 0 1 0 1] 0.009338700112664192,
 [3 1 0 0 1] 0.010161648095898495,
 [0 0 1 1 0] 0.008800298059058962,
 [1 1 0 0 1] 0.026920570777390792,
 [0 0 1 0 1] 0.01845261113215176,
 [2 1 0 0 1] 0.014811122272394004,
 [2 0 1 0 1] 0.0055072388527700866}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m1-unblocked nnns) %)) markings1)))
{[0 1 0 1 0] 0.025163102369711258,
 [3 1 0 1 0] 0.016114179019312516,
 [2 0 1 1 0] 0.007977926858371297,
 [1 1 0 1 0] 0.0201854362883496,
 [3 0 1 0 1] 0.014301613606198235,
 [1 0 1 1 0] 0.008978827733614799,
 [0 1 0 0 1] 0.06621052090624126,  <--- wrong, next is 0.036
 [2 1 0 1 0] 0.01751290729163327,
 [3 0 1 1 0] 0.007622303706912641,
 [1 0 1 0 1] 0.018487183654880144,
 [3 1 0 0 1] 0.029438724652992698,
 [0 0 1 1 0] 0.01104428285399589,
 [1 1 0 0 1] 0.04735457640118155,
 [0 0 1 0 1] 0.02363169658896575,
 [2 1 0 0 1] 0.036172647847275446,
 [2 0 1 0 1] 0.01569931368097529}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-starved nnns) %)) markings1)))

[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.017027576075899276,
 [3 1 0 1 0] 0.004886266737864184,
 [2 0 1 1 0] 0.006935985604851713,
 [1 1 0 1 0] 0.008132810057098754,
 [3 0 1 0 1] 0.008690333194503956,
 [1 0 1 1 0] 0.011443272037409967,
 [0 1 0 0 1] 0.06431606145668564,
 [2 1 0 1 0] 0.005697633024429593,
 [3 0 1 1 0] 0.005600030048084727,
 [1 0 1 0 1] 0.03823100286076116,
 [3 1 0 0 1] 0.00657718778677882,
 [0 0 1 1 0] 0.029978431187203013,
 [1 1 0 0 1] 0.019941922787321802,
 [0 0 1 0 1] 0.11582262659576607, <-- yes. next is 0.064
 [2 1 0 0 1] 0.00937067227357531,
 [2 0 1 0 1] 0.014909753268535426}
nil
gov.nist.sinet.fitness> (ppprint (zipmap markings1
                                         (map #(first (nn/eval-net (:m2-unstarved nnns) %)) markings1)))
[:buffer :m1-blocked :m1-busy :m2-busy :m2-starved]
{[0 1 0 1 0] 0.026026209106502097,
 [3 1 0 1 0] 0.0034988958592581513,
 [2 0 1 1 0] 0.00601129014254703,
 [1 1 0 1 0] 0.010186463188839843,
 [3 0 1 0 1] 0.0033239310083816543,
 [1 0 1 1 0] 0.011904922484223533,
 [0 1 0 0 1] 0.016127654355549154,
 [2 1 0 1 0] 0.00529834749317781,
 [3 0 1 1 0] 0.00385956712448291,
 [1 0 1 0 1] 0.008798843571705668,
 [3 1 0 0 1] 0.0029969968812421986,
 [0 0 1 1 0] 0.03188710693160681, <--- I guess...what does the marking mean???
 [1 1 0 0 1] 0.007127766343136932,
 [0 0 1 0 1] 0.020988809038561193,
 [2 1 0 0 1] 0.004186967134676599,
 [2 0 1 0 1] 0.00488250449212974}
nil
gov.nist.sinet.fitness> 


Let's go back to the dense messages and see if we still get good results.

